/* besfactoryC.cpp
   Generated by gSOAP 2.7.11 from ./wsdl/wsdl/bes-factory.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "besfactoryH.h"

namespace besfactory {

SOAP_SOURCE_STAMP("@(#) besfactoryC.cpp ver 2.7.11 2008-09-23 14:41:30 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_besfactory_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_besfactory_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_besfactory_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_besfactory_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_besfactory_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration:
		return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration:
		return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration:
		return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration:
		return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesType:
		return soap_in_besfactory2__FaultCodesType(soap, NULL, NULL, "besfactory2:FaultCodesType");
	case SOAP_TYPE_besfactory_besfactory2__RelationshipType:
		return soap_in_besfactory2__RelationshipType(soap, NULL, NULL, "besfactory2:RelationshipType");
	case SOAP_TYPE_besfactory_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType__:
		return soap_in_jsdl__Description_USCOREType__(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType:
		return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_:
		return soap_in_jsdl__CreationFlagEnumeration_(soap, NULL, NULL, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_:
		return soap_in_jsdl__FileSystemTypeEnumeration_(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_:
		return soap_in_jsdl__OperatingSystemTypeEnumeration_(soap, NULL, NULL, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_:
		return soap_in_jsdl__ProcessorArchitectureEnumeration_(soap, NULL, NULL, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesType_:
		return soap_in_besfactory2__FaultCodesType_(soap, NULL, NULL, "besfactory2:FaultCodesType");
	case SOAP_TYPE_besfactory_besfactory2__RelationshipType_:
		return soap_in_besfactory2__RelationshipType_(soap, NULL, NULL, "besfactory2:RelationshipType");
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType:
		return soap_in_besfactory2__FaultCodesOpenEnumType(soap, NULL, NULL, "besfactory2:FaultCodesOpenEnumType");
	case SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum:
		return soap_in_besfactory2__RelationshipTypeOpenEnum(soap, NULL, NULL, "besfactory2:RelationshipTypeOpenEnum");
	case SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType:
		return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType:
		return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType:
		return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType:
		return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType:
		return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType:
		return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType:
		return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_besfactory_jsdl__Resources_USCOREType:
		return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_besfactory_jsdl__Application_USCOREType:
		return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType:
		return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType:
		return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType:
		return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType:
		return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_besfactory_jsdl__Range_USCOREType:
		return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_besfactory_jsdl__Exact_USCOREType:
		return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType:
		return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_besfactory_besfactory2__ProblemActionType:
		return soap_in_besfactory2__ProblemActionType(soap, NULL, NULL, "besfactory2:ProblemActionType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedAnyType:
		return soap_in_besfactory2__AttributedAnyType(soap, NULL, NULL, "besfactory2:AttributedAnyType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedQNameType:
		return soap_in_besfactory2__AttributedQNameType(soap, NULL, NULL, "besfactory2:AttributedQNameType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType:
		return soap_in_besfactory2__AttributedUnsignedLongType(soap, NULL, NULL, "besfactory2:AttributedUnsignedLongType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedURIType:
		return soap_in_besfactory2__AttributedURIType(soap, NULL, NULL, "besfactory2:AttributedURIType");
	case SOAP_TYPE_besfactory_besfactory2__RelatesToType:
		return soap_in_besfactory2__RelatesToType(soap, NULL, NULL, "besfactory2:RelatesToType");
	case SOAP_TYPE_besfactory_besfactory2__MetadataType:
		return soap_in_besfactory2__MetadataType(soap, NULL, NULL, "besfactory2:MetadataType");
	case SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType:
		return soap_in_besfactory2__ReferenceParametersType(soap, NULL, NULL, "besfactory2:ReferenceParametersType");
	case SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType:
		return soap_in_besfactory2__EndpointReferenceType(soap, NULL, NULL, "besfactory2:EndpointReferenceType");
	case SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType:
		return soap_in_besfactory__UnsupportedFeatureFaultType(soap, NULL, NULL, "besfactory:UnsupportedFeatureFaultType");
	case SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType:
		return soap_in_besfactory__UnsupportedJSDLVersionFaultType(soap, NULL, NULL, "besfactory:UnsupportedJSDLVersionFaultType");
	case SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType:
		return soap_in_besfactory__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, "besfactory:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType:
		return soap_in_besfactory__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, "besfactory:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType:
		return soap_in_besfactory__GetFactoryAttributesDocumentType(soap, NULL, NULL, "besfactory:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType:
		return soap_in_besfactory__GetActivityDocumentsResponseType(soap, NULL, NULL, "besfactory:GetActivityDocumentsResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType:
		return soap_in_besfactory__GetActivityDocumentsType(soap, NULL, NULL, "besfactory:GetActivityDocumentsType");
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType:
		return soap_in_besfactory__TerminateActivitiesResponseType(soap, NULL, NULL, "besfactory:TerminateActivitiesResponseType");
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType:
		return soap_in_besfactory__TerminateActivitiesType(soap, NULL, NULL, "besfactory:TerminateActivitiesType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType:
		return soap_in_besfactory__GetActivityStatusesResponseType(soap, NULL, NULL, "besfactory:GetActivityStatusesResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType:
		return soap_in_besfactory__GetActivityStatusesType(soap, NULL, NULL, "besfactory:GetActivityStatusesType");
	case SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType:
		return soap_in_besfactory__CreateActivityResponseType(soap, NULL, NULL, "besfactory:CreateActivityResponseType");
	case SOAP_TYPE_besfactory_besfactory__CreateActivityType:
		return soap_in_besfactory__CreateActivityType(soap, NULL, NULL, "besfactory:CreateActivityType");
	case SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType:
		return soap_in_besfactory__TerminateActivityResponseType(soap, NULL, NULL, "besfactory:TerminateActivityResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType:
		return soap_in_besfactory__GetActivityDocumentResponseType(soap, NULL, NULL, "besfactory:GetActivityDocumentResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType:
		return soap_in_besfactory__GetActivityStatusResponseType(soap, NULL, NULL, "besfactory:GetActivityStatusResponseType");
	case SOAP_TYPE_besfactory_besfactory__ActivityStatusType:
		return soap_in_besfactory__ActivityStatusType(soap, NULL, NULL, "besfactory:ActivityStatusType");
	case SOAP_TYPE_besfactory_besfactory__ActivityStateType:
		return soap_in_besfactory__ActivityStateType(soap, NULL, NULL, "besfactory:ActivityStateType");
	case SOAP_TYPE_besfactory_besfactory__ActivityDocumentType:
		return soap_in_besfactory__ActivityDocumentType(soap, NULL, NULL, "besfactory:ActivityDocumentType");
	case SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType:
		return soap_in_besfactory__FactoryResourceAttributesDocumentType(soap, NULL, NULL, "besfactory:FactoryResourceAttributesDocumentType");
	case SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType:
		return soap_in_besfactory__BasicFactoryResourceAttributesDocumentType(soap, NULL, NULL, "besfactory:BasicFactoryResourceAttributesDocumentType");
	case SOAP_TYPE_besfactory_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_besfactory_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_besfactory_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_besfactory_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_besfactory_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_besfactory_xsd__anyURI_:
		return soap_in_xsd__anyURI_(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_besfactory_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_besfactory_xsd__QName_:
		return soap_in_xsd__QName_(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_besfactory_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_besfactory_xsd__NCName_:
		return soap_in_xsd__NCName_(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_besfactory_xsd__NCName:
		return soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_besfactory_xsd__ID_:
		return soap_in_xsd__ID_(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_besfactory_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_besfactory_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_besfactory_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentResponseType:
		return soap_in_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, "besfactory:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentType:
		return soap_in_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, NULL, NULL, "besfactory:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsResponseType:
		return soap_in_PointerTobesfactory__GetActivityDocumentsResponseType(soap, NULL, NULL, "besfactory:GetActivityDocumentsResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsType:
		return soap_in_PointerTobesfactory__GetActivityDocumentsType(soap, NULL, NULL, "besfactory:GetActivityDocumentsType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesResponseType:
		return soap_in_PointerTobesfactory__TerminateActivitiesResponseType(soap, NULL, NULL, "besfactory:TerminateActivitiesResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesType:
		return soap_in_PointerTobesfactory__TerminateActivitiesType(soap, NULL, NULL, "besfactory:TerminateActivitiesType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesResponseType:
		return soap_in_PointerTobesfactory__GetActivityStatusesResponseType(soap, NULL, NULL, "besfactory:GetActivityStatusesResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesType:
		return soap_in_PointerTobesfactory__GetActivityStatusesType(soap, NULL, NULL, "besfactory:GetActivityStatusesType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityResponseType:
		return soap_in_PointerTobesfactory__CreateActivityResponseType(soap, NULL, NULL, "besfactory:CreateActivityResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityType:
		return soap_in_PointerTobesfactory__CreateActivityType(soap, NULL, NULL, "besfactory:CreateActivityType");
	case SOAP_TYPE_besfactory_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_besfactory_PointerTojsdl__SourceTarget_USCOREType:
		return soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_besfactory_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_PointerTojsdl__RangeValue_USCOREType:
		return soap_in_PointerTojsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_besfactory_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_besfactory_PointerTojsdl__FileSystem_USCOREType:
		return soap_in_PointerTojsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Description_USCOREType:
		return soap_in_PointerTojsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_besfactory_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_besfactory_PointerTojsdl__DataStaging_USCOREType:
		return soap_in_PointerTojsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Resources_USCOREType:
		return soap_in_PointerTojsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Application_USCOREType:
		return soap_in_PointerTojsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__JobIdentification_USCOREType:
		return soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_besfactory_PointerToxsd__ID:
		return soap_in_PointerToxsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_besfactory_PointerTojsdl__JobDescription_USCOREType:
		return soap_in_PointerTojsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Range_USCOREType:
		return soap_in_PointerTojsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Exact_USCOREType:
		return soap_in_PointerTojsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Boundary_USCOREType:
		return soap_in_PointerTojsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_besfactory_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__MetadataType:
		return soap_in_PointerTobesfactory2__MetadataType(soap, NULL, NULL, "besfactory2:MetadataType");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__ReferenceParametersType:
		return soap_in_PointerTobesfactory2__ReferenceParametersType(soap, NULL, NULL, "besfactory2:ReferenceParametersType");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__AttributedURIType:
		return soap_in_PointerTobesfactory2__AttributedURIType(soap, NULL, NULL, "besfactory2:AttributedURIType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__FactoryResourceAttributesDocumentType:
		return soap_in_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, NULL, NULL, "besfactory:FactoryResourceAttributesDocumentType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentResponseType:
		return soap_in_PointerTobesfactory__GetActivityDocumentResponseType(soap, NULL, NULL, "besfactory:GetActivityDocumentResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivityResponseType:
		return soap_in_PointerTobesfactory__TerminateActivityResponseType(soap, NULL, NULL, "besfactory:TerminateActivityResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusResponseType:
		return soap_in_PointerTobesfactory__GetActivityStatusResponseType(soap, NULL, NULL, "besfactory:GetActivityStatusResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityDocumentType:
		return soap_in_PointerTobesfactory__ActivityDocumentType(soap, NULL, NULL, "besfactory:ActivityDocumentType");
	case SOAP_TYPE_besfactory_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStatusType:
		return soap_in_PointerTobesfactory__ActivityStatusType(soap, NULL, NULL, "besfactory:ActivityStatusType");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__EndpointReferenceType:
		return soap_in_PointerTobesfactory2__EndpointReferenceType(soap, NULL, NULL, "besfactory2:EndpointReferenceType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStateType:
		return soap_in_PointerTobesfactory__ActivityStateType(soap, NULL, NULL, "besfactory:ActivityStateType");
	case SOAP_TYPE_besfactory_PointerTojsdl__JobDefinition_USCOREType:
		return soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_besfactory_PointerTounsignedLONG64:
		return soap_in_PointerTounsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_besfactory_PointerTounsignedInt:
		return soap_in_PointerTounsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_besfactory_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_besfactory_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "jsdl:Description_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__Description_USCOREType__;
			return soap_in_jsdl__Description_USCOREType__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Description_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__Description_USCOREType;
			return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CreationFlagEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_;
			return soap_in_jsdl__CreationFlagEnumeration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_;
			return soap_in_jsdl__FileSystemTypeEnumeration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_;
			return soap_in_jsdl__OperatingSystemTypeEnumeration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:ProcessorArchitectureEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_;
			return soap_in_jsdl__ProcessorArchitectureEnumeration_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:FaultCodesType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__FaultCodesType_;
			return soap_in_besfactory2__FaultCodesType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:RelationshipType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__RelationshipType_;
			return soap_in_besfactory2__RelationshipType_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:FaultCodesOpenEnumType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType;
			return soap_in_besfactory2__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:RelationshipTypeOpenEnum"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum;
			return soap_in_besfactory2__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:SourceTarget_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType;
			return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:DataStaging_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType;
			return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType;
			return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystem_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType;
			return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystem_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType;
			return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType;
			return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CandidateHosts_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType;
			return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Resources_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__Resources_USCOREType;
			return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Application_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__Application_USCOREType;
			return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobIdentification_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType;
			return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDescription_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType;
			return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDefinition_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType;
			return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:RangeValue_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType;
			return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Range_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__Range_USCOREType;
			return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Exact_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__Exact_USCOREType;
			return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Boundary_Type"))
		{	*type = SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType;
			return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:ProblemActionType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__ProblemActionType;
			return soap_in_besfactory2__ProblemActionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:AttributedAnyType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__AttributedAnyType;
			return soap_in_besfactory2__AttributedAnyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:AttributedQNameType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__AttributedQNameType;
			return soap_in_besfactory2__AttributedQNameType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:AttributedUnsignedLongType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType;
			return soap_in_besfactory2__AttributedUnsignedLongType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:AttributedURIType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__AttributedURIType;
			return soap_in_besfactory2__AttributedURIType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:RelatesToType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__RelatesToType;
			return soap_in_besfactory2__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:MetadataType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__MetadataType;
			return soap_in_besfactory2__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:ReferenceParametersType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType;
			return soap_in_besfactory2__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:EndpointReferenceType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType;
			return soap_in_besfactory2__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:UnsupportedFeatureFaultType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType;
			return soap_in_besfactory__UnsupportedFeatureFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:UnsupportedJSDLVersionFaultType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType;
			return soap_in_besfactory__UnsupportedJSDLVersionFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:NotAcceptingNewActivitiesFaultType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType;
			return soap_in_besfactory__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetFactoryAttributesDocumentResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType;
			return soap_in_besfactory__GetFactoryAttributesDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetFactoryAttributesDocumentType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType;
			return soap_in_besfactory__GetFactoryAttributesDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetActivityDocumentsResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType;
			return soap_in_besfactory__GetActivityDocumentsResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetActivityDocumentsType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType;
			return soap_in_besfactory__GetActivityDocumentsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:TerminateActivitiesResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType;
			return soap_in_besfactory__TerminateActivitiesResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:TerminateActivitiesType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType;
			return soap_in_besfactory__TerminateActivitiesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetActivityStatusesResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType;
			return soap_in_besfactory__GetActivityStatusesResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetActivityStatusesType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType;
			return soap_in_besfactory__GetActivityStatusesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:CreateActivityResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType;
			return soap_in_besfactory__CreateActivityResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:CreateActivityType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__CreateActivityType;
			return soap_in_besfactory__CreateActivityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:TerminateActivityResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType;
			return soap_in_besfactory__TerminateActivityResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetActivityDocumentResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType;
			return soap_in_besfactory__GetActivityDocumentResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:GetActivityStatusResponseType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType;
			return soap_in_besfactory__GetActivityStatusResponseType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:ActivityStatusType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__ActivityStatusType;
			return soap_in_besfactory__ActivityStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:ActivityStateType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__ActivityStateType;
			return soap_in_besfactory__ActivityStateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:ActivityDocumentType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__ActivityDocumentType;
			return soap_in_besfactory__ActivityDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:FactoryResourceAttributesDocumentType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType;
			return soap_in_besfactory__FactoryResourceAttributesDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory:BasicFactoryResourceAttributesDocumentType"))
		{	*type = SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType;
			return soap_in_besfactory__BasicFactoryResourceAttributesDocumentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_besfactory_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_besfactory_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_besfactory_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_besfactory_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_besfactory_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_besfactory_xsd__anyURI_;
			return soap_in_xsd__anyURI_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_besfactory_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_besfactory_xsd__QName_;
			return soap_in_xsd__QName_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_besfactory_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_besfactory_xsd__NCName_;
			return soap_in_xsd__NCName_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_besfactory_xsd__NCName;
			return soap_in_xsd__NCName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_besfactory_xsd__ID_;
			return soap_in_xsd__ID_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_besfactory_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_besfactory_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_besfactory_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_besfactory_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_besfactory_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_besfactory_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_besfactory_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_besfactory_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CreationFlagEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration;
			return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration;
			return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration;
			return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:ProcessorArchitectureEnumeration"))
		{	*type = SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration;
			return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:FaultCodesType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__FaultCodesType;
			return soap_in_besfactory2__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "besfactory2:RelationshipType"))
		{	*type = SOAP_TYPE_besfactory_besfactory2__RelationshipType;
			return soap_in_besfactory2__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_besfactory_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_besfactory_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_besfactory__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_besfactory_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_besfactory_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_besfactory_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_besfactory_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_besfactory_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration:
		return soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, (const enum jsdl__CreationFlagEnumeration *)ptr, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration:
		return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration:
		return soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration:
		return soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesType:
		return soap_out_besfactory2__FaultCodesType(soap, tag, id, (const enum besfactory2__FaultCodesType *)ptr, "besfactory2:FaultCodesType");
	case SOAP_TYPE_besfactory_besfactory2__RelationshipType:
		return soap_out_besfactory2__RelationshipType(soap, tag, id, (const enum besfactory2__RelationshipType *)ptr, "besfactory2:RelationshipType");
	case SOAP_TYPE_besfactory_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType__:
		return ((jsdl__Description_USCOREType__ *)ptr)->soap_out(soap, tag, id, "jsdl:Description_Type");
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType:
		return soap_out_jsdl__Description_USCOREType(soap, tag, id, (const std::string *)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_:
		return ((jsdl__CreationFlagEnumeration_ *)ptr)->soap_out(soap, tag, id, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_:
		return ((jsdl__FileSystemTypeEnumeration_ *)ptr)->soap_out(soap, tag, id, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_:
		return ((jsdl__OperatingSystemTypeEnumeration_ *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_:
		return ((jsdl__ProcessorArchitectureEnumeration_ *)ptr)->soap_out(soap, tag, id, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesType_:
		return ((besfactory2__FaultCodesType_ *)ptr)->soap_out(soap, tag, id, "besfactory2:FaultCodesType");
	case SOAP_TYPE_besfactory_besfactory2__RelationshipType_:
		return ((besfactory2__RelationshipType_ *)ptr)->soap_out(soap, tag, id, "besfactory2:RelationshipType");
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType:
		return soap_out_besfactory2__FaultCodesOpenEnumType(soap, tag, id, (const std::string *)ptr, "besfactory2:FaultCodesOpenEnumType");
	case SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum:
		return soap_out_besfactory2__RelationshipTypeOpenEnum(soap, tag, id, (const std::string *)ptr, "besfactory2:RelationshipTypeOpenEnum");
	case SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType:
		return ((jsdl__SourceTarget_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType:
		return ((jsdl__DataStaging_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:DataStaging_Type");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType:
		return ((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType:
		return ((jsdl__OperatingSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType:
		return ((jsdl__FileSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:FileSystem_Type");
	case SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType:
		return ((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType:
		return ((jsdl__CandidateHosts_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_besfactory_jsdl__Resources_USCOREType:
		return ((jsdl__Resources_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Resources_Type");
	case SOAP_TYPE_besfactory_jsdl__Application_USCOREType:
		return ((jsdl__Application_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Application_Type");
	case SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType:
		return ((jsdl__JobIdentification_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType:
		return ((jsdl__JobDescription_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDescription_Type");
	case SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType:
		return ((jsdl__JobDefinition_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType:
		return ((jsdl__RangeValue_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:RangeValue_Type");
	case SOAP_TYPE_besfactory_jsdl__Range_USCOREType:
		return ((jsdl__Range_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Range_Type");
	case SOAP_TYPE_besfactory_jsdl__Exact_USCOREType:
		return ((jsdl__Exact_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Exact_Type");
	case SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType:
		return ((jsdl__Boundary_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Boundary_Type");
	case SOAP_TYPE_besfactory_besfactory2__ProblemActionType:
		return ((besfactory2__ProblemActionType *)ptr)->soap_out(soap, tag, id, "besfactory2:ProblemActionType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedAnyType:
		return ((besfactory2__AttributedAnyType *)ptr)->soap_out(soap, tag, id, "besfactory2:AttributedAnyType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedQNameType:
		return ((besfactory2__AttributedQNameType *)ptr)->soap_out(soap, tag, id, "besfactory2:AttributedQNameType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType:
		return ((besfactory2__AttributedUnsignedLongType *)ptr)->soap_out(soap, tag, id, "besfactory2:AttributedUnsignedLongType");
	case SOAP_TYPE_besfactory_besfactory2__AttributedURIType:
		return ((besfactory2__AttributedURIType *)ptr)->soap_out(soap, tag, id, "besfactory2:AttributedURIType");
	case SOAP_TYPE_besfactory_besfactory2__RelatesToType:
		return ((besfactory2__RelatesToType *)ptr)->soap_out(soap, tag, id, "besfactory2:RelatesToType");
	case SOAP_TYPE_besfactory_besfactory2__MetadataType:
		return ((besfactory2__MetadataType *)ptr)->soap_out(soap, tag, id, "besfactory2:MetadataType");
	case SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType:
		return ((besfactory2__ReferenceParametersType *)ptr)->soap_out(soap, tag, id, "besfactory2:ReferenceParametersType");
	case SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType:
		return ((besfactory2__EndpointReferenceType *)ptr)->soap_out(soap, tag, id, "besfactory2:EndpointReferenceType");
	case SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType:
		return ((besfactory__UnsupportedFeatureFaultType *)ptr)->soap_out(soap, tag, id, "besfactory:UnsupportedFeatureFaultType");
	case SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType:
		return ((besfactory__UnsupportedJSDLVersionFaultType *)ptr)->soap_out(soap, tag, id, "besfactory:UnsupportedJSDLVersionFaultType");
	case SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType:
		return ((besfactory__NotAcceptingNewActivitiesFaultType *)ptr)->soap_out(soap, tag, id, "besfactory:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType:
		return ((besfactory__GetFactoryAttributesDocumentResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType:
		return ((besfactory__GetFactoryAttributesDocumentType *)ptr)->soap_out(soap, tag, id, "besfactory:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType:
		return ((besfactory__GetActivityDocumentsResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:GetActivityDocumentsResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType:
		return ((besfactory__GetActivityDocumentsType *)ptr)->soap_out(soap, tag, id, "besfactory:GetActivityDocumentsType");
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType:
		return ((besfactory__TerminateActivitiesResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:TerminateActivitiesResponseType");
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType:
		return ((besfactory__TerminateActivitiesType *)ptr)->soap_out(soap, tag, id, "besfactory:TerminateActivitiesType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType:
		return ((besfactory__GetActivityStatusesResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:GetActivityStatusesResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType:
		return ((besfactory__GetActivityStatusesType *)ptr)->soap_out(soap, tag, id, "besfactory:GetActivityStatusesType");
	case SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType:
		return ((besfactory__CreateActivityResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:CreateActivityResponseType");
	case SOAP_TYPE_besfactory_besfactory__CreateActivityType:
		return ((besfactory__CreateActivityType *)ptr)->soap_out(soap, tag, id, "besfactory:CreateActivityType");
	case SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType:
		return ((besfactory__TerminateActivityResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:TerminateActivityResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType:
		return ((besfactory__GetActivityDocumentResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:GetActivityDocumentResponseType");
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType:
		return ((besfactory__GetActivityStatusResponseType *)ptr)->soap_out(soap, tag, id, "besfactory:GetActivityStatusResponseType");
	case SOAP_TYPE_besfactory_besfactory__ActivityStatusType:
		return ((besfactory__ActivityStatusType *)ptr)->soap_out(soap, tag, id, "besfactory:ActivityStatusType");
	case SOAP_TYPE_besfactory_besfactory__ActivityStateType:
		return ((besfactory__ActivityStateType *)ptr)->soap_out(soap, tag, id, "besfactory:ActivityStateType");
	case SOAP_TYPE_besfactory_besfactory__ActivityDocumentType:
		return ((besfactory__ActivityDocumentType *)ptr)->soap_out(soap, tag, id, "besfactory:ActivityDocumentType");
	case SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType:
		return ((besfactory__FactoryResourceAttributesDocumentType *)ptr)->soap_out(soap, tag, id, "besfactory:FactoryResourceAttributesDocumentType");
	case SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType:
		return ((besfactory__BasicFactoryResourceAttributesDocumentType *)ptr)->soap_out(soap, tag, id, "besfactory:BasicFactoryResourceAttributesDocumentType");
	case SOAP_TYPE_besfactory_xsd__unsignedLong:
		return ((xsd__unsignedLong *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_besfactory_xsd__unsignedInt:
		return ((xsd__unsignedInt *)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
	case SOAP_TYPE_besfactory_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_besfactory_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_besfactory_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_besfactory_xsd__anyURI_:
		return ((xsd__anyURI_ *)ptr)->soap_out(soap, tag, id, "xsd:anyURI");
	case SOAP_TYPE_besfactory_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_besfactory_xsd__QName_:
		return ((xsd__QName_ *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_besfactory_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_besfactory_xsd__NCName_:
		return ((xsd__NCName_ *)ptr)->soap_out(soap, tag, id, "xsd:NCName");
	case SOAP_TYPE_besfactory_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_besfactory_xsd__ID_:
		return ((xsd__ID_ *)ptr)->soap_out(soap, tag, id, "xsd:ID");
	case SOAP_TYPE_besfactory_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_besfactory_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_besfactory_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentResponseType:
		return soap_out_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(soap, tag, id, (besfactory__GetFactoryAttributesDocumentResponseType *const*)ptr, "besfactory:GetFactoryAttributesDocumentResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentType:
		return soap_out_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, tag, id, (besfactory__GetFactoryAttributesDocumentType *const*)ptr, "besfactory:GetFactoryAttributesDocumentType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsResponseType:
		return soap_out_PointerTobesfactory__GetActivityDocumentsResponseType(soap, tag, id, (besfactory__GetActivityDocumentsResponseType *const*)ptr, "besfactory:GetActivityDocumentsResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsType:
		return soap_out_PointerTobesfactory__GetActivityDocumentsType(soap, tag, id, (besfactory__GetActivityDocumentsType *const*)ptr, "besfactory:GetActivityDocumentsType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesResponseType:
		return soap_out_PointerTobesfactory__TerminateActivitiesResponseType(soap, tag, id, (besfactory__TerminateActivitiesResponseType *const*)ptr, "besfactory:TerminateActivitiesResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesType:
		return soap_out_PointerTobesfactory__TerminateActivitiesType(soap, tag, id, (besfactory__TerminateActivitiesType *const*)ptr, "besfactory:TerminateActivitiesType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesResponseType:
		return soap_out_PointerTobesfactory__GetActivityStatusesResponseType(soap, tag, id, (besfactory__GetActivityStatusesResponseType *const*)ptr, "besfactory:GetActivityStatusesResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesType:
		return soap_out_PointerTobesfactory__GetActivityStatusesType(soap, tag, id, (besfactory__GetActivityStatusesType *const*)ptr, "besfactory:GetActivityStatusesType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityResponseType:
		return soap_out_PointerTobesfactory__CreateActivityResponseType(soap, tag, id, (besfactory__CreateActivityResponseType *const*)ptr, "besfactory:CreateActivityResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityType:
		return soap_out_PointerTobesfactory__CreateActivityType(soap, tag, id, (besfactory__CreateActivityType *const*)ptr, "besfactory:CreateActivityType");
	case SOAP_TYPE_besfactory_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_besfactory_PointerTojsdl__SourceTarget_USCOREType:
		return soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, (jsdl__SourceTarget_USCOREType *const*)ptr, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_besfactory_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, (jsdl__OperatingSystemType_USCOREType *const*)ptr, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, (enum jsdl__FileSystemTypeEnumeration *const*)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_besfactory_PointerTojsdl__RangeValue_USCOREType:
		return soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, (jsdl__RangeValue_USCOREType *const*)ptr, "jsdl:RangeValue_Type");
	case SOAP_TYPE_besfactory_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_besfactory_PointerTojsdl__FileSystem_USCOREType:
		return soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, (jsdl__FileSystem_USCOREType *const*)ptr, "jsdl:FileSystem_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, (jsdl__CandidateHosts_USCOREType *const*)ptr, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Description_USCOREType:
		return soap_out_PointerTojsdl__Description_USCOREType(soap, tag, id, (std::string *const*)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_besfactory_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_besfactory_PointerTojsdl__DataStaging_USCOREType:
		return soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, (jsdl__DataStaging_USCOREType *const*)ptr, "jsdl:DataStaging_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Resources_USCOREType:
		return soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, (jsdl__Resources_USCOREType *const*)ptr, "jsdl:Resources_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Application_USCOREType:
		return soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, (jsdl__Application_USCOREType *const*)ptr, "jsdl:Application_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__JobIdentification_USCOREType:
		return soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, (jsdl__JobIdentification_USCOREType *const*)ptr, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_besfactory_PointerToxsd__ID:
		return soap_out_PointerToxsd__ID(soap, tag, id, (std::string *const*)ptr, "xsd:ID");
	case SOAP_TYPE_besfactory_PointerTojsdl__JobDescription_USCOREType:
		return soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, (jsdl__JobDescription_USCOREType *const*)ptr, "jsdl:JobDescription_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Range_USCOREType:
		return soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, (jsdl__Range_USCOREType *const*)ptr, "jsdl:Range_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Exact_USCOREType:
		return soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, (jsdl__Exact_USCOREType *const*)ptr, "jsdl:Exact_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__Boundary_USCOREType:
		return soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, (jsdl__Boundary_USCOREType *const*)ptr, "jsdl:Boundary_Type");
	case SOAP_TYPE_besfactory_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__MetadataType:
		return soap_out_PointerTobesfactory2__MetadataType(soap, tag, id, (besfactory2__MetadataType *const*)ptr, "besfactory2:MetadataType");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__ReferenceParametersType:
		return soap_out_PointerTobesfactory2__ReferenceParametersType(soap, tag, id, (besfactory2__ReferenceParametersType *const*)ptr, "besfactory2:ReferenceParametersType");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__AttributedURIType:
		return soap_out_PointerTobesfactory2__AttributedURIType(soap, tag, id, (besfactory2__AttributedURIType *const*)ptr, "besfactory2:AttributedURIType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__FactoryResourceAttributesDocumentType:
		return soap_out_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, tag, id, (besfactory__FactoryResourceAttributesDocumentType *const*)ptr, "besfactory:FactoryResourceAttributesDocumentType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentResponseType:
		return soap_out_PointerTobesfactory__GetActivityDocumentResponseType(soap, tag, id, (besfactory__GetActivityDocumentResponseType *const*)ptr, "besfactory:GetActivityDocumentResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivityResponseType:
		return soap_out_PointerTobesfactory__TerminateActivityResponseType(soap, tag, id, (besfactory__TerminateActivityResponseType *const*)ptr, "besfactory:TerminateActivityResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusResponseType:
		return soap_out_PointerTobesfactory__GetActivityStatusResponseType(soap, tag, id, (besfactory__GetActivityStatusResponseType *const*)ptr, "besfactory:GetActivityStatusResponseType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityDocumentType:
		return soap_out_PointerTobesfactory__ActivityDocumentType(soap, tag, id, (besfactory__ActivityDocumentType *const*)ptr, "besfactory:ActivityDocumentType");
	case SOAP_TYPE_besfactory_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStatusType:
		return soap_out_PointerTobesfactory__ActivityStatusType(soap, tag, id, (besfactory__ActivityStatusType *const*)ptr, "besfactory:ActivityStatusType");
	case SOAP_TYPE_besfactory_PointerTobesfactory2__EndpointReferenceType:
		return soap_out_PointerTobesfactory2__EndpointReferenceType(soap, tag, id, (besfactory2__EndpointReferenceType *const*)ptr, "besfactory2:EndpointReferenceType");
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStateType:
		return soap_out_PointerTobesfactory__ActivityStateType(soap, tag, id, (besfactory__ActivityStateType *const*)ptr, "besfactory:ActivityStateType");
	case SOAP_TYPE_besfactory_PointerTojsdl__JobDefinition_USCOREType:
		return soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, (jsdl__JobDefinition_USCOREType *const*)ptr, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_besfactory_PointerTounsignedLONG64:
		return soap_out_PointerTounsignedLONG64(soap, tag, id, (ULONG64 *const*)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_besfactory_PointerTounsignedInt:
		return soap_out_PointerTounsignedInt(soap, tag, id, (unsigned int *const*)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_besfactory_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, (jsdl__CPUArchitecture_USCOREType *const*)ptr, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, (jsdl__OperatingSystem_USCOREType *const*)ptr, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_besfactory__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_besfactory_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType__:
		((jsdl__Description_USCOREType__ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType:
		soap_serialize_jsdl__Description_USCOREType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_:
		((jsdl__CreationFlagEnumeration_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_:
		((jsdl__FileSystemTypeEnumeration_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_:
		((jsdl__OperatingSystemTypeEnumeration_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_:
		((jsdl__ProcessorArchitectureEnumeration_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesType_:
		((besfactory2__FaultCodesType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__RelationshipType_:
		((besfactory2__RelationshipType_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType:
		soap_serialize_besfactory2__FaultCodesOpenEnumType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum:
		soap_serialize_besfactory2__RelationshipTypeOpenEnum(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType:
		((jsdl__SourceTarget_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType:
		((jsdl__DataStaging_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType:
		((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType:
		((jsdl__OperatingSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType:
		((jsdl__FileSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType:
		((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType:
		((jsdl__CandidateHosts_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__Resources_USCOREType:
		((jsdl__Resources_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__Application_USCOREType:
		((jsdl__Application_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType:
		((jsdl__JobIdentification_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType:
		((jsdl__JobDescription_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType:
		((jsdl__JobDefinition_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType:
		((jsdl__RangeValue_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__Range_USCOREType:
		((jsdl__Range_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__Exact_USCOREType:
		((jsdl__Exact_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType:
		((jsdl__Boundary_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__ProblemActionType:
		((besfactory2__ProblemActionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedAnyType:
		((besfactory2__AttributedAnyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedQNameType:
		((besfactory2__AttributedQNameType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType:
		((besfactory2__AttributedUnsignedLongType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedURIType:
		((besfactory2__AttributedURIType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__RelatesToType:
		((besfactory2__RelatesToType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__MetadataType:
		((besfactory2__MetadataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType:
		((besfactory2__ReferenceParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType:
		((besfactory2__EndpointReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType:
		((besfactory__UnsupportedFeatureFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType:
		((besfactory__UnsupportedJSDLVersionFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType:
		((besfactory__NotAcceptingNewActivitiesFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType:
		((besfactory__GetFactoryAttributesDocumentResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType:
		((besfactory__GetFactoryAttributesDocumentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType:
		((besfactory__GetActivityDocumentsResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType:
		((besfactory__GetActivityDocumentsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType:
		((besfactory__TerminateActivitiesResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType:
		((besfactory__TerminateActivitiesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType:
		((besfactory__GetActivityStatusesResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType:
		((besfactory__GetActivityStatusesType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType:
		((besfactory__CreateActivityResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__CreateActivityType:
		((besfactory__CreateActivityType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType:
		((besfactory__TerminateActivityResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType:
		((besfactory__GetActivityDocumentResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType:
		((besfactory__GetActivityStatusResponseType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__ActivityStatusType:
		((besfactory__ActivityStatusType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__ActivityStateType:
		((besfactory__ActivityStateType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__ActivityDocumentType:
		((besfactory__ActivityDocumentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType:
		((besfactory__FactoryResourceAttributesDocumentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType:
		((besfactory__BasicFactoryResourceAttributesDocumentType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__unsignedLong:
		((xsd__unsignedLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__unsignedInt:
		((xsd__unsignedInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__anyURI_:
		((xsd__anyURI_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_xsd__QName_:
		((xsd__QName_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_xsd__NCName_:
		((xsd__NCName_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_xsd__ID_:
		((xsd__ID_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_besfactory_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_besfactory___besfactory__GetFactoryAttributesDocument:
		soap_serialize___besfactory__GetFactoryAttributesDocument(soap, (const struct __besfactory__GetFactoryAttributesDocument *)ptr);
		break;
	case SOAP_TYPE_besfactory___besfactory__GetActivityDocuments:
		soap_serialize___besfactory__GetActivityDocuments(soap, (const struct __besfactory__GetActivityDocuments *)ptr);
		break;
	case SOAP_TYPE_besfactory___besfactory__TerminateActivities:
		soap_serialize___besfactory__TerminateActivities(soap, (const struct __besfactory__TerminateActivities *)ptr);
		break;
	case SOAP_TYPE_besfactory___besfactory__GetActivityStatuses:
		soap_serialize___besfactory__GetActivityStatuses(soap, (const struct __besfactory__GetActivityStatuses *)ptr);
		break;
	case SOAP_TYPE_besfactory___besfactory__CreateActivity:
		soap_serialize___besfactory__CreateActivity(soap, (const struct __besfactory__CreateActivity *)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentResponseType:
		soap_serialize_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(soap, (besfactory__GetFactoryAttributesDocumentResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentType:
		soap_serialize_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, (besfactory__GetFactoryAttributesDocumentType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsResponseType:
		soap_serialize_PointerTobesfactory__GetActivityDocumentsResponseType(soap, (besfactory__GetActivityDocumentsResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsType:
		soap_serialize_PointerTobesfactory__GetActivityDocumentsType(soap, (besfactory__GetActivityDocumentsType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesResponseType:
		soap_serialize_PointerTobesfactory__TerminateActivitiesResponseType(soap, (besfactory__TerminateActivitiesResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesType:
		soap_serialize_PointerTobesfactory__TerminateActivitiesType(soap, (besfactory__TerminateActivitiesType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesResponseType:
		soap_serialize_PointerTobesfactory__GetActivityStatusesResponseType(soap, (besfactory__GetActivityStatusesResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesType:
		soap_serialize_PointerTobesfactory__GetActivityStatusesType(soap, (besfactory__GetActivityStatusesType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityResponseType:
		soap_serialize_PointerTobesfactory__CreateActivityResponseType(soap, (besfactory__CreateActivityResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityType:
		soap_serialize_PointerTobesfactory__CreateActivityType(soap, (besfactory__CreateActivityType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__SourceTarget_USCOREType:
		soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, (jsdl__SourceTarget_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystemType_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, (jsdl__OperatingSystemType_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__FileSystemTypeEnumeration:
		soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, (enum jsdl__FileSystemTypeEnumeration *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__RangeValue_USCOREType:
		soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, (jsdl__RangeValue_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__FileSystem_USCOREType:
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, (jsdl__FileSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__CandidateHosts_USCOREType:
		soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, (jsdl__CandidateHosts_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__Description_USCOREType:
		soap_serialize_PointerTojsdl__Description_USCOREType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__DataStaging_USCOREType:
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, (jsdl__DataStaging_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__Resources_USCOREType:
		soap_serialize_PointerTojsdl__Resources_USCOREType(soap, (jsdl__Resources_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__Application_USCOREType:
		soap_serialize_PointerTojsdl__Application_USCOREType(soap, (jsdl__Application_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__JobIdentification_USCOREType:
		soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, (jsdl__JobIdentification_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerToxsd__ID:
		soap_serialize_PointerToxsd__ID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__JobDescription_USCOREType:
		soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, (jsdl__JobDescription_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__Range_USCOREType:
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, (jsdl__Range_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__Exact_USCOREType:
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, (jsdl__Exact_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__Boundary_USCOREType:
		soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, (jsdl__Boundary_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory2__MetadataType:
		soap_serialize_PointerTobesfactory2__MetadataType(soap, (besfactory2__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory2__ReferenceParametersType:
		soap_serialize_PointerTobesfactory2__ReferenceParametersType(soap, (besfactory2__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory2__AttributedURIType:
		soap_serialize_PointerTobesfactory2__AttributedURIType(soap, (besfactory2__AttributedURIType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__FactoryResourceAttributesDocumentType:
		soap_serialize_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, (besfactory__FactoryResourceAttributesDocumentType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentResponseType:
		soap_serialize_PointerTobesfactory__GetActivityDocumentResponseType(soap, (besfactory__GetActivityDocumentResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivityResponseType:
		soap_serialize_PointerTobesfactory__TerminateActivityResponseType(soap, (besfactory__TerminateActivityResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusResponseType:
		soap_serialize_PointerTobesfactory__GetActivityStatusResponseType(soap, (besfactory__GetActivityStatusResponseType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityDocumentType:
		soap_serialize_PointerTobesfactory__ActivityDocumentType(soap, (besfactory__ActivityDocumentType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStatusType:
		soap_serialize_PointerTobesfactory__ActivityStatusType(soap, (besfactory__ActivityStatusType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory2__EndpointReferenceType:
		soap_serialize_PointerTobesfactory2__EndpointReferenceType(soap, (besfactory2__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStateType:
		soap_serialize_PointerTobesfactory__ActivityStateType(soap, (besfactory__ActivityStateType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__JobDefinition_USCOREType:
		soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, (jsdl__JobDefinition_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTounsignedLONG64:
		soap_serialize_PointerTounsignedLONG64(soap, (ULONG64 *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTounsignedInt:
		soap_serialize_PointerTounsignedInt(soap, (unsigned int *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__CPUArchitecture_USCOREType:
		soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, (jsdl__CPUArchitecture_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystem_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, (jsdl__OperatingSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_besfactory__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_besfactory_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_besfactory_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__ID_:
		return (void*)soap_instantiate_xsd__ID_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__NCName_:
		return (void*)soap_instantiate_xsd__NCName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__QName_:
		return (void*)soap_instantiate_xsd__QName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__anyURI_:
		return (void*)soap_instantiate_xsd__anyURI_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__unsignedInt:
		return (void*)soap_instantiate_xsd__unsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__unsignedLong:
		return (void*)soap_instantiate_xsd__unsignedLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__RelationshipType_:
		return (void*)soap_instantiate_besfactory2__RelationshipType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesType_:
		return (void*)soap_instantiate_besfactory2__FaultCodesType_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_:
		return (void*)soap_instantiate_jsdl__ProcessorArchitectureEnumeration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_:
		return (void*)soap_instantiate_jsdl__OperatingSystemTypeEnumeration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_:
		return (void*)soap_instantiate_jsdl__FileSystemTypeEnumeration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_:
		return (void*)soap_instantiate_jsdl__CreationFlagEnumeration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType__:
		return (void*)soap_instantiate_jsdl__Description_USCOREType__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType:
		return (void*)soap_instantiate_besfactory__BasicFactoryResourceAttributesDocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__ActivityDocumentType:
		return (void*)soap_instantiate_besfactory__ActivityDocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__ActivityStateType:
		return (void*)soap_instantiate_besfactory__ActivityStateType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__ActivityStatusType:
		return (void*)soap_instantiate_besfactory__ActivityStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType:
		return (void*)soap_instantiate_besfactory__GetActivityStatusResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType:
		return (void*)soap_instantiate_besfactory__GetActivityDocumentResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType:
		return (void*)soap_instantiate_besfactory__TerminateActivityResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__CreateActivityType:
		return (void*)soap_instantiate_besfactory__CreateActivityType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType:
		return (void*)soap_instantiate_besfactory__CreateActivityResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType:
		return (void*)soap_instantiate_besfactory__GetActivityStatusesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType:
		return (void*)soap_instantiate_besfactory__GetActivityStatusesResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType:
		return (void*)soap_instantiate_besfactory__TerminateActivitiesType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType:
		return (void*)soap_instantiate_besfactory__TerminateActivitiesResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType:
		return (void*)soap_instantiate_besfactory__GetActivityDocumentsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType:
		return (void*)soap_instantiate_besfactory__GetActivityDocumentsResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType:
		return (void*)soap_instantiate_besfactory__GetFactoryAttributesDocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType:
		return (void*)soap_instantiate_besfactory__GetFactoryAttributesDocumentResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType:
		return (void*)soap_instantiate_besfactory__NotAcceptingNewActivitiesFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType:
		return (void*)soap_instantiate_besfactory__UnsupportedJSDLVersionFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType:
		return (void*)soap_instantiate_besfactory__UnsupportedFeatureFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType:
		return (void*)soap_instantiate_besfactory2__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType:
		return (void*)soap_instantiate_besfactory2__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__MetadataType:
		return (void*)soap_instantiate_besfactory2__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__AttributedAnyType:
		return (void*)soap_instantiate_besfactory2__AttributedAnyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__ProblemActionType:
		return (void*)soap_instantiate_besfactory2__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__Range_USCOREType:
		return (void*)soap_instantiate_jsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType:
		return (void*)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType:
		return (void*)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__Application_USCOREType:
		return (void*)soap_instantiate_jsdl__Application_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__Resources_USCOREType:
		return (void*)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType:
		return (void*)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType:
		return (void*)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType:
		return (void*)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType:
		return (void*)soap_instantiate_besfactory__FactoryResourceAttributesDocumentType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__RelatesToType:
		return (void*)soap_instantiate_besfactory2__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__AttributedURIType:
		return (void*)soap_instantiate_besfactory2__AttributedURIType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType:
		return (void*)soap_instantiate_besfactory2__AttributedUnsignedLongType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__AttributedQNameType:
		return (void*)soap_instantiate_besfactory2__AttributedQNameType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType:
		return (void*)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__Exact_USCOREType:
		return (void*)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_besfactory_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_besfactory___besfactory__CreateActivity:
		return (void*)soap_instantiate___besfactory__CreateActivity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory___besfactory__GetActivityStatuses:
		return (void*)soap_instantiate___besfactory__GetActivityStatuses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory___besfactory__TerminateActivities:
		return (void*)soap_instantiate___besfactory__TerminateActivities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory___besfactory__GetActivityDocuments:
		return (void*)soap_instantiate___besfactory__GetActivityDocuments(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory___besfactory__GetFactoryAttributesDocument:
		return (void*)soap_instantiate___besfactory__GetFactoryAttributesDocument(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_besfactory_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_besfactory_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_besfactory_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_besfactory_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_besfactory_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum:
		return (void*)soap_instantiate_besfactory2__RelationshipTypeOpenEnum(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType:
		return (void*)soap_instantiate_besfactory2__FaultCodesOpenEnumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType:
		return (void*)soap_instantiate_jsdl__Description_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerToxsd__anyType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_besfactory_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_besfactory_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__ID_:
		if (p->size < 0)
			delete (xsd__ID_*)p->ptr;
		else
			delete[] (xsd__ID_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__NCName_:
		if (p->size < 0)
			delete (xsd__NCName_*)p->ptr;
		else
			delete[] (xsd__NCName_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__QName_:
		if (p->size < 0)
			delete (xsd__QName_*)p->ptr;
		else
			delete[] (xsd__QName_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__anyURI_:
		if (p->size < 0)
			delete (xsd__anyURI_*)p->ptr;
		else
			delete[] (xsd__anyURI_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__boolean:
		if (p->size < 0)
			delete (xsd__boolean*)p->ptr;
		else
			delete[] (xsd__boolean*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__double:
		if (p->size < 0)
			delete (xsd__double*)p->ptr;
		else
			delete[] (xsd__double*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__string:
		if (p->size < 0)
			delete (xsd__string*)p->ptr;
		else
			delete[] (xsd__string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__unsignedInt:
		if (p->size < 0)
			delete (xsd__unsignedInt*)p->ptr;
		else
			delete[] (xsd__unsignedInt*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__unsignedLong:
		if (p->size < 0)
			delete (xsd__unsignedLong*)p->ptr;
		else
			delete[] (xsd__unsignedLong*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__RelationshipType_:
		if (p->size < 0)
			delete (besfactory2__RelationshipType_*)p->ptr;
		else
			delete[] (besfactory2__RelationshipType_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesType_:
		if (p->size < 0)
			delete (besfactory2__FaultCodesType_*)p->ptr;
		else
			delete[] (besfactory2__FaultCodesType_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_:
		if (p->size < 0)
			delete (jsdl__ProcessorArchitectureEnumeration_*)p->ptr;
		else
			delete[] (jsdl__ProcessorArchitectureEnumeration_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_:
		if (p->size < 0)
			delete (jsdl__OperatingSystemTypeEnumeration_*)p->ptr;
		else
			delete[] (jsdl__OperatingSystemTypeEnumeration_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_:
		if (p->size < 0)
			delete (jsdl__FileSystemTypeEnumeration_*)p->ptr;
		else
			delete[] (jsdl__FileSystemTypeEnumeration_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_:
		if (p->size < 0)
			delete (jsdl__CreationFlagEnumeration_*)p->ptr;
		else
			delete[] (jsdl__CreationFlagEnumeration_*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType__:
		if (p->size < 0)
			delete (jsdl__Description_USCOREType__*)p->ptr;
		else
			delete[] (jsdl__Description_USCOREType__*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType:
		if (p->size < 0)
			delete (besfactory__BasicFactoryResourceAttributesDocumentType*)p->ptr;
		else
			delete[] (besfactory__BasicFactoryResourceAttributesDocumentType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__ActivityDocumentType:
		if (p->size < 0)
			delete (besfactory__ActivityDocumentType*)p->ptr;
		else
			delete[] (besfactory__ActivityDocumentType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__ActivityStateType:
		if (p->size < 0)
			delete (besfactory__ActivityStateType*)p->ptr;
		else
			delete[] (besfactory__ActivityStateType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__ActivityStatusType:
		if (p->size < 0)
			delete (besfactory__ActivityStatusType*)p->ptr;
		else
			delete[] (besfactory__ActivityStatusType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType:
		if (p->size < 0)
			delete (besfactory__GetActivityStatusResponseType*)p->ptr;
		else
			delete[] (besfactory__GetActivityStatusResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType:
		if (p->size < 0)
			delete (besfactory__GetActivityDocumentResponseType*)p->ptr;
		else
			delete[] (besfactory__GetActivityDocumentResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType:
		if (p->size < 0)
			delete (besfactory__TerminateActivityResponseType*)p->ptr;
		else
			delete[] (besfactory__TerminateActivityResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__CreateActivityType:
		if (p->size < 0)
			delete (besfactory__CreateActivityType*)p->ptr;
		else
			delete[] (besfactory__CreateActivityType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType:
		if (p->size < 0)
			delete (besfactory__CreateActivityResponseType*)p->ptr;
		else
			delete[] (besfactory__CreateActivityResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType:
		if (p->size < 0)
			delete (besfactory__GetActivityStatusesType*)p->ptr;
		else
			delete[] (besfactory__GetActivityStatusesType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType:
		if (p->size < 0)
			delete (besfactory__GetActivityStatusesResponseType*)p->ptr;
		else
			delete[] (besfactory__GetActivityStatusesResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType:
		if (p->size < 0)
			delete (besfactory__TerminateActivitiesType*)p->ptr;
		else
			delete[] (besfactory__TerminateActivitiesType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType:
		if (p->size < 0)
			delete (besfactory__TerminateActivitiesResponseType*)p->ptr;
		else
			delete[] (besfactory__TerminateActivitiesResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType:
		if (p->size < 0)
			delete (besfactory__GetActivityDocumentsType*)p->ptr;
		else
			delete[] (besfactory__GetActivityDocumentsType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType:
		if (p->size < 0)
			delete (besfactory__GetActivityDocumentsResponseType*)p->ptr;
		else
			delete[] (besfactory__GetActivityDocumentsResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType:
		if (p->size < 0)
			delete (besfactory__GetFactoryAttributesDocumentType*)p->ptr;
		else
			delete[] (besfactory__GetFactoryAttributesDocumentType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType:
		if (p->size < 0)
			delete (besfactory__GetFactoryAttributesDocumentResponseType*)p->ptr;
		else
			delete[] (besfactory__GetFactoryAttributesDocumentResponseType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType:
		if (p->size < 0)
			delete (besfactory__NotAcceptingNewActivitiesFaultType*)p->ptr;
		else
			delete[] (besfactory__NotAcceptingNewActivitiesFaultType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType:
		if (p->size < 0)
			delete (besfactory__UnsupportedJSDLVersionFaultType*)p->ptr;
		else
			delete[] (besfactory__UnsupportedJSDLVersionFaultType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType:
		if (p->size < 0)
			delete (besfactory__UnsupportedFeatureFaultType*)p->ptr;
		else
			delete[] (besfactory__UnsupportedFeatureFaultType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType:
		if (p->size < 0)
			delete (besfactory2__EndpointReferenceType*)p->ptr;
		else
			delete[] (besfactory2__EndpointReferenceType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType:
		if (p->size < 0)
			delete (besfactory2__ReferenceParametersType*)p->ptr;
		else
			delete[] (besfactory2__ReferenceParametersType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__MetadataType:
		if (p->size < 0)
			delete (besfactory2__MetadataType*)p->ptr;
		else
			delete[] (besfactory2__MetadataType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedAnyType:
		if (p->size < 0)
			delete (besfactory2__AttributedAnyType*)p->ptr;
		else
			delete[] (besfactory2__AttributedAnyType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__ProblemActionType:
		if (p->size < 0)
			delete (besfactory2__ProblemActionType*)p->ptr;
		else
			delete[] (besfactory2__ProblemActionType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__Range_USCOREType:
		if (p->size < 0)
			delete (jsdl__Range_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Range_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType:
		if (p->size < 0)
			delete (jsdl__RangeValue_USCOREType*)p->ptr;
		else
			delete[] (jsdl__RangeValue_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobDefinition_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobDefinition_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobDescription_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobDescription_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobIdentification_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobIdentification_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__Application_USCOREType:
		if (p->size < 0)
			delete (jsdl__Application_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Application_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__Resources_USCOREType:
		if (p->size < 0)
			delete (jsdl__Resources_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Resources_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType:
		if (p->size < 0)
			delete (jsdl__CandidateHosts_USCOREType*)p->ptr;
		else
			delete[] (jsdl__CandidateHosts_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType:
		if (p->size < 0)
			delete (jsdl__CPUArchitecture_USCOREType*)p->ptr;
		else
			delete[] (jsdl__CPUArchitecture_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType:
		if (p->size < 0)
			delete (jsdl__FileSystem_USCOREType*)p->ptr;
		else
			delete[] (jsdl__FileSystem_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType:
		if (p->size < 0)
			delete (jsdl__OperatingSystem_USCOREType*)p->ptr;
		else
			delete[] (jsdl__OperatingSystem_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType:
		if (p->size < 0)
			delete (jsdl__OperatingSystemType_USCOREType*)p->ptr;
		else
			delete[] (jsdl__OperatingSystemType_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType:
		if (p->size < 0)
			delete (jsdl__DataStaging_USCOREType*)p->ptr;
		else
			delete[] (jsdl__DataStaging_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType:
		if (p->size < 0)
			delete (jsdl__SourceTarget_USCOREType*)p->ptr;
		else
			delete[] (jsdl__SourceTarget_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType:
		if (p->size < 0)
			delete (besfactory__FactoryResourceAttributesDocumentType*)p->ptr;
		else
			delete[] (besfactory__FactoryResourceAttributesDocumentType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__RelatesToType:
		if (p->size < 0)
			delete (besfactory2__RelatesToType*)p->ptr;
		else
			delete[] (besfactory2__RelatesToType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedURIType:
		if (p->size < 0)
			delete (besfactory2__AttributedURIType*)p->ptr;
		else
			delete[] (besfactory2__AttributedURIType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType:
		if (p->size < 0)
			delete (besfactory2__AttributedUnsignedLongType*)p->ptr;
		else
			delete[] (besfactory2__AttributedUnsignedLongType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__AttributedQNameType:
		if (p->size < 0)
			delete (besfactory2__AttributedQNameType*)p->ptr;
		else
			delete[] (besfactory2__AttributedQNameType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType:
		if (p->size < 0)
			delete (jsdl__Boundary_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Boundary_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__Exact_USCOREType:
		if (p->size < 0)
			delete (jsdl__Exact_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Exact_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_besfactory___besfactory__CreateActivity:
		if (p->size < 0)
			delete (struct __besfactory__CreateActivity*)p->ptr;
		else
			delete[] (struct __besfactory__CreateActivity*)p->ptr;
		break;
	case SOAP_TYPE_besfactory___besfactory__GetActivityStatuses:
		if (p->size < 0)
			delete (struct __besfactory__GetActivityStatuses*)p->ptr;
		else
			delete[] (struct __besfactory__GetActivityStatuses*)p->ptr;
		break;
	case SOAP_TYPE_besfactory___besfactory__TerminateActivities:
		if (p->size < 0)
			delete (struct __besfactory__TerminateActivities*)p->ptr;
		else
			delete[] (struct __besfactory__TerminateActivities*)p->ptr;
		break;
	case SOAP_TYPE_besfactory___besfactory__GetActivityDocuments:
		if (p->size < 0)
			delete (struct __besfactory__GetActivityDocuments*)p->ptr;
		else
			delete[] (struct __besfactory__GetActivityDocuments*)p->ptr;
		break;
	case SOAP_TYPE_besfactory___besfactory__GetFactoryAttributesDocument:
		if (p->size < 0)
			delete (struct __besfactory__GetFactoryAttributesDocument*)p->ptr;
		else
			delete[] (struct __besfactory__GetFactoryAttributesDocument*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__ID:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__NCName:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__QName:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_xsd__anyURI:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_jsdl__Description_USCOREType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerToxsd__anyType:
		if (p->size < 0)
			delete (std::vector<xsd__anyType * >*)p->ptr;
		else
			delete[] (std::vector<xsd__anyType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__Range_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__Range_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__Exact_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__Exact_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType:
		if (p->size < 0)
			delete (std::vector<besfactory__GetActivityDocumentResponseType * >*)p->ptr;
		else
			delete[] (std::vector<besfactory__GetActivityDocumentResponseType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType:
		if (p->size < 0)
			delete (std::vector<besfactory__TerminateActivityResponseType * >*)p->ptr;
		else
			delete[] (std::vector<besfactory__TerminateActivityResponseType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType:
		if (p->size < 0)
			delete (std::vector<besfactory__GetActivityStatusResponseType * >*)p->ptr;
		else
			delete[] (std::vector<besfactory__GetActivityStatusResponseType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType:
		if (p->size < 0)
			delete (std::vector<besfactory2__EndpointReferenceType * >*)p->ptr;
		else
			delete[] (std::vector<besfactory2__EndpointReferenceType * >*)p->ptr;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOf_XML:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerToxsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<xsd__anyType * >*)p)[len] = *(xsd__anyType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__FileSystem_USCOREType * >*)p)[len] = *(jsdl__FileSystem_USCOREType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__DataStaging_USCOREType * >*)p)[len] = *(jsdl__DataStaging_USCOREType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Range_USCOREType * >*)p)[len] = *(jsdl__Range_USCOREType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Exact_USCOREType * >*)p)[len] = *(jsdl__Exact_USCOREType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<besfactory__GetActivityDocumentResponseType * >*)p)[len] = *(besfactory__GetActivityDocumentResponseType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<besfactory__TerminateActivityResponseType * >*)p)[len] = *(besfactory__TerminateActivityResponseType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<besfactory__GetActivityStatusResponseType * >*)p)[len] = *(besfactory__GetActivityStatusResponseType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<besfactory2__EndpointReferenceType * >*)p)[len] = *(besfactory2__EndpointReferenceType **)q;
		break;
	case SOAP_TYPE_besfactory_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_besfactory_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_besfactory_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_besfactory_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_besfactory_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_besfactory_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_besfactory_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_besfactory_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_besfactory_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_besfactory_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_besfactory_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__CreationFlagEnumeration
	*a = SOAP_DEFAULT_jsdl__CreationFlagEnumeration;
#else
	*a = (enum jsdl__CreationFlagEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__CreationFlagEnumeration(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration);
	if (soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__CreationFlagEnumeration[] =
{	{ (long)jsdl__CreationFlagEnumeration__overwrite, "overwrite" },
	{ (long)jsdl__CreationFlagEnumeration__append, "append" },
	{ (long)jsdl__CreationFlagEnumeration__dontOverwrite, "dontOverwrite" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__CreationFlagEnumeration2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__CreationFlagEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration), type) || soap_send(soap, soap_jsdl__CreationFlagEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CreationFlagEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__CreationFlagEnumeration(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__CreationFlagEnumeration, s);
	if (map)
		*a = (enum jsdl__CreationFlagEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__CreationFlagEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__CreationFlagEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration;
#else
	*a = (enum jsdl__FileSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__FileSystemTypeEnumeration(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration);
	if (soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__FileSystemTypeEnumeration[] =
{	{ (long)jsdl__FileSystemTypeEnumeration__swap, "swap" },
	{ (long)jsdl__FileSystemTypeEnumeration__temporary, "temporary" },
	{ (long)jsdl__FileSystemTypeEnumeration__spool, "spool" },
	{ (long)jsdl__FileSystemTypeEnumeration__normal, "normal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__FileSystemTypeEnumeration2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__FileSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__FileSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__FileSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__FileSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__FileSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__FileSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration;
#else
	*a = (enum jsdl__OperatingSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration);
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__OperatingSystemTypeEnumeration[] =
{	{ (long)jsdl__OperatingSystemTypeEnumeration__Unknown, "Unknown" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACOS, "MACOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ATTUNIX, "ATTUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DGUX, "DGUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DECNT, "DECNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Tru64_USCOREUNIX, "Tru64_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenVMS, "OpenVMS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HPUX, "HPUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__AIX, "AIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MVS, "MVS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS400, "OS400" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE2, "OS_2" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__JavaVM, "JavaVM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MSDOS, "MSDOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN3x, "WIN3x" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN95, "WIN95" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN98, "WIN98" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINNT, "WINNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINCE, "WINCE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NCR3000, "NCR3000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetWare, "NetWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OSF, "OSF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DC_USCOREOS, "DC_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Reliant_USCOREUNIX, "Reliant_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREUnixWare, "SCO_UnixWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREOpenServer, "SCO_OpenServer" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Sequent, "Sequent" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IRIX, "IRIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Solaris, "Solaris" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SunOS, "SunOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__U6000, "U6000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ASERIES, "ASERIES" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNSK, "TandemNSK" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNT, "TandemNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BS2000, "BS2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__LINUX, "LINUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Lynx, "Lynx" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__XENIX, "XENIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VM, "VM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Interactive_USCOREUNIX, "Interactive_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BSDUNIX, "BSDUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__FreeBSD, "FreeBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetBSD, "NetBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__GNU_USCOREHurd, "GNU_Hurd" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS9, "OS9" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACH_USCOREKernel, "MACH_Kernel" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Inferno, "Inferno" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__QNX, "QNX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__EPOC, "EPOC" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IxWorks, "IxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VxWorks, "VxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MiNT, "MiNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BeOS, "BeOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HP_USCOREMPE, "HP_MPE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NextStep, "NextStep" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__PalmPilot, "PalmPilot" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Rhapsody, "Rhapsody" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORE2000, "Windows_2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Dedicated, "Dedicated" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE390, "OS_390" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VSE, "VSE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TPF, "TPF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORER_USCOREMe, "Windows_R_Me" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Caldera_USCOREOpen_USCOREUNIX, "Caldera_Open_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenBSD, "OpenBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Not_USCOREApplicable, "Not_Applicable" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCOREXP, "Windows_XP" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__z_USCOREOS, "z_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__OperatingSystemTypeEnumeration2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__OperatingSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__OperatingSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__OperatingSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__OperatingSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 68)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__OperatingSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__OperatingSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration
	*a = SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration;
#else
	*a = (enum jsdl__ProcessorArchitectureEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration);
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__ProcessorArchitectureEnumeration[] =
{	{ (long)jsdl__ProcessorArchitectureEnumeration__sparc, "sparc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__powerpc, "powerpc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86, "x86" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE32, "x86_32" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE64, "x86_64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__parisc, "parisc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__mips, "mips" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__ia64, "ia64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__arm, "arm" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__ProcessorArchitectureEnumeration2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__ProcessorArchitectureEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration), type) || soap_send(soap, soap_jsdl__ProcessorArchitectureEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__ProcessorArchitectureEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__ProcessorArchitectureEnumeration, s);
	if (map)
		*a = (enum jsdl__ProcessorArchitectureEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__ProcessorArchitectureEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__ProcessorArchitectureEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_besfactory2__FaultCodesType(struct soap *soap, enum besfactory2__FaultCodesType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_besfactory2__FaultCodesType
	*a = SOAP_DEFAULT_besfactory2__FaultCodesType;
#else
	*a = (enum besfactory2__FaultCodesType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_besfactory2__FaultCodesType(struct soap *soap, const enum besfactory2__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__FaultCodesType);
	if (soap_out_besfactory2__FaultCodesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_besfactory2__FaultCodesType[] =
{	{ (long)besfactory2__FaultCodesType__besfactory2__InvalidAddressingHeader, "besfactory2:InvalidAddressingHeader" },
	{ (long)besfactory2__FaultCodesType__besfactory2__InvalidAddress, "besfactory2:InvalidAddress" },
	{ (long)besfactory2__FaultCodesType__besfactory2__InvalidEPR, "besfactory2:InvalidEPR" },
	{ (long)besfactory2__FaultCodesType__besfactory2__InvalidCardinality, "besfactory2:InvalidCardinality" },
	{ (long)besfactory2__FaultCodesType__besfactory2__MissingAddressInEPR, "besfactory2:MissingAddressInEPR" },
	{ (long)besfactory2__FaultCodesType__besfactory2__DuplicateMessageID, "besfactory2:DuplicateMessageID" },
	{ (long)besfactory2__FaultCodesType__besfactory2__ActionMismatch, "besfactory2:ActionMismatch" },
	{ (long)besfactory2__FaultCodesType__besfactory2__MessageAddressingHeaderRequired, "besfactory2:MessageAddressingHeaderRequired" },
	{ (long)besfactory2__FaultCodesType__besfactory2__DestinationUnreachable, "besfactory2:DestinationUnreachable" },
	{ (long)besfactory2__FaultCodesType__besfactory2__ActionNotSupported, "besfactory2:ActionNotSupported" },
	{ (long)besfactory2__FaultCodesType__besfactory2__EndpointUnavailable, "besfactory2:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_besfactory2__FaultCodesType2s(struct soap *soap, enum besfactory2__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_besfactory2__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__FaultCodesType(struct soap *soap, const char *tag, int id, const enum besfactory2__FaultCodesType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory2__FaultCodesType), type) || soap_send(soap, soap_besfactory2__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum besfactory2__FaultCodesType * SOAP_FMAC4 soap_get_besfactory2__FaultCodesType(struct soap *soap, enum besfactory2__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2besfactory2__FaultCodesType(struct soap *soap, const char *s, enum besfactory2__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_besfactory2__FaultCodesType, t);
	if (map)
		*a = (enum besfactory2__FaultCodesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum besfactory2__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum besfactory2__FaultCodesType * SOAP_FMAC4 soap_in_besfactory2__FaultCodesType(struct soap *soap, const char *tag, enum besfactory2__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum besfactory2__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__FaultCodesType, sizeof(enum besfactory2__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2besfactory2__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum besfactory2__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory2__FaultCodesType, 0, sizeof(enum besfactory2__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_besfactory2__RelationshipType(struct soap *soap, enum besfactory2__RelationshipType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_besfactory2__RelationshipType
	*a = SOAP_DEFAULT_besfactory2__RelationshipType;
#else
	*a = (enum besfactory2__RelationshipType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_besfactory2__RelationshipType(struct soap *soap, const enum besfactory2__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__RelationshipType);
	if (soap_out_besfactory2__RelationshipType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_besfactory2__RelationshipType[] =
{	{ (long)besfactory2__RelationshipType__http___x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_besfactory2__RelationshipType2s(struct soap *soap, enum besfactory2__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_besfactory2__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__RelationshipType(struct soap *soap, const char *tag, int id, const enum besfactory2__RelationshipType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory2__RelationshipType), type) || soap_send(soap, soap_besfactory2__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum besfactory2__RelationshipType * SOAP_FMAC4 soap_get_besfactory2__RelationshipType(struct soap *soap, enum besfactory2__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2besfactory2__RelationshipType(struct soap *soap, const char *s, enum besfactory2__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_besfactory2__RelationshipType, s);
	if (map)
		*a = (enum besfactory2__RelationshipType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum besfactory2__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum besfactory2__RelationshipType * SOAP_FMAC4 soap_in_besfactory2__RelationshipType(struct soap *soap, const char *tag, enum besfactory2__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum besfactory2__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__RelationshipType, sizeof(enum besfactory2__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2besfactory2__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum besfactory2__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory2__RelationshipType, 0, sizeof(enum besfactory2__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void jsdl__Description_USCOREType__::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__Description_USCOREType(soap, &this->jsdl__Description_USCOREType__::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__Description_USCOREType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Description_USCOREType__::__item, SOAP_TYPE_besfactory_jsdl__Description_USCOREType);
	soap_serialize_jsdl__Description_USCOREType(soap, &this->jsdl__Description_USCOREType__::__item);
	/* transient soap skipped */
}

int jsdl__Description_USCOREType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__Description_USCOREType__);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Description_USCOREType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Description_USCOREType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Description_USCOREType__(struct soap *soap, const char *tag, int id, const jsdl__Description_USCOREType__ *a, const char *type)
{
	return soap_out_jsdl__Description_USCOREType(soap, tag, id, &(a->jsdl__Description_USCOREType__::__item), "jsdl:Description_Type");
}

void *jsdl__Description_USCOREType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Description_USCOREType__(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Description_USCOREType__ * SOAP_FMAC4 soap_get_jsdl__Description_USCOREType__(struct soap *soap, jsdl__Description_USCOREType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Description_USCOREType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Description_USCOREType__::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Description_USCOREType__(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Description_USCOREType__ * SOAP_FMAC4 soap_in_jsdl__Description_USCOREType__(struct soap *soap, const char *tag, jsdl__Description_USCOREType__ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Description_USCOREType__ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__Description_USCOREType__, sizeof(jsdl__Description_USCOREType__), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__Description_USCOREType__)
			return (jsdl__Description_USCOREType__ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_jsdl__Description_USCOREType(soap, tag, &(a->jsdl__Description_USCOREType__::__item), "jsdl:Description_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__Description_USCOREType__ * SOAP_FMAC6 soap_new_jsdl__Description_USCOREType__(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Description_USCOREType__(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Description_USCOREType__(struct soap *soap, jsdl__Description_USCOREType__ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Description_USCOREType__ * SOAP_FMAC4 soap_instantiate_jsdl__Description_USCOREType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Description_USCOREType__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__Description_USCOREType__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Description_USCOREType__;
		if (size)
			*size = sizeof(jsdl__Description_USCOREType__);
		((jsdl__Description_USCOREType__*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Description_USCOREType__[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Description_USCOREType__);
		for (int i = 0; i < n; i++)
			((jsdl__Description_USCOREType__*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Description_USCOREType__*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Description_USCOREType__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Description_USCOREType__ %p -> %p\n", q, p));
	*(jsdl__Description_USCOREType__*)p = *(jsdl__Description_USCOREType__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Description_USCOREType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Description_USCOREType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Description_USCOREType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__Description_USCOREType);
	if (soap_out_jsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_jsdl__Description_USCOREType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_jsdl__Description_USCOREType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_jsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_jsdl__Description_USCOREType, 0, sizeof(std::string), 0, soap_copy_jsdl__Description_USCOREType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_jsdl__Description_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Description_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Description_USCOREType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_jsdl__Description_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Description_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__Description_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Description_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void jsdl__CreationFlagEnumeration_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__CreationFlagEnumeration(soap, &this->jsdl__CreationFlagEnumeration_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__CreationFlagEnumeration_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int jsdl__CreationFlagEnumeration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__CreationFlagEnumeration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CreationFlagEnumeration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CreationFlagEnumeration_(struct soap *soap, const char *tag, int id, const jsdl__CreationFlagEnumeration_ *a, const char *type)
{
	return soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, &(a->jsdl__CreationFlagEnumeration_::__item), "jsdl:CreationFlagEnumeration");
}

void *jsdl__CreationFlagEnumeration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CreationFlagEnumeration_(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CreationFlagEnumeration_ * SOAP_FMAC4 soap_get_jsdl__CreationFlagEnumeration_(struct soap *soap, jsdl__CreationFlagEnumeration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CreationFlagEnumeration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__CreationFlagEnumeration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CreationFlagEnumeration_(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CreationFlagEnumeration_ * SOAP_FMAC4 soap_in_jsdl__CreationFlagEnumeration_(struct soap *soap, const char *tag, jsdl__CreationFlagEnumeration_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__CreationFlagEnumeration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_, sizeof(jsdl__CreationFlagEnumeration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_)
			return (jsdl__CreationFlagEnumeration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_jsdl__CreationFlagEnumeration(soap, tag, &(a->jsdl__CreationFlagEnumeration_::__item), "jsdl:CreationFlagEnumeration"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__CreationFlagEnumeration_ * SOAP_FMAC6 soap_new_jsdl__CreationFlagEnumeration_(struct soap *soap, int n)
{	return soap_instantiate_jsdl__CreationFlagEnumeration_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__CreationFlagEnumeration_(struct soap *soap, jsdl__CreationFlagEnumeration_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__CreationFlagEnumeration_ * SOAP_FMAC4 soap_instantiate_jsdl__CreationFlagEnumeration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CreationFlagEnumeration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__CreationFlagEnumeration_;
		if (size)
			*size = sizeof(jsdl__CreationFlagEnumeration_);
		((jsdl__CreationFlagEnumeration_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__CreationFlagEnumeration_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CreationFlagEnumeration_);
		for (int i = 0; i < n; i++)
			((jsdl__CreationFlagEnumeration_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CreationFlagEnumeration_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CreationFlagEnumeration_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CreationFlagEnumeration_ %p -> %p\n", q, p));
	*(jsdl__CreationFlagEnumeration_*)p = *(jsdl__CreationFlagEnumeration_*)q;
}

void jsdl__FileSystemTypeEnumeration_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__FileSystemTypeEnumeration(soap, &this->jsdl__FileSystemTypeEnumeration_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__FileSystemTypeEnumeration_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__FileSystemTypeEnumeration_::__item, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration);
	/* transient soap skipped */
}

int jsdl__FileSystemTypeEnumeration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__FileSystemTypeEnumeration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__FileSystemTypeEnumeration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystemTypeEnumeration_(struct soap *soap, const char *tag, int id, const jsdl__FileSystemTypeEnumeration_ *a, const char *type)
{
	return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, &(a->jsdl__FileSystemTypeEnumeration_::__item), "jsdl:FileSystemTypeEnumeration");
}

void *jsdl__FileSystemTypeEnumeration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__FileSystemTypeEnumeration_(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__FileSystemTypeEnumeration_ * SOAP_FMAC4 soap_get_jsdl__FileSystemTypeEnumeration_(struct soap *soap, jsdl__FileSystemTypeEnumeration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystemTypeEnumeration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__FileSystemTypeEnumeration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__FileSystemTypeEnumeration_(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__FileSystemTypeEnumeration_ * SOAP_FMAC4 soap_in_jsdl__FileSystemTypeEnumeration_(struct soap *soap, const char *tag, jsdl__FileSystemTypeEnumeration_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__FileSystemTypeEnumeration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_, sizeof(jsdl__FileSystemTypeEnumeration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_)
			return (jsdl__FileSystemTypeEnumeration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, &(a->jsdl__FileSystemTypeEnumeration_::__item), "jsdl:FileSystemTypeEnumeration"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__FileSystemTypeEnumeration_ * SOAP_FMAC6 soap_new_jsdl__FileSystemTypeEnumeration_(struct soap *soap, int n)
{	return soap_instantiate_jsdl__FileSystemTypeEnumeration_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__FileSystemTypeEnumeration_(struct soap *soap, jsdl__FileSystemTypeEnumeration_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__FileSystemTypeEnumeration_ * SOAP_FMAC4 soap_instantiate_jsdl__FileSystemTypeEnumeration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__FileSystemTypeEnumeration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__FileSystemTypeEnumeration_;
		if (size)
			*size = sizeof(jsdl__FileSystemTypeEnumeration_);
		((jsdl__FileSystemTypeEnumeration_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__FileSystemTypeEnumeration_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__FileSystemTypeEnumeration_);
		for (int i = 0; i < n; i++)
			((jsdl__FileSystemTypeEnumeration_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__FileSystemTypeEnumeration_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__FileSystemTypeEnumeration_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__FileSystemTypeEnumeration_ %p -> %p\n", q, p));
	*(jsdl__FileSystemTypeEnumeration_*)p = *(jsdl__FileSystemTypeEnumeration_*)q;
}

void jsdl__OperatingSystemTypeEnumeration_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, &this->jsdl__OperatingSystemTypeEnumeration_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystemTypeEnumeration_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int jsdl__OperatingSystemTypeEnumeration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__OperatingSystemTypeEnumeration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystemTypeEnumeration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemTypeEnumeration_(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystemTypeEnumeration_ *a, const char *type)
{
	return soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, &(a->jsdl__OperatingSystemTypeEnumeration_::__item), "jsdl:OperatingSystemTypeEnumeration");
}

void *jsdl__OperatingSystemTypeEnumeration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystemTypeEnumeration_(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystemTypeEnumeration_ * SOAP_FMAC4 soap_get_jsdl__OperatingSystemTypeEnumeration_(struct soap *soap, jsdl__OperatingSystemTypeEnumeration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemTypeEnumeration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__OperatingSystemTypeEnumeration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystemTypeEnumeration_(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystemTypeEnumeration_ * SOAP_FMAC4 soap_in_jsdl__OperatingSystemTypeEnumeration_(struct soap *soap, const char *tag, jsdl__OperatingSystemTypeEnumeration_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__OperatingSystemTypeEnumeration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_, sizeof(jsdl__OperatingSystemTypeEnumeration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_)
			return (jsdl__OperatingSystemTypeEnumeration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_jsdl__OperatingSystemTypeEnumeration(soap, tag, &(a->jsdl__OperatingSystemTypeEnumeration_::__item), "jsdl:OperatingSystemTypeEnumeration"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__OperatingSystemTypeEnumeration_ * SOAP_FMAC6 soap_new_jsdl__OperatingSystemTypeEnumeration_(struct soap *soap, int n)
{	return soap_instantiate_jsdl__OperatingSystemTypeEnumeration_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__OperatingSystemTypeEnumeration_(struct soap *soap, jsdl__OperatingSystemTypeEnumeration_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__OperatingSystemTypeEnumeration_ * SOAP_FMAC4 soap_instantiate_jsdl__OperatingSystemTypeEnumeration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystemTypeEnumeration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__OperatingSystemTypeEnumeration_;
		if (size)
			*size = sizeof(jsdl__OperatingSystemTypeEnumeration_);
		((jsdl__OperatingSystemTypeEnumeration_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__OperatingSystemTypeEnumeration_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystemTypeEnumeration_);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystemTypeEnumeration_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystemTypeEnumeration_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystemTypeEnumeration_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystemTypeEnumeration_ %p -> %p\n", q, p));
	*(jsdl__OperatingSystemTypeEnumeration_*)p = *(jsdl__OperatingSystemTypeEnumeration_*)q;
}

void jsdl__ProcessorArchitectureEnumeration_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, &this->jsdl__ProcessorArchitectureEnumeration_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__ProcessorArchitectureEnumeration_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int jsdl__ProcessorArchitectureEnumeration_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__ProcessorArchitectureEnumeration_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__ProcessorArchitectureEnumeration_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__ProcessorArchitectureEnumeration_(struct soap *soap, const char *tag, int id, const jsdl__ProcessorArchitectureEnumeration_ *a, const char *type)
{
	return soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, &(a->jsdl__ProcessorArchitectureEnumeration_::__item), "jsdl:ProcessorArchitectureEnumeration");
}

void *jsdl__ProcessorArchitectureEnumeration_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__ProcessorArchitectureEnumeration_(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__ProcessorArchitectureEnumeration_ * SOAP_FMAC4 soap_get_jsdl__ProcessorArchitectureEnumeration_(struct soap *soap, jsdl__ProcessorArchitectureEnumeration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__ProcessorArchitectureEnumeration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__ProcessorArchitectureEnumeration_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__ProcessorArchitectureEnumeration_(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__ProcessorArchitectureEnumeration_ * SOAP_FMAC4 soap_in_jsdl__ProcessorArchitectureEnumeration_(struct soap *soap, const char *tag, jsdl__ProcessorArchitectureEnumeration_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__ProcessorArchitectureEnumeration_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_, sizeof(jsdl__ProcessorArchitectureEnumeration_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_)
			return (jsdl__ProcessorArchitectureEnumeration_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_jsdl__ProcessorArchitectureEnumeration(soap, tag, &(a->jsdl__ProcessorArchitectureEnumeration_::__item), "jsdl:ProcessorArchitectureEnumeration"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__ProcessorArchitectureEnumeration_ * SOAP_FMAC6 soap_new_jsdl__ProcessorArchitectureEnumeration_(struct soap *soap, int n)
{	return soap_instantiate_jsdl__ProcessorArchitectureEnumeration_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__ProcessorArchitectureEnumeration_(struct soap *soap, jsdl__ProcessorArchitectureEnumeration_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__ProcessorArchitectureEnumeration_ * SOAP_FMAC4 soap_instantiate_jsdl__ProcessorArchitectureEnumeration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__ProcessorArchitectureEnumeration_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__ProcessorArchitectureEnumeration_;
		if (size)
			*size = sizeof(jsdl__ProcessorArchitectureEnumeration_);
		((jsdl__ProcessorArchitectureEnumeration_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__ProcessorArchitectureEnumeration_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__ProcessorArchitectureEnumeration_);
		for (int i = 0; i < n; i++)
			((jsdl__ProcessorArchitectureEnumeration_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__ProcessorArchitectureEnumeration_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__ProcessorArchitectureEnumeration_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__ProcessorArchitectureEnumeration_ %p -> %p\n", q, p));
	*(jsdl__ProcessorArchitectureEnumeration_*)p = *(jsdl__ProcessorArchitectureEnumeration_*)q;
}

void besfactory2__FaultCodesType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_besfactory2__FaultCodesType(soap, &this->besfactory2__FaultCodesType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__FaultCodesType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int besfactory2__FaultCodesType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__FaultCodesType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__FaultCodesType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__FaultCodesType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__FaultCodesType_(struct soap *soap, const char *tag, int id, const besfactory2__FaultCodesType_ *a, const char *type)
{
	return soap_out_besfactory2__FaultCodesType(soap, tag, id, &(a->besfactory2__FaultCodesType_::__item), "besfactory2:FaultCodesType");
}

void *besfactory2__FaultCodesType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__FaultCodesType_(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__FaultCodesType_ * SOAP_FMAC4 soap_get_besfactory2__FaultCodesType_(struct soap *soap, besfactory2__FaultCodesType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__FaultCodesType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__FaultCodesType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__FaultCodesType_(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__FaultCodesType_ * SOAP_FMAC4 soap_in_besfactory2__FaultCodesType_(struct soap *soap, const char *tag, besfactory2__FaultCodesType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory2__FaultCodesType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__FaultCodesType_, sizeof(besfactory2__FaultCodesType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__FaultCodesType_)
			return (besfactory2__FaultCodesType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_besfactory2__FaultCodesType(soap, tag, &(a->besfactory2__FaultCodesType_::__item), "besfactory2:FaultCodesType"))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory2__FaultCodesType_ * SOAP_FMAC6 soap_new_besfactory2__FaultCodesType_(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__FaultCodesType_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__FaultCodesType_(struct soap *soap, besfactory2__FaultCodesType_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__FaultCodesType_ * SOAP_FMAC4 soap_instantiate_besfactory2__FaultCodesType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__FaultCodesType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__FaultCodesType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__FaultCodesType_;
		if (size)
			*size = sizeof(besfactory2__FaultCodesType_);
		((besfactory2__FaultCodesType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__FaultCodesType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__FaultCodesType_);
		for (int i = 0; i < n; i++)
			((besfactory2__FaultCodesType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__FaultCodesType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__FaultCodesType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__FaultCodesType_ %p -> %p\n", q, p));
	*(besfactory2__FaultCodesType_*)p = *(besfactory2__FaultCodesType_*)q;
}

void besfactory2__RelationshipType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_besfactory2__RelationshipType(soap, &this->besfactory2__RelationshipType_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__RelationshipType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int besfactory2__RelationshipType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__RelationshipType_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__RelationshipType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__RelationshipType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__RelationshipType_(struct soap *soap, const char *tag, int id, const besfactory2__RelationshipType_ *a, const char *type)
{
	return soap_out_besfactory2__RelationshipType(soap, tag, id, &(a->besfactory2__RelationshipType_::__item), "besfactory2:RelationshipType");
}

void *besfactory2__RelationshipType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__RelationshipType_(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__RelationshipType_ * SOAP_FMAC4 soap_get_besfactory2__RelationshipType_(struct soap *soap, besfactory2__RelationshipType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__RelationshipType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__RelationshipType_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__RelationshipType_(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__RelationshipType_ * SOAP_FMAC4 soap_in_besfactory2__RelationshipType_(struct soap *soap, const char *tag, besfactory2__RelationshipType_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory2__RelationshipType_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__RelationshipType_, sizeof(besfactory2__RelationshipType_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__RelationshipType_)
			return (besfactory2__RelationshipType_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_besfactory2__RelationshipType(soap, tag, &(a->besfactory2__RelationshipType_::__item), "besfactory2:RelationshipType"))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory2__RelationshipType_ * SOAP_FMAC6 soap_new_besfactory2__RelationshipType_(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__RelationshipType_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__RelationshipType_(struct soap *soap, besfactory2__RelationshipType_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__RelationshipType_ * SOAP_FMAC4 soap_instantiate_besfactory2__RelationshipType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__RelationshipType_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__RelationshipType_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__RelationshipType_;
		if (size)
			*size = sizeof(besfactory2__RelationshipType_);
		((besfactory2__RelationshipType_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__RelationshipType_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__RelationshipType_);
		for (int i = 0; i < n; i++)
			((besfactory2__RelationshipType_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__RelationshipType_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__RelationshipType_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__RelationshipType_ %p -> %p\n", q, p));
	*(besfactory2__RelationshipType_*)p = *(besfactory2__RelationshipType_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_besfactory2__FaultCodesOpenEnumType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_besfactory2__FaultCodesOpenEnumType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_besfactory2__FaultCodesOpenEnumType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType);
	if (soap_out_besfactory2__FaultCodesOpenEnumType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_besfactory2__FaultCodesOpenEnumType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_besfactory2__FaultCodesOpenEnumType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType, 0, sizeof(std::string), 0, soap_copy_besfactory2__FaultCodesOpenEnumType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_besfactory2__FaultCodesOpenEnumType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__FaultCodesOpenEnumType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__FaultCodesOpenEnumType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_besfactory2__FaultCodesOpenEnumType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__FaultCodesOpenEnumType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__FaultCodesOpenEnumType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__FaultCodesOpenEnumType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum);
	if (soap_out_besfactory2__RelationshipTypeOpenEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum, 0, sizeof(std::string), 0, soap_copy_besfactory2__RelationshipTypeOpenEnum);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__RelationshipTypeOpenEnum(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__RelationshipTypeOpenEnum(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__RelationshipTypeOpenEnum, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__RelationshipTypeOpenEnum(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void jsdl__SourceTarget_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__SourceTarget_USCOREType::jsdl__URI = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	this->jsdl__SourceTarget_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__SourceTarget_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->jsdl__SourceTarget_USCOREType::jsdl__URI);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__SourceTarget_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__SourceTarget_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType), "jsdl:SourceTarget_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__anyURI(soap, "jsdl:URI", -1, &(a->jsdl__SourceTarget_USCOREType::jsdl__URI), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__SourceTarget_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__SourceTarget_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__SourceTarget_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get_jsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__SourceTarget_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__SourceTarget_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__SourceTarget_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__SourceTarget_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__URI1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "jsdl:URI", &(a->jsdl__SourceTarget_USCOREType::jsdl__URI), "xsd:anyURI"))
				{	soap_flag_jsdl__URI1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__SourceTarget_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType, 0, sizeof(jsdl__SourceTarget_USCOREType), 0, soap_copy_jsdl__SourceTarget_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__SourceTarget_USCOREType * SOAP_FMAC6 soap_new_jsdl__SourceTarget_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__SourceTarget_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__SourceTarget_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__SourceTarget_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType;
		if (size)
			*size = sizeof(jsdl__SourceTarget_USCOREType);
		((jsdl__SourceTarget_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__SourceTarget_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__SourceTarget_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__SourceTarget_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__SourceTarget_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__SourceTarget_USCOREType %p -> %p\n", q, p));
	*(jsdl__SourceTarget_USCOREType*)p = *(jsdl__SourceTarget_USCOREType*)q;
}

void jsdl__DataStaging_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName);
	this->jsdl__DataStaging_USCOREType::jsdl__FilesystemName = NULL;
	soap_default_jsdl__CreationFlagEnumeration(soap, &this->jsdl__DataStaging_USCOREType::jsdl__CreationFlag);
	this->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination = NULL;
	this->jsdl__DataStaging_USCOREType::jsdl__Source = NULL;
	this->jsdl__DataStaging_USCOREType::jsdl__Target = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	this->jsdl__DataStaging_USCOREType::name = NULL;
	this->jsdl__DataStaging_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__DataStaging_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName, SOAP_TYPE_besfactory_std__string);
	soap_serialize_std__string(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName);
	soap_serialize_PointerToxsd__NCName(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FilesystemName);
	soap_serialize_PointerTobool(soap, &this->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::jsdl__Source);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::jsdl__Target);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__DataStaging_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__DataStaging_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (((jsdl__DataStaging_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((jsdl__DataStaging_USCOREType*)a)->name->c_str());
	if (((jsdl__DataStaging_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__DataStaging_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType), "jsdl:DataStaging_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "jsdl:FileName", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__FileName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__NCName(soap, "jsdl:FilesystemName", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__FilesystemName), ""))
		return soap->error;
	if (soap_out_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__CreationFlag), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "jsdl:DeleteOnTermination", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__Source), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__Target), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__DataStaging_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__DataStaging_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__DataStaging_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get_jsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__DataStaging_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__DataStaging_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__DataStaging_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__DataStaging_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdl__DataStaging_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((jsdl__DataStaging_USCOREType*)a)->name->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__DataStaging_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__FileName1 = 1;
	size_t soap_flag_jsdl__FilesystemName1 = 1;
	size_t soap_flag_jsdl__CreationFlag1 = 1;
	size_t soap_flag_jsdl__DeleteOnTermination1 = 1;
	size_t soap_flag_jsdl__Source1 = 1;
	size_t soap_flag_jsdl__Target1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__FileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jsdl:FileName", &(a->jsdl__DataStaging_USCOREType::jsdl__FileName), "xsd:string"))
				{	soap_flag_jsdl__FileName1--;
					continue;
				}
			if (soap_flag_jsdl__FilesystemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__NCName(soap, "jsdl:FilesystemName", &(a->jsdl__DataStaging_USCOREType::jsdl__FilesystemName), "xsd:NCName"))
				{	soap_flag_jsdl__FilesystemName1--;
					continue;
				}
			if (soap_flag_jsdl__CreationFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", &(a->jsdl__DataStaging_USCOREType::jsdl__CreationFlag), "jsdl:CreationFlagEnumeration"))
				{	soap_flag_jsdl__CreationFlag1--;
					continue;
				}
			if (soap_flag_jsdl__DeleteOnTermination1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "jsdl:DeleteOnTermination", &(a->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination), "xsd:boolean"))
				{	soap_flag_jsdl__DeleteOnTermination1--;
					continue;
				}
			if (soap_flag_jsdl__Source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", &(a->jsdl__DataStaging_USCOREType::jsdl__Source), "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Source1--;
					continue;
				}
			if (soap_flag_jsdl__Target1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", &(a->jsdl__DataStaging_USCOREType::jsdl__Target), "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Target1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__DataStaging_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType, 0, sizeof(jsdl__DataStaging_USCOREType), 0, soap_copy_jsdl__DataStaging_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__FileName1 > 0 || soap_flag_jsdl__CreationFlag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__DataStaging_USCOREType * SOAP_FMAC6 soap_new_jsdl__DataStaging_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__DataStaging_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType;
		if (size)
			*size = sizeof(jsdl__DataStaging_USCOREType);
		((jsdl__DataStaging_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__DataStaging_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__DataStaging_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__DataStaging_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__DataStaging_USCOREType %p -> %p\n", q, p));
	*(jsdl__DataStaging_USCOREType*)p = *(jsdl__DataStaging_USCOREType*)q;
}

void jsdl__OperatingSystemType_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, &this->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	this->jsdl__OperatingSystemType_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystemType_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystemType_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__OperatingSystemType_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType), "jsdl:OperatingSystemType_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", -1, &(a->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystemType_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystemType_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__OperatingSystemType_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystemType_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystemType_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__OperatingSystemName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__OperatingSystemName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", &(a->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName), "jsdl:OperatingSystemTypeEnumeration"))
				{	soap_flag_jsdl__OperatingSystemName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType, 0, sizeof(jsdl__OperatingSystemType_USCOREType), 0, soap_copy_jsdl__OperatingSystemType_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__OperatingSystemName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC6 soap_new_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystemType_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType;
		if (size)
			*size = sizeof(jsdl__OperatingSystemType_USCOREType);
		((jsdl__OperatingSystemType_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystemType_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystemType_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystemType_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystemType_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystemType_USCOREType*)p = *(jsdl__OperatingSystemType_USCOREType*)q;
}

void jsdl__OperatingSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType = NULL;
	this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion = NULL;
	this->jsdl__OperatingSystem_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	this->jsdl__OperatingSystem_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__OperatingSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType), "jsdl:OperatingSystem_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:OperatingSystemVersion", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__OperatingSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__OperatingSystemType1 = 1;
	size_t soap_flag_jsdl__OperatingSystemVersion1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__OperatingSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType), "jsdl:OperatingSystemType_Type"))
				{	soap_flag_jsdl__OperatingSystemType1--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystemVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:OperatingSystemVersion", &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion), "xsd:string"))
				{	soap_flag_jsdl__OperatingSystemVersion1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__OperatingSystem_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType, 0, sizeof(jsdl__OperatingSystem_USCOREType), 0, soap_copy_jsdl__OperatingSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__OperatingSystem_USCOREType * SOAP_FMAC6 soap_new_jsdl__OperatingSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__OperatingSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType;
		if (size)
			*size = sizeof(jsdl__OperatingSystem_USCOREType);
		((jsdl__OperatingSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystem_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystem_USCOREType*)p = *(jsdl__OperatingSystem_USCOREType*)q;
}

void jsdl__FileSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__FileSystem_USCOREType::jsdl__FileSystemType = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__Description = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__MountPoint = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__DiskSpace = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	soap_default_xsd__NCName(soap, &this->jsdl__FileSystem_USCOREType::name);
	this->jsdl__FileSystem_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__FileSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, &this->jsdl__FileSystem_USCOREType::jsdl__FileSystemType);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::jsdl__Description);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__FileSystem_USCOREType::jsdl__MountPoint);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::jsdl__DiskSpace);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__FileSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__FileSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (!((jsdl__FileSystem_USCOREType*)a)->name.empty())
		soap_set_attr(soap, "name", ((jsdl__FileSystem_USCOREType*)a)->name.c_str());
	if (((jsdl__FileSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__FileSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType), "jsdl:FileSystem_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__FileSystemType), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:MountPoint", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__MountPoint), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__DiskSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__FileSystem_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__FileSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__FileSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__FileSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__FileSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__FileSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__FileSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((jsdl__FileSystem_USCOREType*)a)->name.assign(s);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__FileSystem_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__FileSystemType1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	size_t soap_flag_jsdl__MountPoint1 = 1;
	size_t soap_flag_jsdl__DiskSpace1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__FileSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", &(a->jsdl__FileSystem_USCOREType::jsdl__FileSystemType), "jsdl:FileSystemTypeEnumeration"))
				{	soap_flag_jsdl__FileSystemType1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__FileSystem_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap_flag_jsdl__MountPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:MountPoint", &(a->jsdl__FileSystem_USCOREType::jsdl__MountPoint), "xsd:string"))
				{	soap_flag_jsdl__MountPoint1--;
					continue;
				}
			if (soap_flag_jsdl__DiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", &(a->jsdl__FileSystem_USCOREType::jsdl__DiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__DiskSpace1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__FileSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType, 0, sizeof(jsdl__FileSystem_USCOREType), 0, soap_copy_jsdl__FileSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__FileSystem_USCOREType * SOAP_FMAC6 soap_new_jsdl__FileSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__FileSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType;
		if (size)
			*size = sizeof(jsdl__FileSystem_USCOREType);
		((jsdl__FileSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__FileSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__FileSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__FileSystem_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__FileSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__FileSystem_USCOREType*)p = *(jsdl__FileSystem_USCOREType*)q;
}

void jsdl__CPUArchitecture_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, &this->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	this->jsdl__CPUArchitecture_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__CPUArchitecture_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__CPUArchitecture_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__CPUArchitecture_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType), "jsdl:CPUArchitecture_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", -1, &(a->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__CPUArchitecture_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CPUArchitecture_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get_jsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__CPUArchitecture_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CPUArchitecture_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CPUArchitecture_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__CPUArchitectureName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__CPUArchitectureName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", &(a->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName), "jsdl:ProcessorArchitectureEnumeration"))
				{	soap_flag_jsdl__CPUArchitectureName1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType, 0, sizeof(jsdl__CPUArchitecture_USCOREType), 0, soap_copy_jsdl__CPUArchitecture_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__CPUArchitectureName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC6 soap_new_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CPUArchitecture_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType;
		if (size)
			*size = sizeof(jsdl__CPUArchitecture_USCOREType);
		((jsdl__CPUArchitecture_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CPUArchitecture_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CPUArchitecture_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CPUArchitecture_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CPUArchitecture_USCOREType %p -> %p\n", q, p));
	*(jsdl__CPUArchitecture_USCOREType*)p = *(jsdl__CPUArchitecture_USCOREType*)q;
}

void jsdl__CandidateHosts_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::jsdl__HostName);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__CandidateHosts_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::jsdl__HostName);
	/* transient soap skipped */
}

int jsdl__CandidateHosts_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__CandidateHosts_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType), "jsdl:CandidateHosts_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:HostName", -1, &(a->jsdl__CandidateHosts_USCOREType::jsdl__HostName), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__CandidateHosts_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CandidateHosts_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get_jsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__CandidateHosts_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CandidateHosts_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CandidateHosts_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:HostName", &(a->jsdl__CandidateHosts_USCOREType::jsdl__HostName), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType, 0, sizeof(jsdl__CandidateHosts_USCOREType), 0, soap_copy_jsdl__CandidateHosts_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__CandidateHosts_USCOREType * SOAP_FMAC6 soap_new_jsdl__CandidateHosts_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__CandidateHosts_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CandidateHosts_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType;
		if (size)
			*size = sizeof(jsdl__CandidateHosts_USCOREType);
		((jsdl__CandidateHosts_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CandidateHosts_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CandidateHosts_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CandidateHosts_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CandidateHosts_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CandidateHosts_USCOREType %p -> %p\n", q, p));
	*(jsdl__CandidateHosts_USCOREType*)p = *(jsdl__CandidateHosts_USCOREType*)q;
}

void jsdl__Resources_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Resources_USCOREType::jsdl__CandidateHosts = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__FileSystem);
	this->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution = NULL;
	this->jsdl__Resources_USCOREType::jsdl__OperatingSystem = NULL;
	this->jsdl__Resources_USCOREType::jsdl__CPUArchitecture = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalCPUTime = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalCPUCount = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalResourceCount = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	this->jsdl__Resources_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__Resources_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__CandidateHosts);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__FileSystem);
	soap_serialize_PointerTobool(soap, &this->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__CPUArchitecture);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalResourceCount);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Resources_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Resources_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Resources_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Resources_USCOREType *a, const char *type)
{
	if (((jsdl__Resources_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Resources_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType), "jsdl:Resources_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", -1, &(a->jsdl__Resources_USCOREType::jsdl__CandidateHosts), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", -1, &(a->jsdl__Resources_USCOREType::jsdl__FileSystem), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "jsdl:ExclusiveExecution", -1, &(a->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", -1, &(a->jsdl__Resources_USCOREType::jsdl__OperatingSystem), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", -1, &(a->jsdl__Resources_USCOREType::jsdl__CPUArchitecture), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalResourceCount), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Resources_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__Resources_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Resources_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get_jsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Resources_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Resources_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Resources_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__Resources_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Resources_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Resources_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__CandidateHosts1 = 1;
	size_t soap_flag_jsdl__ExclusiveExecution1 = 1;
	size_t soap_flag_jsdl__OperatingSystem1 = 1;
	size_t soap_flag_jsdl__CPUArchitecture1 = 1;
	size_t soap_flag_jsdl__IndividualCPUSpeed1 = 1;
	size_t soap_flag_jsdl__IndividualCPUTime1 = 1;
	size_t soap_flag_jsdl__IndividualCPUCount1 = 1;
	size_t soap_flag_jsdl__IndividualNetworkBandwidth1 = 1;
	size_t soap_flag_jsdl__IndividualPhysicalMemory1 = 1;
	size_t soap_flag_jsdl__IndividualVirtualMemory1 = 1;
	size_t soap_flag_jsdl__IndividualDiskSpace1 = 1;
	size_t soap_flag_jsdl__TotalCPUTime1 = 1;
	size_t soap_flag_jsdl__TotalCPUCount1 = 1;
	size_t soap_flag_jsdl__TotalPhysicalMemory1 = 1;
	size_t soap_flag_jsdl__TotalVirtualMemory1 = 1;
	size_t soap_flag_jsdl__TotalDiskSpace1 = 1;
	size_t soap_flag_jsdl__TotalResourceCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__CandidateHosts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", &(a->jsdl__Resources_USCOREType::jsdl__CandidateHosts), "jsdl:CandidateHosts_Type"))
				{	soap_flag_jsdl__CandidateHosts1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", &(a->jsdl__Resources_USCOREType::jsdl__FileSystem), "jsdl:FileSystem_Type"))
					continue;
			if (soap_flag_jsdl__ExclusiveExecution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "jsdl:ExclusiveExecution", &(a->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution), "xsd:boolean"))
				{	soap_flag_jsdl__ExclusiveExecution1--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", &(a->jsdl__Resources_USCOREType::jsdl__OperatingSystem), "jsdl:OperatingSystem_Type"))
				{	soap_flag_jsdl__OperatingSystem1--;
					continue;
				}
			if (soap_flag_jsdl__CPUArchitecture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", &(a->jsdl__Resources_USCOREType::jsdl__CPUArchitecture), "jsdl:CPUArchitecture_Type"))
				{	soap_flag_jsdl__CPUArchitecture1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUSpeed1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUTime1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUCount1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualNetworkBandwidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", &(a->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualNetworkBandwidth1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", &(a->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualPhysicalMemory1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", &(a->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualVirtualMemory1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", &(a->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualDiskSpace1--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUTime1--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUCount1--;
					continue;
				}
			if (soap_flag_jsdl__TotalPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", &(a->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalPhysicalMemory1--;
					continue;
				}
			if (soap_flag_jsdl__TotalVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", &(a->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalVirtualMemory1--;
					continue;
				}
			if (soap_flag_jsdl__TotalDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", &(a->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalDiskSpace1--;
					continue;
				}
			if (soap_flag_jsdl__TotalResourceCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", &(a->jsdl__Resources_USCOREType::jsdl__TotalResourceCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalResourceCount1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Resources_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType, 0, sizeof(jsdl__Resources_USCOREType), 0, soap_copy_jsdl__Resources_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Resources_USCOREType * SOAP_FMAC6 soap_new_jsdl__Resources_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Resources_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Resources_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Resources_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Resources_USCOREType;
		if (size)
			*size = sizeof(jsdl__Resources_USCOREType);
		((jsdl__Resources_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Resources_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Resources_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Resources_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Resources_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Resources_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Resources_USCOREType %p -> %p\n", q, p));
	*(jsdl__Resources_USCOREType*)p = *(jsdl__Resources_USCOREType*)q;
}

void jsdl__Application_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Application_USCOREType::jsdl__ApplicationName = NULL;
	this->jsdl__Application_USCOREType::jsdl__ApplicationVersion = NULL;
	this->jsdl__Application_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	this->jsdl__Application_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__Application_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::jsdl__ApplicationName);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::jsdl__ApplicationVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__Application_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Application_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__Application_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Application_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Application_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Application_USCOREType *a, const char *type)
{
	if (((jsdl__Application_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Application_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__Application_USCOREType), "jsdl:Application_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "jsdl:ApplicationName", -1, &(a->jsdl__Application_USCOREType::jsdl__ApplicationName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:ApplicationVersion", -1, &(a->jsdl__Application_USCOREType::jsdl__ApplicationVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__Application_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Application_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__Application_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Application_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_get_jsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Application_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Application_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_in_jsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Application_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__Application_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Application_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Application_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__ApplicationName1 = 1;
	size_t soap_flag_jsdl__ApplicationVersion1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__ApplicationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:ApplicationName", &(a->jsdl__Application_USCOREType::jsdl__ApplicationName), "xsd:string"))
				{	soap_flag_jsdl__ApplicationName1--;
					continue;
				}
			if (soap_flag_jsdl__ApplicationVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:ApplicationVersion", &(a->jsdl__Application_USCOREType::jsdl__ApplicationVersion), "xsd:string"))
				{	soap_flag_jsdl__ApplicationVersion1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__Application_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Application_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__Application_USCOREType, 0, sizeof(jsdl__Application_USCOREType), 0, soap_copy_jsdl__Application_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Application_USCOREType * SOAP_FMAC6 soap_new_jsdl__Application_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Application_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Application_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Application_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__Application_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Application_USCOREType;
		if (size)
			*size = sizeof(jsdl__Application_USCOREType);
		((jsdl__Application_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Application_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Application_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Application_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Application_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Application_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Application_USCOREType %p -> %p\n", q, p));
	*(jsdl__Application_USCOREType*)p = *(jsdl__Application_USCOREType*)q;
}

void jsdl__JobIdentification_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobIdentification_USCOREType::jsdl__JobName = NULL;
	this->jsdl__JobIdentification_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobProject);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	this->jsdl__JobIdentification_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__JobIdentification_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobName);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobProject);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobIdentification_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobIdentification_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType), "jsdl:JobIdentification_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTostd__string(soap, "jsdl:JobName", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobName), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:JobAnnotation", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:JobProject", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobProject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobIdentification_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobIdentification_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobIdentification_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobIdentification_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobIdentification_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobIdentification_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobIdentification_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__JobName1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__JobName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:JobName", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobName), "xsd:string"))
				{	soap_flag_jsdl__JobName1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__JobIdentification_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:JobAnnotation", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:JobProject", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobProject), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobIdentification_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType, 0, sizeof(jsdl__JobIdentification_USCOREType), 0, soap_copy_jsdl__JobIdentification_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobIdentification_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobIdentification_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobIdentification_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobIdentification_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobIdentification_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobIdentification_USCOREType);
		((jsdl__JobIdentification_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobIdentification_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobIdentification_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobIdentification_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobIdentification_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobIdentification_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobIdentification_USCOREType*)p = *(jsdl__JobIdentification_USCOREType*)q;
}

void jsdl__JobDescription_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDescription_USCOREType::jsdl__JobIdentification = NULL;
	this->jsdl__JobDescription_USCOREType::jsdl__Application = NULL;
	this->jsdl__JobDescription_USCOREType::jsdl__Resources = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__DataStaging);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	this->jsdl__JobDescription_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__JobDescription_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__JobIdentification);
	soap_serialize_PointerTojsdl__Application_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__Application);
	soap_serialize_PointerTojsdl__Resources_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__Resources);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__DataStaging);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDescription_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobDescription_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (((jsdl__JobDescription_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDescription_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType), "jsdl:JobDescription_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__JobIdentification), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__Application), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__Resources), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__DataStaging), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDescription_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDescription_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDescription_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobDescription_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDescription_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDescription_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDescription_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDescription_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__JobIdentification1 = 1;
	size_t soap_flag_jsdl__Application1 = 1;
	size_t soap_flag_jsdl__Resources1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__JobIdentification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", &(a->jsdl__JobDescription_USCOREType::jsdl__JobIdentification), "jsdl:JobIdentification_Type"))
				{	soap_flag_jsdl__JobIdentification1--;
					continue;
				}
			if (soap_flag_jsdl__Application1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", &(a->jsdl__JobDescription_USCOREType::jsdl__Application), "jsdl:Application_Type"))
				{	soap_flag_jsdl__Application1--;
					continue;
				}
			if (soap_flag_jsdl__Resources1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", &(a->jsdl__JobDescription_USCOREType::jsdl__Resources), "jsdl:Resources_Type"))
				{	soap_flag_jsdl__Resources1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", &(a->jsdl__JobDescription_USCOREType::jsdl__DataStaging), "jsdl:DataStaging_Type"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDescription_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType, 0, sizeof(jsdl__JobDescription_USCOREType), 0, soap_copy_jsdl__JobDescription_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobDescription_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobDescription_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobDescription_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobDescription_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDescription_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobDescription_USCOREType);
		((jsdl__JobDescription_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDescription_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDescription_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDescription_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDescription_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDescription_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDescription_USCOREType*)p = *(jsdl__JobDescription_USCOREType*)q;
}

void jsdl__JobDefinition_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDefinition_USCOREType::jsdl__JobDescription = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	this->jsdl__JobDefinition_USCOREType::id = NULL;
	this->jsdl__JobDefinition_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__JobDefinition_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, &this->jsdl__JobDefinition_USCOREType::jsdl__JobDescription);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDefinition_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobDefinition_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (((jsdl__JobDefinition_USCOREType*)a)->id)
		soap_set_attr(soap, "id", ((jsdl__JobDefinition_USCOREType*)a)->id->c_str());
	if (((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType), "jsdl:JobDefinition_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", -1, &(a->jsdl__JobDefinition_USCOREType::jsdl__JobDescription), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDefinition_USCOREType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDefinition_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDefinition_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobDefinition_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDefinition_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDefinition_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDefinition_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdl__JobDefinition_USCOREType*)a)->id = soap_new_std__string(soap, -1);
				((jsdl__JobDefinition_USCOREType*)a)->id->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__JobDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__JobDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", &(a->jsdl__JobDefinition_USCOREType::jsdl__JobDescription), "jsdl:JobDescription_Type"))
				{	soap_flag_jsdl__JobDescription1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDefinition_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType, 0, sizeof(jsdl__JobDefinition_USCOREType), 0, soap_copy_jsdl__JobDefinition_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDescription1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobDefinition_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobDefinition_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobDefinition_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobDefinition_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDefinition_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobDefinition_USCOREType);
		((jsdl__JobDefinition_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDefinition_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDefinition_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDefinition_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDefinition_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDefinition_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDefinition_USCOREType*)p = *(jsdl__JobDefinition_USCOREType*)q;
}

void jsdl__RangeValue_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__RangeValue_USCOREType::UpperBoundedRange = NULL;
	this->jsdl__RangeValue_USCOREType::LowerBoundedRange = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	this->jsdl__RangeValue_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__RangeValue_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::UpperBoundedRange);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::LowerBoundedRange);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	/* transient soap skipped */
}

int jsdl__RangeValue_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__RangeValue_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (((jsdl__RangeValue_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__RangeValue_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType), "jsdl:RangeValue_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, &(a->jsdl__RangeValue_USCOREType::Exact), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "jsdl:Range", -1, &(a->jsdl__RangeValue_USCOREType::Range), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__RangeValue_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__RangeValue_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get_jsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__RangeValue_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__RangeValue_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__RangeValue_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__RangeValue_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__RangeValue_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_UpperBoundedRange1 = 1;
	size_t soap_flag_LowerBoundedRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_UpperBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange1--;
					continue;
				}
			if (soap_flag_LowerBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "jsdl:Exact", &(a->jsdl__RangeValue_USCOREType::Exact), "jsdl:Exact_Type"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "jsdl:Range", &(a->jsdl__RangeValue_USCOREType::Range), "jsdl:Range_Type"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType, 0, sizeof(jsdl__RangeValue_USCOREType), 0, soap_copy_jsdl__RangeValue_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__RangeValue_USCOREType * SOAP_FMAC6 soap_new_jsdl__RangeValue_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__RangeValue_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__RangeValue_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__RangeValue_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType;
		if (size)
			*size = sizeof(jsdl__RangeValue_USCOREType);
		((jsdl__RangeValue_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__RangeValue_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__RangeValue_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__RangeValue_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__RangeValue_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__RangeValue_USCOREType %p -> %p\n", q, p));
	*(jsdl__RangeValue_USCOREType*)p = *(jsdl__RangeValue_USCOREType*)q;
}

void jsdl__Range_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Range_USCOREType::LowerBound = NULL;
	this->jsdl__Range_USCOREType::UpperBound = NULL;
	this->jsdl__Range_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__Range_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::LowerBound);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::UpperBound);
	/* transient soap skipped */
}

int jsdl__Range_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__Range_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Range_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Range_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Range_USCOREType *a, const char *type)
{
	if (((jsdl__Range_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Range_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_jsdl__Range_USCOREType), "jsdl:Range_Type"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", -1, &(a->jsdl__Range_USCOREType::LowerBound), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", -1, &(a->jsdl__Range_USCOREType::UpperBound), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *jsdl__Range_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Range_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_get_jsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Range_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Range_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_in_jsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Range_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__Range_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Range_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Range_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_LowerBound1 = 1;
	size_t soap_flag_UpperBound1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_LowerBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", &(a->jsdl__Range_USCOREType::LowerBound), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBound1--;
					continue;
				}
			if (soap_flag_UpperBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", &(a->jsdl__Range_USCOREType::UpperBound), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBound1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Range_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_jsdl__Range_USCOREType, 0, sizeof(jsdl__Range_USCOREType), 0, soap_copy_jsdl__Range_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LowerBound1 > 0 || soap_flag_UpperBound1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Range_USCOREType * SOAP_FMAC6 soap_new_jsdl__Range_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Range_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Range_USCOREType;
		if (size)
			*size = sizeof(jsdl__Range_USCOREType);
		((jsdl__Range_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Range_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Range_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Range_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Range_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Range_USCOREType %p -> %p\n", q, p));
	*(jsdl__Range_USCOREType*)p = *(jsdl__Range_USCOREType*)q;
}

void jsdl__Exact_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Exact_USCOREType::__item);
	this->jsdl__Exact_USCOREType::epsilon = NULL;
	this->jsdl__Exact_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__Exact_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Exact_USCOREType::__item, SOAP_TYPE_besfactory_double);
	/* transient soap skipped */
}

int jsdl__Exact_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__Exact_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Exact_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Exact_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Exact_USCOREType *a, const char *type)
{
	if (((jsdl__Exact_USCOREType*)a)->epsilon)
		soap_set_attr(soap, "epsilon", soap_double2s(soap, *((jsdl__Exact_USCOREType*)a)->epsilon));
	if (((jsdl__Exact_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Exact_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &(a->jsdl__Exact_USCOREType::__item), "jsdl:Exact_Type");
}

void *jsdl__Exact_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Exact_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_get_jsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Exact_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Exact_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_in_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Exact_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__Exact_USCOREType)
			return (jsdl__Exact_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "epsilon", 0);
		if (t)
		{
			if (!(((jsdl__Exact_USCOREType*)a)->epsilon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((jsdl__Exact_USCOREType*)a)->epsilon))
				return NULL;
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Exact_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Exact_USCOREType::__item), "jsdl:Exact_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__Exact_USCOREType * SOAP_FMAC6 soap_new_jsdl__Exact_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Exact_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Exact_USCOREType;
		if (size)
			*size = sizeof(jsdl__Exact_USCOREType);
		((jsdl__Exact_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Exact_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Exact_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Exact_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Exact_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Exact_USCOREType %p -> %p\n", q, p));
	*(jsdl__Exact_USCOREType*)p = *(jsdl__Exact_USCOREType*)q;
}

void jsdl__Boundary_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Boundary_USCOREType::__item);
	this->jsdl__Boundary_USCOREType::exclusiveBound = NULL;
	this->jsdl__Boundary_USCOREType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void jsdl__Boundary_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Boundary_USCOREType::__item, SOAP_TYPE_besfactory_double);
	/* transient soap skipped */
}

int jsdl__Boundary_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Boundary_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Boundary_USCOREType *a, const char *type)
{
	if (((jsdl__Boundary_USCOREType*)a)->exclusiveBound)
		soap_set_attr(soap, "exclusiveBound", soap_bool2s(soap, *((jsdl__Boundary_USCOREType*)a)->exclusiveBound));
	if (((jsdl__Boundary_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Boundary_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &(a->jsdl__Boundary_USCOREType::__item), "jsdl:Boundary_Type");
}

void *jsdl__Boundary_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Boundary_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_get_jsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Boundary_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Boundary_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_in_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Boundary_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType)
			return (jsdl__Boundary_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "exclusiveBound", 0);
		if (t)
		{
			if (!(((jsdl__Boundary_USCOREType*)a)->exclusiveBound = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((jsdl__Boundary_USCOREType*)a)->exclusiveBound))
			return NULL;
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Boundary_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Boundary_USCOREType::__item), "jsdl:Boundary_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__Boundary_USCOREType * SOAP_FMAC6 soap_new_jsdl__Boundary_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Boundary_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Boundary_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Boundary_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Boundary_USCOREType;
		if (size)
			*size = sizeof(jsdl__Boundary_USCOREType);
		((jsdl__Boundary_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Boundary_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Boundary_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Boundary_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Boundary_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Boundary_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Boundary_USCOREType %p -> %p\n", q, p));
	*(jsdl__Boundary_USCOREType*)p = *(jsdl__Boundary_USCOREType*)q;
}

void besfactory2__ProblemActionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory2__ProblemActionType::besfactory2__Action = NULL;
	this->besfactory2__ProblemActionType::SoapAction = NULL;
	this->besfactory2__ProblemActionType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__ProblemActionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory2__AttributedURIType(soap, &this->besfactory2__ProblemActionType::besfactory2__Action);
	soap_serialize_PointerToxsd__anyURI(soap, &this->besfactory2__ProblemActionType::SoapAction);
	/* transient soap skipped */
}

int besfactory2__ProblemActionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__ProblemActionType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__ProblemActionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__ProblemActionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__ProblemActionType(struct soap *soap, const char *tag, int id, const besfactory2__ProblemActionType *a, const char *type)
{
	if (((besfactory2__ProblemActionType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__ProblemActionType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory2__ProblemActionType), "besfactory2:ProblemActionType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobesfactory2__AttributedURIType(soap, "besfactory2:Action", -1, &(a->besfactory2__ProblemActionType::besfactory2__Action), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "besfactory2:SoapAction", -1, &(a->besfactory2__ProblemActionType::SoapAction), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory2__ProblemActionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__ProblemActionType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__ProblemActionType * SOAP_FMAC4 soap_get_besfactory2__ProblemActionType(struct soap *soap, besfactory2__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__ProblemActionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__ProblemActionType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__ProblemActionType * SOAP_FMAC4 soap_in_besfactory2__ProblemActionType(struct soap *soap, const char *tag, besfactory2__ProblemActionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory2__ProblemActionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__ProblemActionType, sizeof(besfactory2__ProblemActionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__ProblemActionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory2__ProblemActionType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__ProblemActionType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_besfactory2__Action1 = 1;
	size_t soap_flag_SoapAction1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_besfactory2__Action1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__AttributedURIType(soap, "besfactory2:Action", &(a->besfactory2__ProblemActionType::besfactory2__Action), "besfactory2:AttributedURIType"))
				{	soap_flag_besfactory2__Action1--;
					continue;
				}
			if (soap_flag_SoapAction1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "besfactory2:SoapAction", &(a->besfactory2__ProblemActionType::SoapAction), "xsd:anyURI"))
				{	soap_flag_SoapAction1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory2__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory2__ProblemActionType, 0, sizeof(besfactory2__ProblemActionType), 0, soap_copy_besfactory2__ProblemActionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory2__ProblemActionType * SOAP_FMAC6 soap_new_besfactory2__ProblemActionType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__ProblemActionType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__ProblemActionType(struct soap *soap, besfactory2__ProblemActionType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__ProblemActionType * SOAP_FMAC4 soap_instantiate_besfactory2__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__ProblemActionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__ProblemActionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__ProblemActionType;
		if (size)
			*size = sizeof(besfactory2__ProblemActionType);
		((besfactory2__ProblemActionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__ProblemActionType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__ProblemActionType);
		for (int i = 0; i < n; i++)
			((besfactory2__ProblemActionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__ProblemActionType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__ProblemActionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__ProblemActionType %p -> %p\n", q, p));
	*(besfactory2__ProblemActionType*)p = *(besfactory2__ProblemActionType*)q;
}

void besfactory2__AttributedAnyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory2__AttributedAnyType::__any = NULL;
	this->besfactory2__AttributedAnyType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__AttributedAnyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int besfactory2__AttributedAnyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__AttributedAnyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__AttributedAnyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__AttributedAnyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__AttributedAnyType(struct soap *soap, const char *tag, int id, const besfactory2__AttributedAnyType *a, const char *type)
{
	if (((besfactory2__AttributedAnyType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__AttributedAnyType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory2__AttributedAnyType), "besfactory2:AttributedAnyType"))
		return soap->error;
	/* transient soap skipped */
	soap_outliteral(soap, "-any", &(a->besfactory2__AttributedAnyType::__any), NULL);
	return soap_element_end_out(soap, tag);
}

void *besfactory2__AttributedAnyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__AttributedAnyType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__AttributedAnyType * SOAP_FMAC4 soap_get_besfactory2__AttributedAnyType(struct soap *soap, besfactory2__AttributedAnyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__AttributedAnyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__AttributedAnyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__AttributedAnyType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__AttributedAnyType * SOAP_FMAC4 soap_in_besfactory2__AttributedAnyType(struct soap *soap, const char *tag, besfactory2__AttributedAnyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory2__AttributedAnyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__AttributedAnyType, sizeof(besfactory2__AttributedAnyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__AttributedAnyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory2__AttributedAnyType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__AttributedAnyType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->besfactory2__AttributedAnyType::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory2__AttributedAnyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory2__AttributedAnyType, 0, sizeof(besfactory2__AttributedAnyType), 0, soap_copy_besfactory2__AttributedAnyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory2__AttributedAnyType * SOAP_FMAC6 soap_new_besfactory2__AttributedAnyType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__AttributedAnyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__AttributedAnyType(struct soap *soap, besfactory2__AttributedAnyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__AttributedAnyType * SOAP_FMAC4 soap_instantiate_besfactory2__AttributedAnyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__AttributedAnyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__AttributedAnyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__AttributedAnyType;
		if (size)
			*size = sizeof(besfactory2__AttributedAnyType);
		((besfactory2__AttributedAnyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__AttributedAnyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__AttributedAnyType);
		for (int i = 0; i < n; i++)
			((besfactory2__AttributedAnyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__AttributedAnyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__AttributedAnyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__AttributedAnyType %p -> %p\n", q, p));
	*(besfactory2__AttributedAnyType*)p = *(besfactory2__AttributedAnyType*)q;
}

void besfactory2__AttributedQNameType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__QName(soap, &this->besfactory2__AttributedQNameType::__item);
	this->besfactory2__AttributedQNameType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__AttributedQNameType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__QName(soap, &this->besfactory2__AttributedQNameType::__item);
	/* transient soap skipped */
}

int besfactory2__AttributedQNameType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__AttributedQNameType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__AttributedQNameType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__AttributedQNameType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__AttributedQNameType(struct soap *soap, const char *tag, int id, const besfactory2__AttributedQNameType *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	if (((besfactory2__AttributedQNameType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__AttributedQNameType*)a)->__anyAttribute);
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "besfactory2:AttributedQNameType");
}

void *besfactory2__AttributedQNameType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__AttributedQNameType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__AttributedQNameType * SOAP_FMAC4 soap_get_besfactory2__AttributedQNameType(struct soap *soap, besfactory2__AttributedQNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__AttributedQNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__AttributedQNameType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__AttributedQNameType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__AttributedQNameType * SOAP_FMAC4 soap_in_besfactory2__AttributedQNameType(struct soap *soap, const char *tag, besfactory2__AttributedQNameType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory2__AttributedQNameType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__AttributedQNameType, sizeof(besfactory2__AttributedQNameType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__AttributedQNameType)
			return (besfactory2__AttributedQNameType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__AttributedQNameType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__QName(soap, tag, &(a->besfactory2__AttributedQNameType::__item), "besfactory2:AttributedQNameType"))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory2__AttributedQNameType * SOAP_FMAC6 soap_new_besfactory2__AttributedQNameType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__AttributedQNameType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__AttributedQNameType(struct soap *soap, besfactory2__AttributedQNameType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__AttributedQNameType * SOAP_FMAC4 soap_instantiate_besfactory2__AttributedQNameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__AttributedQNameType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__AttributedQNameType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__AttributedQNameType;
		if (size)
			*size = sizeof(besfactory2__AttributedQNameType);
		((besfactory2__AttributedQNameType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__AttributedQNameType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__AttributedQNameType);
		for (int i = 0; i < n; i++)
			((besfactory2__AttributedQNameType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__AttributedQNameType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__AttributedQNameType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__AttributedQNameType %p -> %p\n", q, p));
	*(besfactory2__AttributedQNameType*)p = *(besfactory2__AttributedQNameType*)q;
}

void besfactory2__AttributedUnsignedLongType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedLONG64(soap, &this->besfactory2__AttributedUnsignedLongType::__item);
	this->besfactory2__AttributedUnsignedLongType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__AttributedUnsignedLongType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->besfactory2__AttributedUnsignedLongType::__item, SOAP_TYPE_besfactory_unsignedLONG64);
	/* transient soap skipped */
}

int besfactory2__AttributedUnsignedLongType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__AttributedUnsignedLongType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__AttributedUnsignedLongType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__AttributedUnsignedLongType(struct soap *soap, const char *tag, int id, const besfactory2__AttributedUnsignedLongType *a, const char *type)
{
	if (((besfactory2__AttributedUnsignedLongType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__AttributedUnsignedLongType*)a)->__anyAttribute);
	return soap_out_unsignedLONG64(soap, tag, id, &(a->besfactory2__AttributedUnsignedLongType::__item), "besfactory2:AttributedUnsignedLongType");
}

void *besfactory2__AttributedUnsignedLongType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__AttributedUnsignedLongType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__AttributedUnsignedLongType * SOAP_FMAC4 soap_get_besfactory2__AttributedUnsignedLongType(struct soap *soap, besfactory2__AttributedUnsignedLongType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__AttributedUnsignedLongType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__AttributedUnsignedLongType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__AttributedUnsignedLongType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__AttributedUnsignedLongType * SOAP_FMAC4 soap_in_besfactory2__AttributedUnsignedLongType(struct soap *soap, const char *tag, besfactory2__AttributedUnsignedLongType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory2__AttributedUnsignedLongType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType, sizeof(besfactory2__AttributedUnsignedLongType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType)
			return (besfactory2__AttributedUnsignedLongType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__AttributedUnsignedLongType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_unsignedLONG64(soap, tag, &(a->besfactory2__AttributedUnsignedLongType::__item), "besfactory2:AttributedUnsignedLongType"))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory2__AttributedUnsignedLongType * SOAP_FMAC6 soap_new_besfactory2__AttributedUnsignedLongType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__AttributedUnsignedLongType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__AttributedUnsignedLongType(struct soap *soap, besfactory2__AttributedUnsignedLongType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__AttributedUnsignedLongType * SOAP_FMAC4 soap_instantiate_besfactory2__AttributedUnsignedLongType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__AttributedUnsignedLongType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__AttributedUnsignedLongType;
		if (size)
			*size = sizeof(besfactory2__AttributedUnsignedLongType);
		((besfactory2__AttributedUnsignedLongType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__AttributedUnsignedLongType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__AttributedUnsignedLongType);
		for (int i = 0; i < n; i++)
			((besfactory2__AttributedUnsignedLongType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__AttributedUnsignedLongType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__AttributedUnsignedLongType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__AttributedUnsignedLongType %p -> %p\n", q, p));
	*(besfactory2__AttributedUnsignedLongType*)p = *(besfactory2__AttributedUnsignedLongType*)q;
}

void besfactory2__AttributedURIType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->besfactory2__AttributedURIType::__item);
	this->besfactory2__AttributedURIType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__AttributedURIType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->besfactory2__AttributedURIType::__item, SOAP_TYPE_besfactory_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->besfactory2__AttributedURIType::__item);
	/* transient soap skipped */
}

int besfactory2__AttributedURIType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__AttributedURIType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__AttributedURIType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__AttributedURIType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__AttributedURIType(struct soap *soap, const char *tag, int id, const besfactory2__AttributedURIType *a, const char *type)
{
	if (((besfactory2__AttributedURIType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__AttributedURIType*)a)->__anyAttribute);
	return soap_out_xsd__anyURI(soap, tag, id, &(a->besfactory2__AttributedURIType::__item), "besfactory2:AttributedURIType");
}

void *besfactory2__AttributedURIType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__AttributedURIType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__AttributedURIType * SOAP_FMAC4 soap_get_besfactory2__AttributedURIType(struct soap *soap, besfactory2__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__AttributedURIType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__AttributedURIType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__AttributedURIType * SOAP_FMAC4 soap_in_besfactory2__AttributedURIType(struct soap *soap, const char *tag, besfactory2__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory2__AttributedURIType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__AttributedURIType, sizeof(besfactory2__AttributedURIType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__AttributedURIType)
			return (besfactory2__AttributedURIType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__AttributedURIType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &(a->besfactory2__AttributedURIType::__item), "besfactory2:AttributedURIType"))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory2__AttributedURIType * SOAP_FMAC6 soap_new_besfactory2__AttributedURIType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__AttributedURIType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__AttributedURIType(struct soap *soap, besfactory2__AttributedURIType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__AttributedURIType * SOAP_FMAC4 soap_instantiate_besfactory2__AttributedURIType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__AttributedURIType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__AttributedURIType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__AttributedURIType;
		if (size)
			*size = sizeof(besfactory2__AttributedURIType);
		((besfactory2__AttributedURIType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__AttributedURIType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__AttributedURIType);
		for (int i = 0; i < n; i++)
			((besfactory2__AttributedURIType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__AttributedURIType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__AttributedURIType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__AttributedURIType %p -> %p\n", q, p));
	*(besfactory2__AttributedURIType*)p = *(besfactory2__AttributedURIType*)q;
}

void besfactory2__RelatesToType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->besfactory2__RelatesToType::__item);
	soap_default_besfactory2__RelationshipTypeOpenEnum(soap, &this->besfactory2__RelatesToType::RelationshipType);
	this->besfactory2__RelatesToType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__RelatesToType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->besfactory2__RelatesToType::__item, SOAP_TYPE_besfactory_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->besfactory2__RelatesToType::__item);
	/* transient soap skipped */
}

int besfactory2__RelatesToType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__RelatesToType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__RelatesToType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__RelatesToType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__RelatesToType(struct soap *soap, const char *tag, int id, const besfactory2__RelatesToType *a, const char *type)
{
	if (!((besfactory2__RelatesToType*)a)->RelationshipType.empty())
		soap_set_attr(soap, "RelationshipType", ((besfactory2__RelatesToType*)a)->RelationshipType.c_str());
	if (((besfactory2__RelatesToType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__RelatesToType*)a)->__anyAttribute);
	return soap_out_xsd__anyURI(soap, tag, id, &(a->besfactory2__RelatesToType::__item), "besfactory2:RelatesToType");
}

void *besfactory2__RelatesToType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__RelatesToType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__RelatesToType * SOAP_FMAC4 soap_get_besfactory2__RelatesToType(struct soap *soap, besfactory2__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__RelatesToType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__RelatesToType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__RelatesToType * SOAP_FMAC4 soap_in_besfactory2__RelatesToType(struct soap *soap, const char *tag, besfactory2__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory2__RelatesToType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__RelatesToType, sizeof(besfactory2__RelatesToType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__RelatesToType)
			return (besfactory2__RelatesToType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "RelationshipType", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((besfactory2__RelatesToType*)a)->RelationshipType.assign(s);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__RelatesToType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &(a->besfactory2__RelatesToType::__item), "besfactory2:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory2__RelatesToType * SOAP_FMAC6 soap_new_besfactory2__RelatesToType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__RelatesToType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__RelatesToType(struct soap *soap, besfactory2__RelatesToType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__RelatesToType * SOAP_FMAC4 soap_instantiate_besfactory2__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__RelatesToType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__RelatesToType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__RelatesToType;
		if (size)
			*size = sizeof(besfactory2__RelatesToType);
		((besfactory2__RelatesToType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__RelatesToType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__RelatesToType);
		for (int i = 0; i < n; i++)
			((besfactory2__RelatesToType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__RelatesToType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__RelatesToType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__RelatesToType %p -> %p\n", q, p));
	*(besfactory2__RelatesToType*)p = *(besfactory2__RelatesToType*)q;
}

void besfactory2__MetadataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->besfactory2__MetadataType::__any);
	this->besfactory2__MetadataType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__MetadataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->besfactory2__MetadataType::__any);
	/* transient soap skipped */
}

int besfactory2__MetadataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__MetadataType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__MetadataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__MetadataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__MetadataType(struct soap *soap, const char *tag, int id, const besfactory2__MetadataType *a, const char *type)
{
	if (((besfactory2__MetadataType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__MetadataType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory2__MetadataType), "besfactory2:MetadataType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->besfactory2__MetadataType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory2__MetadataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__MetadataType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__MetadataType * SOAP_FMAC4 soap_get_besfactory2__MetadataType(struct soap *soap, besfactory2__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__MetadataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__MetadataType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__MetadataType * SOAP_FMAC4 soap_in_besfactory2__MetadataType(struct soap *soap, const char *tag, besfactory2__MetadataType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory2__MetadataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__MetadataType, sizeof(besfactory2__MetadataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__MetadataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory2__MetadataType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__MetadataType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->besfactory2__MetadataType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory2__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory2__MetadataType, 0, sizeof(besfactory2__MetadataType), 0, soap_copy_besfactory2__MetadataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory2__MetadataType * SOAP_FMAC6 soap_new_besfactory2__MetadataType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__MetadataType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__MetadataType(struct soap *soap, besfactory2__MetadataType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__MetadataType * SOAP_FMAC4 soap_instantiate_besfactory2__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__MetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__MetadataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__MetadataType;
		if (size)
			*size = sizeof(besfactory2__MetadataType);
		((besfactory2__MetadataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__MetadataType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__MetadataType);
		for (int i = 0; i < n; i++)
			((besfactory2__MetadataType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__MetadataType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__MetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__MetadataType %p -> %p\n", q, p));
	*(besfactory2__MetadataType*)p = *(besfactory2__MetadataType*)q;
}

void besfactory2__ReferenceParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->besfactory2__ReferenceParametersType::__any);
	this->besfactory2__ReferenceParametersType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__ReferenceParametersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->besfactory2__ReferenceParametersType::__any);
	/* transient soap skipped */
}

int besfactory2__ReferenceParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__ReferenceParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__ReferenceParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__ReferenceParametersType(struct soap *soap, const char *tag, int id, const besfactory2__ReferenceParametersType *a, const char *type)
{
	if (((besfactory2__ReferenceParametersType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__ReferenceParametersType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType), "besfactory2:ReferenceParametersType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->besfactory2__ReferenceParametersType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory2__ReferenceParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__ReferenceParametersType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__ReferenceParametersType * SOAP_FMAC4 soap_get_besfactory2__ReferenceParametersType(struct soap *soap, besfactory2__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__ReferenceParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__ReferenceParametersType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__ReferenceParametersType * SOAP_FMAC4 soap_in_besfactory2__ReferenceParametersType(struct soap *soap, const char *tag, besfactory2__ReferenceParametersType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory2__ReferenceParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType, sizeof(besfactory2__ReferenceParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory2__ReferenceParametersType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__ReferenceParametersType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->besfactory2__ReferenceParametersType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory2__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType, 0, sizeof(besfactory2__ReferenceParametersType), 0, soap_copy_besfactory2__ReferenceParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory2__ReferenceParametersType * SOAP_FMAC6 soap_new_besfactory2__ReferenceParametersType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__ReferenceParametersType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__ReferenceParametersType(struct soap *soap, besfactory2__ReferenceParametersType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__ReferenceParametersType * SOAP_FMAC4 soap_instantiate_besfactory2__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__ReferenceParametersType;
		if (size)
			*size = sizeof(besfactory2__ReferenceParametersType);
		((besfactory2__ReferenceParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__ReferenceParametersType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__ReferenceParametersType);
		for (int i = 0; i < n; i++)
			((besfactory2__ReferenceParametersType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__ReferenceParametersType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__ReferenceParametersType %p -> %p\n", q, p));
	*(besfactory2__ReferenceParametersType*)p = *(besfactory2__ReferenceParametersType*)q;
}

void besfactory2__EndpointReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory2__EndpointReferenceType::Address = NULL;
	this->besfactory2__EndpointReferenceType::ReferenceParameters = NULL;
	this->besfactory2__EndpointReferenceType::besfactory2__Metadata = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->besfactory2__EndpointReferenceType::__any);
	this->besfactory2__EndpointReferenceType::__anyAttribute = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory2__EndpointReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory2__AttributedURIType(soap, &this->besfactory2__EndpointReferenceType::Address);
	soap_serialize_PointerTobesfactory2__ReferenceParametersType(soap, &this->besfactory2__EndpointReferenceType::ReferenceParameters);
	soap_serialize_PointerTobesfactory2__MetadataType(soap, &this->besfactory2__EndpointReferenceType::besfactory2__Metadata);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->besfactory2__EndpointReferenceType::__any);
	/* transient soap skipped */
}

int besfactory2__EndpointReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory2__EndpointReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory2__EndpointReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory2__EndpointReferenceType(struct soap *soap, const char *tag, int id, const besfactory2__EndpointReferenceType *a, const char *type)
{
	if (((besfactory2__EndpointReferenceType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((besfactory2__EndpointReferenceType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType), "besfactory2:EndpointReferenceType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobesfactory2__AttributedURIType(soap, "besfactory2:Address", -1, &(a->besfactory2__EndpointReferenceType::Address), ""))
		return soap->error;
	if (soap_out_PointerTobesfactory2__ReferenceParametersType(soap, "besfactory2:ReferenceParameters", -1, &(a->besfactory2__EndpointReferenceType::ReferenceParameters), ""))
		return soap->error;
	if (soap_out_PointerTobesfactory2__MetadataType(soap, "besfactory2:Metadata", -1, &(a->besfactory2__EndpointReferenceType::besfactory2__Metadata), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->besfactory2__EndpointReferenceType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory2__EndpointReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory2__EndpointReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory2__EndpointReferenceType * SOAP_FMAC4 soap_get_besfactory2__EndpointReferenceType(struct soap *soap, besfactory2__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory2__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory2__EndpointReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory2__EndpointReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory2__EndpointReferenceType * SOAP_FMAC4 soap_in_besfactory2__EndpointReferenceType(struct soap *soap, const char *tag, besfactory2__EndpointReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory2__EndpointReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType, sizeof(besfactory2__EndpointReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory2__EndpointReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((besfactory2__EndpointReferenceType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_ReferenceParameters1 = 1;
	size_t soap_flag_besfactory2__Metadata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__AttributedURIType(soap, "besfactory2:Address", &(a->besfactory2__EndpointReferenceType::Address), "besfactory2:AttributedURIType"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_ReferenceParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__ReferenceParametersType(soap, "besfactory2:ReferenceParameters", &(a->besfactory2__EndpointReferenceType::ReferenceParameters), "besfactory2:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters1--;
					continue;
				}
			if (soap_flag_besfactory2__Metadata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__MetadataType(soap, "besfactory2:Metadata", &(a->besfactory2__EndpointReferenceType::besfactory2__Metadata), "besfactory2:MetadataType"))
				{	soap_flag_besfactory2__Metadata1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->besfactory2__EndpointReferenceType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory2__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType, 0, sizeof(besfactory2__EndpointReferenceType), 0, soap_copy_besfactory2__EndpointReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory2__EndpointReferenceType * SOAP_FMAC6 soap_new_besfactory2__EndpointReferenceType(struct soap *soap, int n)
{	return soap_instantiate_besfactory2__EndpointReferenceType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory2__EndpointReferenceType(struct soap *soap, besfactory2__EndpointReferenceType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory2__EndpointReferenceType * SOAP_FMAC4 soap_instantiate_besfactory2__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory2__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory2__EndpointReferenceType;
		if (size)
			*size = sizeof(besfactory2__EndpointReferenceType);
		((besfactory2__EndpointReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory2__EndpointReferenceType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory2__EndpointReferenceType);
		for (int i = 0; i < n; i++)
			((besfactory2__EndpointReferenceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory2__EndpointReferenceType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory2__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory2__EndpointReferenceType %p -> %p\n", q, p));
	*(besfactory2__EndpointReferenceType*)p = *(besfactory2__EndpointReferenceType*)q;
}

void besfactory__UnsupportedFeatureFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->besfactory__UnsupportedFeatureFaultType::Feature);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__UnsupportedFeatureFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->besfactory__UnsupportedFeatureFaultType::Feature);
	/* transient soap skipped */
}

int besfactory__UnsupportedFeatureFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__UnsupportedFeatureFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__UnsupportedFeatureFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, int id, const besfactory__UnsupportedFeatureFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType), "besfactory:UnsupportedFeatureFaultType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfstd__string(soap, "besfactory:Feature", -1, &(a->besfactory__UnsupportedFeatureFaultType::Feature), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__UnsupportedFeatureFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__UnsupportedFeatureFaultType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_get_besfactory__UnsupportedFeatureFaultType(struct soap *soap, besfactory__UnsupportedFeatureFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__UnsupportedFeatureFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__UnsupportedFeatureFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__UnsupportedFeatureFaultType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_in_besfactory__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, besfactory__UnsupportedFeatureFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__UnsupportedFeatureFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType, sizeof(besfactory__UnsupportedFeatureFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__UnsupportedFeatureFaultType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "besfactory:Feature", &(a->besfactory__UnsupportedFeatureFaultType::Feature), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__UnsupportedFeatureFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType, 0, sizeof(besfactory__UnsupportedFeatureFaultType), 0, soap_copy_besfactory__UnsupportedFeatureFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__UnsupportedFeatureFaultType * SOAP_FMAC6 soap_new_besfactory__UnsupportedFeatureFaultType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__UnsupportedFeatureFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__UnsupportedFeatureFaultType(struct soap *soap, besfactory__UnsupportedFeatureFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_instantiate_besfactory__UnsupportedFeatureFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__UnsupportedFeatureFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__UnsupportedFeatureFaultType;
		if (size)
			*size = sizeof(besfactory__UnsupportedFeatureFaultType);
		((besfactory__UnsupportedFeatureFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__UnsupportedFeatureFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__UnsupportedFeatureFaultType);
		for (int i = 0; i < n; i++)
			((besfactory__UnsupportedFeatureFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__UnsupportedFeatureFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__UnsupportedFeatureFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__UnsupportedFeatureFaultType %p -> %p\n", q, p));
	*(besfactory__UnsupportedFeatureFaultType*)p = *(besfactory__UnsupportedFeatureFaultType*)q;
}

void besfactory__UnsupportedJSDLVersionFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__UnsupportedJSDLVersionFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int besfactory__UnsupportedJSDLVersionFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__UnsupportedJSDLVersionFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__UnsupportedJSDLVersionFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__UnsupportedJSDLVersionFaultType(struct soap *soap, const char *tag, int id, const besfactory__UnsupportedJSDLVersionFaultType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "besfactory:UnsupportedJSDLVersionFaultType");
}

void *besfactory__UnsupportedJSDLVersionFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__UnsupportedJSDLVersionFaultType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__UnsupportedJSDLVersionFaultType * SOAP_FMAC4 soap_get_besfactory__UnsupportedJSDLVersionFaultType(struct soap *soap, besfactory__UnsupportedJSDLVersionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__UnsupportedJSDLVersionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__UnsupportedJSDLVersionFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__UnsupportedJSDLVersionFaultType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__UnsupportedJSDLVersionFaultType * SOAP_FMAC4 soap_in_besfactory__UnsupportedJSDLVersionFaultType(struct soap *soap, const char *tag, besfactory__UnsupportedJSDLVersionFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory__UnsupportedJSDLVersionFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType, sizeof(besfactory__UnsupportedJSDLVersionFaultType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType)
			return (besfactory__UnsupportedJSDLVersionFaultType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory__UnsupportedJSDLVersionFaultType * SOAP_FMAC6 soap_new_besfactory__UnsupportedJSDLVersionFaultType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__UnsupportedJSDLVersionFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__UnsupportedJSDLVersionFaultType(struct soap *soap, besfactory__UnsupportedJSDLVersionFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__UnsupportedJSDLVersionFaultType * SOAP_FMAC4 soap_instantiate_besfactory__UnsupportedJSDLVersionFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__UnsupportedJSDLVersionFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__UnsupportedJSDLVersionFaultType;
		if (size)
			*size = sizeof(besfactory__UnsupportedJSDLVersionFaultType);
		((besfactory__UnsupportedJSDLVersionFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__UnsupportedJSDLVersionFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__UnsupportedJSDLVersionFaultType);
		for (int i = 0; i < n; i++)
			((besfactory__UnsupportedJSDLVersionFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__UnsupportedJSDLVersionFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__UnsupportedJSDLVersionFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__UnsupportedJSDLVersionFaultType %p -> %p\n", q, p));
	*(besfactory__UnsupportedJSDLVersionFaultType*)p = *(besfactory__UnsupportedJSDLVersionFaultType*)q;
}

void besfactory__NotAcceptingNewActivitiesFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__NotAcceptingNewActivitiesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int besfactory__NotAcceptingNewActivitiesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__NotAcceptingNewActivitiesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__NotAcceptingNewActivitiesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, int id, const besfactory__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "besfactory:NotAcceptingNewActivitiesFaultType");
}

void *besfactory__NotAcceptingNewActivitiesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__NotAcceptingNewActivitiesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_get_besfactory__NotAcceptingNewActivitiesFaultType(struct soap *soap, besfactory__NotAcceptingNewActivitiesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__NotAcceptingNewActivitiesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__NotAcceptingNewActivitiesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__NotAcceptingNewActivitiesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_in_besfactory__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, besfactory__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory__NotAcceptingNewActivitiesFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType, sizeof(besfactory__NotAcceptingNewActivitiesFaultType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType)
			return (besfactory__NotAcceptingNewActivitiesFaultType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory__NotAcceptingNewActivitiesFaultType * SOAP_FMAC6 soap_new_besfactory__NotAcceptingNewActivitiesFaultType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__NotAcceptingNewActivitiesFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__NotAcceptingNewActivitiesFaultType(struct soap *soap, besfactory__NotAcceptingNewActivitiesFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_instantiate_besfactory__NotAcceptingNewActivitiesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__NotAcceptingNewActivitiesFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__NotAcceptingNewActivitiesFaultType;
		if (size)
			*size = sizeof(besfactory__NotAcceptingNewActivitiesFaultType);
		((besfactory__NotAcceptingNewActivitiesFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__NotAcceptingNewActivitiesFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__NotAcceptingNewActivitiesFaultType);
		for (int i = 0; i < n; i++)
			((besfactory__NotAcceptingNewActivitiesFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__NotAcceptingNewActivitiesFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__NotAcceptingNewActivitiesFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__NotAcceptingNewActivitiesFaultType %p -> %p\n", q, p));
	*(besfactory__NotAcceptingNewActivitiesFaultType*)p = *(besfactory__NotAcceptingNewActivitiesFaultType*)q;
}

void besfactory__GetFactoryAttributesDocumentResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__GetFactoryAttributesDocumentResponseType::besfactory__FactoryResourceAttributesDocument = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetFactoryAttributesDocumentResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, &this->besfactory__GetFactoryAttributesDocumentResponseType::besfactory__FactoryResourceAttributesDocument);
	/* transient soap skipped */
}

int besfactory__GetFactoryAttributesDocumentResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetFactoryAttributesDocumentResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetFactoryAttributesDocumentResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, int id, const besfactory__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType), "besfactory:GetFactoryAttributesDocumentResponseType"))
		return soap->error;
	/* transient soap skipped */
	if (a->besfactory__FactoryResourceAttributesDocument)
		soap_element_result(soap, "besfactory:FactoryResourceAttributesDocument");
	if (soap_out_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, "besfactory:FactoryResourceAttributesDocument", -1, &(a->besfactory__GetFactoryAttributesDocumentResponseType::besfactory__FactoryResourceAttributesDocument), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__GetFactoryAttributesDocumentResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetFactoryAttributesDocumentResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_get_besfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, besfactory__GetFactoryAttributesDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetFactoryAttributesDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetFactoryAttributesDocumentResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetFactoryAttributesDocumentResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_in_besfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, besfactory__GetFactoryAttributesDocumentResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__GetFactoryAttributesDocumentResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType, sizeof(besfactory__GetFactoryAttributesDocumentResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__GetFactoryAttributesDocumentResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_besfactory__FactoryResourceAttributesDocument1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_besfactory__FactoryResourceAttributesDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, "besfactory:FactoryResourceAttributesDocument", &(a->besfactory__GetFactoryAttributesDocumentResponseType::besfactory__FactoryResourceAttributesDocument), "besfactory:FactoryResourceAttributesDocumentType"))
				{	soap_flag_besfactory__FactoryResourceAttributesDocument1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			soap_check_result(soap, "besfactory:FactoryResourceAttributesDocument");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__GetFactoryAttributesDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType, 0, sizeof(besfactory__GetFactoryAttributesDocumentResponseType), 0, soap_copy_besfactory__GetFactoryAttributesDocumentResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_besfactory__FactoryResourceAttributesDocument1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__GetFactoryAttributesDocumentResponseType * SOAP_FMAC6 soap_new_besfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetFactoryAttributesDocumentResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, besfactory__GetFactoryAttributesDocumentResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentResponseType * SOAP_FMAC4 soap_instantiate_besfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetFactoryAttributesDocumentResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentResponseType;
		if (size)
			*size = sizeof(besfactory__GetFactoryAttributesDocumentResponseType);
		((besfactory__GetFactoryAttributesDocumentResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetFactoryAttributesDocumentResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__GetFactoryAttributesDocumentResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetFactoryAttributesDocumentResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetFactoryAttributesDocumentResponseType %p -> %p\n", q, p));
	*(besfactory__GetFactoryAttributesDocumentResponseType*)p = *(besfactory__GetFactoryAttributesDocumentResponseType*)q;
}

void besfactory__GetFactoryAttributesDocumentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetFactoryAttributesDocumentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int besfactory__GetFactoryAttributesDocumentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetFactoryAttributesDocumentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetFactoryAttributesDocumentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, int id, const besfactory__GetFactoryAttributesDocumentType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "besfactory:GetFactoryAttributesDocumentType");
}

void *besfactory__GetFactoryAttributesDocumentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetFactoryAttributesDocumentType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_get_besfactory__GetFactoryAttributesDocumentType(struct soap *soap, besfactory__GetFactoryAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetFactoryAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetFactoryAttributesDocumentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetFactoryAttributesDocumentType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_in_besfactory__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, besfactory__GetFactoryAttributesDocumentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (besfactory__GetFactoryAttributesDocumentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType, sizeof(besfactory__GetFactoryAttributesDocumentType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType)
			return (besfactory__GetFactoryAttributesDocumentType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 besfactory__GetFactoryAttributesDocumentType * SOAP_FMAC6 soap_new_besfactory__GetFactoryAttributesDocumentType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetFactoryAttributesDocumentType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetFactoryAttributesDocumentType(struct soap *soap, besfactory__GetFactoryAttributesDocumentType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentType * SOAP_FMAC4 soap_instantiate_besfactory__GetFactoryAttributesDocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetFactoryAttributesDocumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentType;
		if (size)
			*size = sizeof(besfactory__GetFactoryAttributesDocumentType);
		((besfactory__GetFactoryAttributesDocumentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetFactoryAttributesDocumentType);
		for (int i = 0; i < n; i++)
			((besfactory__GetFactoryAttributesDocumentType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetFactoryAttributesDocumentType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetFactoryAttributesDocumentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetFactoryAttributesDocumentType %p -> %p\n", q, p));
	*(besfactory__GetFactoryAttributesDocumentType*)p = *(besfactory__GetFactoryAttributesDocumentType*)q;
}

void besfactory__GetActivityDocumentsResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(soap, &this->besfactory__GetActivityDocumentsResponseType::Response);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetActivityDocumentsResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(soap, &this->besfactory__GetActivityDocumentsResponseType::Response);
	/* transient soap skipped */
}

int besfactory__GetActivityDocumentsResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetActivityDocumentsResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetActivityDocumentsResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, int id, const besfactory__GetActivityDocumentsResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType), "besfactory:GetActivityDocumentsResponseType"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "besfactory:Response");
	if (soap_out_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(soap, "besfactory:Response", -1, &(a->besfactory__GetActivityDocumentsResponseType::Response), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__GetActivityDocumentsResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetActivityDocumentsResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_get_besfactory__GetActivityDocumentsResponseType(struct soap *soap, besfactory__GetActivityDocumentsResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetActivityDocumentsResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetActivityDocumentsResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetActivityDocumentsResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_in_besfactory__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, besfactory__GetActivityDocumentsResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__GetActivityDocumentsResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType, sizeof(besfactory__GetActivityDocumentsResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__GetActivityDocumentsResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(soap, "besfactory:Response", &(a->besfactory__GetActivityDocumentsResponseType::Response), "besfactory:GetActivityDocumentResponseType"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			soap_check_result(soap, "besfactory:Response");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__GetActivityDocumentsResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType, 0, sizeof(besfactory__GetActivityDocumentsResponseType), 0, soap_copy_besfactory__GetActivityDocumentsResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__GetActivityDocumentsResponseType * SOAP_FMAC6 soap_new_besfactory__GetActivityDocumentsResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetActivityDocumentsResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetActivityDocumentsResponseType(struct soap *soap, besfactory__GetActivityDocumentsResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsResponseType * SOAP_FMAC4 soap_instantiate_besfactory__GetActivityDocumentsResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetActivityDocumentsResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetActivityDocumentsResponseType;
		if (size)
			*size = sizeof(besfactory__GetActivityDocumentsResponseType);
		((besfactory__GetActivityDocumentsResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetActivityDocumentsResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetActivityDocumentsResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__GetActivityDocumentsResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetActivityDocumentsResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetActivityDocumentsResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetActivityDocumentsResponseType %p -> %p\n", q, p));
	*(besfactory__GetActivityDocumentsResponseType*)p = *(besfactory__GetActivityDocumentsResponseType*)q;
}

void besfactory__GetActivityDocumentsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__GetActivityDocumentsType::besfactory__ActivityIdentifier);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetActivityDocumentsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__GetActivityDocumentsType::besfactory__ActivityIdentifier);
	/* transient soap skipped */
}

int besfactory__GetActivityDocumentsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetActivityDocumentsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetActivityDocumentsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetActivityDocumentsType(struct soap *soap, const char *tag, int id, const besfactory__GetActivityDocumentsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType), "besfactory:GetActivityDocumentsType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", -1, &(a->besfactory__GetActivityDocumentsType::besfactory__ActivityIdentifier), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__GetActivityDocumentsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetActivityDocumentsType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsType * SOAP_FMAC4 soap_get_besfactory__GetActivityDocumentsType(struct soap *soap, besfactory__GetActivityDocumentsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetActivityDocumentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetActivityDocumentsType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetActivityDocumentsType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsType * SOAP_FMAC4 soap_in_besfactory__GetActivityDocumentsType(struct soap *soap, const char *tag, besfactory__GetActivityDocumentsType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__GetActivityDocumentsType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType, sizeof(besfactory__GetActivityDocumentsType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__GetActivityDocumentsType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", &(a->besfactory__GetActivityDocumentsType::besfactory__ActivityIdentifier), "besfactory2:EndpointReferenceType"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__GetActivityDocumentsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType, 0, sizeof(besfactory__GetActivityDocumentsType), 0, soap_copy_besfactory__GetActivityDocumentsType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__GetActivityDocumentsType * SOAP_FMAC6 soap_new_besfactory__GetActivityDocumentsType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetActivityDocumentsType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetActivityDocumentsType(struct soap *soap, besfactory__GetActivityDocumentsType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsType * SOAP_FMAC4 soap_instantiate_besfactory__GetActivityDocumentsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetActivityDocumentsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetActivityDocumentsType;
		if (size)
			*size = sizeof(besfactory__GetActivityDocumentsType);
		((besfactory__GetActivityDocumentsType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetActivityDocumentsType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetActivityDocumentsType);
		for (int i = 0; i < n; i++)
			((besfactory__GetActivityDocumentsType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetActivityDocumentsType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetActivityDocumentsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetActivityDocumentsType %p -> %p\n", q, p));
	*(besfactory__GetActivityDocumentsType*)p = *(besfactory__GetActivityDocumentsType*)q;
}

void besfactory__TerminateActivitiesResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(soap, &this->besfactory__TerminateActivitiesResponseType::Response);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__TerminateActivitiesResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(soap, &this->besfactory__TerminateActivitiesResponseType::Response);
	/* transient soap skipped */
}

int besfactory__TerminateActivitiesResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__TerminateActivitiesResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__TerminateActivitiesResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__TerminateActivitiesResponseType(struct soap *soap, const char *tag, int id, const besfactory__TerminateActivitiesResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType), "besfactory:TerminateActivitiesResponseType"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "besfactory:Response");
	if (soap_out_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(soap, "besfactory:Response", -1, &(a->besfactory__TerminateActivitiesResponseType::Response), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__TerminateActivitiesResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__TerminateActivitiesResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__TerminateActivitiesResponseType * SOAP_FMAC4 soap_get_besfactory__TerminateActivitiesResponseType(struct soap *soap, besfactory__TerminateActivitiesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__TerminateActivitiesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__TerminateActivitiesResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__TerminateActivitiesResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__TerminateActivitiesResponseType * SOAP_FMAC4 soap_in_besfactory__TerminateActivitiesResponseType(struct soap *soap, const char *tag, besfactory__TerminateActivitiesResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__TerminateActivitiesResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType, sizeof(besfactory__TerminateActivitiesResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__TerminateActivitiesResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(soap, "besfactory:Response", &(a->besfactory__TerminateActivitiesResponseType::Response), "besfactory:TerminateActivityResponseType"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			soap_check_result(soap, "besfactory:Response");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__TerminateActivitiesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType, 0, sizeof(besfactory__TerminateActivitiesResponseType), 0, soap_copy_besfactory__TerminateActivitiesResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__TerminateActivitiesResponseType * SOAP_FMAC6 soap_new_besfactory__TerminateActivitiesResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__TerminateActivitiesResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__TerminateActivitiesResponseType(struct soap *soap, besfactory__TerminateActivitiesResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__TerminateActivitiesResponseType * SOAP_FMAC4 soap_instantiate_besfactory__TerminateActivitiesResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__TerminateActivitiesResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__TerminateActivitiesResponseType;
		if (size)
			*size = sizeof(besfactory__TerminateActivitiesResponseType);
		((besfactory__TerminateActivitiesResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__TerminateActivitiesResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__TerminateActivitiesResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__TerminateActivitiesResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__TerminateActivitiesResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__TerminateActivitiesResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__TerminateActivitiesResponseType %p -> %p\n", q, p));
	*(besfactory__TerminateActivitiesResponseType*)p = *(besfactory__TerminateActivitiesResponseType*)q;
}

void besfactory__TerminateActivitiesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__TerminateActivitiesType::besfactory__ActivityIdentifier);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__TerminateActivitiesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__TerminateActivitiesType::besfactory__ActivityIdentifier);
	/* transient soap skipped */
}

int besfactory__TerminateActivitiesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__TerminateActivitiesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__TerminateActivitiesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__TerminateActivitiesType(struct soap *soap, const char *tag, int id, const besfactory__TerminateActivitiesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType), "besfactory:TerminateActivitiesType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", -1, &(a->besfactory__TerminateActivitiesType::besfactory__ActivityIdentifier), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__TerminateActivitiesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__TerminateActivitiesType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__TerminateActivitiesType * SOAP_FMAC4 soap_get_besfactory__TerminateActivitiesType(struct soap *soap, besfactory__TerminateActivitiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__TerminateActivitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__TerminateActivitiesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__TerminateActivitiesType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__TerminateActivitiesType * SOAP_FMAC4 soap_in_besfactory__TerminateActivitiesType(struct soap *soap, const char *tag, besfactory__TerminateActivitiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__TerminateActivitiesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType, sizeof(besfactory__TerminateActivitiesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__TerminateActivitiesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", &(a->besfactory__TerminateActivitiesType::besfactory__ActivityIdentifier), "besfactory2:EndpointReferenceType"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__TerminateActivitiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType, 0, sizeof(besfactory__TerminateActivitiesType), 0, soap_copy_besfactory__TerminateActivitiesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__TerminateActivitiesType * SOAP_FMAC6 soap_new_besfactory__TerminateActivitiesType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__TerminateActivitiesType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__TerminateActivitiesType(struct soap *soap, besfactory__TerminateActivitiesType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__TerminateActivitiesType * SOAP_FMAC4 soap_instantiate_besfactory__TerminateActivitiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__TerminateActivitiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__TerminateActivitiesType;
		if (size)
			*size = sizeof(besfactory__TerminateActivitiesType);
		((besfactory__TerminateActivitiesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__TerminateActivitiesType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__TerminateActivitiesType);
		for (int i = 0; i < n; i++)
			((besfactory__TerminateActivitiesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__TerminateActivitiesType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__TerminateActivitiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__TerminateActivitiesType %p -> %p\n", q, p));
	*(besfactory__TerminateActivitiesType*)p = *(besfactory__TerminateActivitiesType*)q;
}

void besfactory__GetActivityStatusesResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(soap, &this->besfactory__GetActivityStatusesResponseType::Response);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetActivityStatusesResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(soap, &this->besfactory__GetActivityStatusesResponseType::Response);
	/* transient soap skipped */
}

int besfactory__GetActivityStatusesResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetActivityStatusesResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetActivityStatusesResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetActivityStatusesResponseType(struct soap *soap, const char *tag, int id, const besfactory__GetActivityStatusesResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType), "besfactory:GetActivityStatusesResponseType"))
		return soap->error;
	/* transient soap skipped */
	soap_element_result(soap, "besfactory:Response");
	if (soap_out_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(soap, "besfactory:Response", -1, &(a->besfactory__GetActivityStatusesResponseType::Response), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__GetActivityStatusesResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetActivityStatusesResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusesResponseType * SOAP_FMAC4 soap_get_besfactory__GetActivityStatusesResponseType(struct soap *soap, besfactory__GetActivityStatusesResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetActivityStatusesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetActivityStatusesResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetActivityStatusesResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusesResponseType * SOAP_FMAC4 soap_in_besfactory__GetActivityStatusesResponseType(struct soap *soap, const char *tag, besfactory__GetActivityStatusesResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__GetActivityStatusesResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType, sizeof(besfactory__GetActivityStatusesResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__GetActivityStatusesResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(soap, "besfactory:Response", &(a->besfactory__GetActivityStatusesResponseType::Response), "besfactory:GetActivityStatusResponseType"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			soap_check_result(soap, "besfactory:Response");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__GetActivityStatusesResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType, 0, sizeof(besfactory__GetActivityStatusesResponseType), 0, soap_copy_besfactory__GetActivityStatusesResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__GetActivityStatusesResponseType * SOAP_FMAC6 soap_new_besfactory__GetActivityStatusesResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetActivityStatusesResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetActivityStatusesResponseType(struct soap *soap, besfactory__GetActivityStatusesResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetActivityStatusesResponseType * SOAP_FMAC4 soap_instantiate_besfactory__GetActivityStatusesResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetActivityStatusesResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetActivityStatusesResponseType;
		if (size)
			*size = sizeof(besfactory__GetActivityStatusesResponseType);
		((besfactory__GetActivityStatusesResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetActivityStatusesResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetActivityStatusesResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__GetActivityStatusesResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetActivityStatusesResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetActivityStatusesResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetActivityStatusesResponseType %p -> %p\n", q, p));
	*(besfactory__GetActivityStatusesResponseType*)p = *(besfactory__GetActivityStatusesResponseType*)q;
}

void besfactory__GetActivityStatusesType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__GetActivityStatusesType::ActivityIdentifier);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetActivityStatusesType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__GetActivityStatusesType::ActivityIdentifier);
	/* transient soap skipped */
}

int besfactory__GetActivityStatusesType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetActivityStatusesType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetActivityStatusesType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetActivityStatusesType(struct soap *soap, const char *tag, int id, const besfactory__GetActivityStatusesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType), "besfactory:GetActivityStatusesType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", -1, &(a->besfactory__GetActivityStatusesType::ActivityIdentifier), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__GetActivityStatusesType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetActivityStatusesType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusesType * SOAP_FMAC4 soap_get_besfactory__GetActivityStatusesType(struct soap *soap, besfactory__GetActivityStatusesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetActivityStatusesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetActivityStatusesType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetActivityStatusesType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusesType * SOAP_FMAC4 soap_in_besfactory__GetActivityStatusesType(struct soap *soap, const char *tag, besfactory__GetActivityStatusesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__GetActivityStatusesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType, sizeof(besfactory__GetActivityStatusesType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__GetActivityStatusesType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", &(a->besfactory__GetActivityStatusesType::ActivityIdentifier), "besfactory2:EndpointReferenceType"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__GetActivityStatusesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType, 0, sizeof(besfactory__GetActivityStatusesType), 0, soap_copy_besfactory__GetActivityStatusesType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__GetActivityStatusesType * SOAP_FMAC6 soap_new_besfactory__GetActivityStatusesType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetActivityStatusesType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetActivityStatusesType(struct soap *soap, besfactory__GetActivityStatusesType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetActivityStatusesType * SOAP_FMAC4 soap_instantiate_besfactory__GetActivityStatusesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetActivityStatusesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetActivityStatusesType;
		if (size)
			*size = sizeof(besfactory__GetActivityStatusesType);
		((besfactory__GetActivityStatusesType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetActivityStatusesType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetActivityStatusesType);
		for (int i = 0; i < n; i++)
			((besfactory__GetActivityStatusesType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetActivityStatusesType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetActivityStatusesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetActivityStatusesType %p -> %p\n", q, p));
	*(besfactory__GetActivityStatusesType*)p = *(besfactory__GetActivityStatusesType*)q;
}

void besfactory__CreateActivityResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__CreateActivityResponseType::besfactory__ActivityIdentifier = NULL;
	this->besfactory__CreateActivityResponseType::besfactory__ActivityDocument = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__CreateActivityResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__CreateActivityResponseType::besfactory__ActivityIdentifier);
	soap_serialize_PointerTobesfactory__ActivityDocumentType(soap, &this->besfactory__CreateActivityResponseType::besfactory__ActivityDocument);
	/* transient soap skipped */
}

int besfactory__CreateActivityResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__CreateActivityResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__CreateActivityResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__CreateActivityResponseType(struct soap *soap, const char *tag, int id, const besfactory__CreateActivityResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType), "besfactory:CreateActivityResponseType"))
		return soap->error;
	/* transient soap skipped */
	if (a->besfactory__ActivityIdentifier)
		soap_element_result(soap, "besfactory:ActivityIdentifier");
	if (soap_out_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", -1, &(a->besfactory__CreateActivityResponseType::besfactory__ActivityIdentifier), ""))
		return soap->error;
	if (soap_out_PointerTobesfactory__ActivityDocumentType(soap, "besfactory:ActivityDocument", -1, &(a->besfactory__CreateActivityResponseType::besfactory__ActivityDocument), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__CreateActivityResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__CreateActivityResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__CreateActivityResponseType * SOAP_FMAC4 soap_get_besfactory__CreateActivityResponseType(struct soap *soap, besfactory__CreateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__CreateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__CreateActivityResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__CreateActivityResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__CreateActivityResponseType * SOAP_FMAC4 soap_in_besfactory__CreateActivityResponseType(struct soap *soap, const char *tag, besfactory__CreateActivityResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__CreateActivityResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType, sizeof(besfactory__CreateActivityResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__CreateActivityResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_besfactory__ActivityIdentifier1 = 1;
	size_t soap_flag_besfactory__ActivityDocument1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_besfactory__ActivityIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", &(a->besfactory__CreateActivityResponseType::besfactory__ActivityIdentifier), "besfactory2:EndpointReferenceType"))
				{	soap_flag_besfactory__ActivityIdentifier1--;
					continue;
				}
			if (soap_flag_besfactory__ActivityDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__ActivityDocumentType(soap, "besfactory:ActivityDocument", &(a->besfactory__CreateActivityResponseType::besfactory__ActivityDocument), "besfactory:ActivityDocumentType"))
				{	soap_flag_besfactory__ActivityDocument1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			soap_check_result(soap, "besfactory:ActivityIdentifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__CreateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType, 0, sizeof(besfactory__CreateActivityResponseType), 0, soap_copy_besfactory__CreateActivityResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_besfactory__ActivityIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__CreateActivityResponseType * SOAP_FMAC6 soap_new_besfactory__CreateActivityResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__CreateActivityResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__CreateActivityResponseType(struct soap *soap, besfactory__CreateActivityResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__CreateActivityResponseType * SOAP_FMAC4 soap_instantiate_besfactory__CreateActivityResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__CreateActivityResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__CreateActivityResponseType;
		if (size)
			*size = sizeof(besfactory__CreateActivityResponseType);
		((besfactory__CreateActivityResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__CreateActivityResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__CreateActivityResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__CreateActivityResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__CreateActivityResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__CreateActivityResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__CreateActivityResponseType %p -> %p\n", q, p));
	*(besfactory__CreateActivityResponseType*)p = *(besfactory__CreateActivityResponseType*)q;
}

void besfactory__CreateActivityType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__CreateActivityType::besfactory__ActivityDocument = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__CreateActivityType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory__ActivityDocumentType(soap, &this->besfactory__CreateActivityType::besfactory__ActivityDocument);
	/* transient soap skipped */
}

int besfactory__CreateActivityType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__CreateActivityType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__CreateActivityType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__CreateActivityType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__CreateActivityType(struct soap *soap, const char *tag, int id, const besfactory__CreateActivityType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__CreateActivityType), "besfactory:CreateActivityType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobesfactory__ActivityDocumentType(soap, "besfactory:ActivityDocument", -1, &(a->besfactory__CreateActivityType::besfactory__ActivityDocument), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__CreateActivityType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__CreateActivityType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__CreateActivityType * SOAP_FMAC4 soap_get_besfactory__CreateActivityType(struct soap *soap, besfactory__CreateActivityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__CreateActivityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__CreateActivityType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__CreateActivityType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__CreateActivityType * SOAP_FMAC4 soap_in_besfactory__CreateActivityType(struct soap *soap, const char *tag, besfactory__CreateActivityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__CreateActivityType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__CreateActivityType, sizeof(besfactory__CreateActivityType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__CreateActivityType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__CreateActivityType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_besfactory__ActivityDocument1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_besfactory__ActivityDocument1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__ActivityDocumentType(soap, "besfactory:ActivityDocument", &(a->besfactory__CreateActivityType::besfactory__ActivityDocument), "besfactory:ActivityDocumentType"))
				{	soap_flag_besfactory__ActivityDocument1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__CreateActivityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__CreateActivityType, 0, sizeof(besfactory__CreateActivityType), 0, soap_copy_besfactory__CreateActivityType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_besfactory__ActivityDocument1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__CreateActivityType * SOAP_FMAC6 soap_new_besfactory__CreateActivityType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__CreateActivityType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__CreateActivityType(struct soap *soap, besfactory__CreateActivityType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__CreateActivityType * SOAP_FMAC4 soap_instantiate_besfactory__CreateActivityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__CreateActivityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__CreateActivityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__CreateActivityType;
		if (size)
			*size = sizeof(besfactory__CreateActivityType);
		((besfactory__CreateActivityType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__CreateActivityType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__CreateActivityType);
		for (int i = 0; i < n; i++)
			((besfactory__CreateActivityType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__CreateActivityType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__CreateActivityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__CreateActivityType %p -> %p\n", q, p));
	*(besfactory__CreateActivityType*)p = *(besfactory__CreateActivityType*)q;
}

void besfactory__TerminateActivityResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__TerminateActivityResponseType::besfactory__ActivityIdentifier = NULL;
	soap_default_bool(soap, &this->besfactory__TerminateActivityResponseType::Cancelled);
	this->besfactory__TerminateActivityResponseType::Fault = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__TerminateActivityResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__TerminateActivityResponseType::besfactory__ActivityIdentifier);
	soap_embedded(soap, &this->besfactory__TerminateActivityResponseType::Cancelled, SOAP_TYPE_besfactory_bool);
	soap_serialize_PointerToxsd__anyType(soap, &this->besfactory__TerminateActivityResponseType::Fault);
	/* transient soap skipped */
}

int besfactory__TerminateActivityResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__TerminateActivityResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__TerminateActivityResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__TerminateActivityResponseType(struct soap *soap, const char *tag, int id, const besfactory__TerminateActivityResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType), "besfactory:TerminateActivityResponseType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", -1, &(a->besfactory__TerminateActivityResponseType::besfactory__ActivityIdentifier), ""))
		return soap->error;
	if (soap_out_bool(soap, "besfactory:Cancelled", -1, &(a->besfactory__TerminateActivityResponseType::Cancelled), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "besfactory:Fault", -1, &(a->besfactory__TerminateActivityResponseType::Fault), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__TerminateActivityResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__TerminateActivityResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__TerminateActivityResponseType * SOAP_FMAC4 soap_get_besfactory__TerminateActivityResponseType(struct soap *soap, besfactory__TerminateActivityResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__TerminateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__TerminateActivityResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__TerminateActivityResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__TerminateActivityResponseType * SOAP_FMAC4 soap_in_besfactory__TerminateActivityResponseType(struct soap *soap, const char *tag, besfactory__TerminateActivityResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__TerminateActivityResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType, sizeof(besfactory__TerminateActivityResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__TerminateActivityResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_besfactory__ActivityIdentifier1 = 1;
	size_t soap_flag_Cancelled1 = 1;
	size_t soap_flag_Fault1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_besfactory__ActivityIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", &(a->besfactory__TerminateActivityResponseType::besfactory__ActivityIdentifier), "besfactory2:EndpointReferenceType"))
				{	soap_flag_besfactory__ActivityIdentifier1--;
					continue;
				}
			if (soap_flag_Cancelled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "besfactory:Cancelled", &(a->besfactory__TerminateActivityResponseType::Cancelled), "xsd:boolean"))
				{	soap_flag_Cancelled1--;
					continue;
				}
			if (soap_flag_Fault1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "besfactory:Fault", &(a->besfactory__TerminateActivityResponseType::Fault), "xsd:anyType"))
				{	soap_flag_Fault1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__TerminateActivityResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType, 0, sizeof(besfactory__TerminateActivityResponseType), 0, soap_copy_besfactory__TerminateActivityResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_besfactory__ActivityIdentifier1 > 0 || soap_flag_Cancelled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__TerminateActivityResponseType * SOAP_FMAC6 soap_new_besfactory__TerminateActivityResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__TerminateActivityResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__TerminateActivityResponseType(struct soap *soap, besfactory__TerminateActivityResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__TerminateActivityResponseType * SOAP_FMAC4 soap_instantiate_besfactory__TerminateActivityResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__TerminateActivityResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__TerminateActivityResponseType;
		if (size)
			*size = sizeof(besfactory__TerminateActivityResponseType);
		((besfactory__TerminateActivityResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__TerminateActivityResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__TerminateActivityResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__TerminateActivityResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__TerminateActivityResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__TerminateActivityResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__TerminateActivityResponseType %p -> %p\n", q, p));
	*(besfactory__TerminateActivityResponseType*)p = *(besfactory__TerminateActivityResponseType*)q;
}

void besfactory__GetActivityDocumentResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__GetActivityDocumentResponseType::besfactory__ActivityIdentifier = NULL;
	this->besfactory__GetActivityDocumentResponseType::jsdl__JobDefinition = NULL;
	this->besfactory__GetActivityDocumentResponseType::Fault = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetActivityDocumentResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__GetActivityDocumentResponseType::besfactory__ActivityIdentifier);
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &this->besfactory__GetActivityDocumentResponseType::jsdl__JobDefinition);
	soap_serialize_PointerToxsd__anyType(soap, &this->besfactory__GetActivityDocumentResponseType::Fault);
	/* transient soap skipped */
}

int besfactory__GetActivityDocumentResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetActivityDocumentResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetActivityDocumentResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetActivityDocumentResponseType(struct soap *soap, const char *tag, int id, const besfactory__GetActivityDocumentResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType), "besfactory:GetActivityDocumentResponseType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", -1, &(a->besfactory__GetActivityDocumentResponseType::besfactory__ActivityIdentifier), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", -1, &(a->besfactory__GetActivityDocumentResponseType::jsdl__JobDefinition), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "besfactory:Fault", -1, &(a->besfactory__GetActivityDocumentResponseType::Fault), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__GetActivityDocumentResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetActivityDocumentResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentResponseType * SOAP_FMAC4 soap_get_besfactory__GetActivityDocumentResponseType(struct soap *soap, besfactory__GetActivityDocumentResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetActivityDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetActivityDocumentResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetActivityDocumentResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentResponseType * SOAP_FMAC4 soap_in_besfactory__GetActivityDocumentResponseType(struct soap *soap, const char *tag, besfactory__GetActivityDocumentResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__GetActivityDocumentResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType, sizeof(besfactory__GetActivityDocumentResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__GetActivityDocumentResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_besfactory__ActivityIdentifier1 = 1;
	size_t soap_flag_jsdl__JobDefinition1 = 1;
	size_t soap_flag_Fault1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_besfactory__ActivityIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", &(a->besfactory__GetActivityDocumentResponseType::besfactory__ActivityIdentifier), "besfactory2:EndpointReferenceType"))
				{	soap_flag_besfactory__ActivityIdentifier1--;
					continue;
				}
			if (soap_flag_jsdl__JobDefinition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", &(a->besfactory__GetActivityDocumentResponseType::jsdl__JobDefinition), "jsdl:JobDefinition_Type"))
				{	soap_flag_jsdl__JobDefinition1--;
					continue;
				}
			if (soap_flag_Fault1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "besfactory:Fault", &(a->besfactory__GetActivityDocumentResponseType::Fault), "xsd:anyType"))
				{	soap_flag_Fault1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__GetActivityDocumentResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType, 0, sizeof(besfactory__GetActivityDocumentResponseType), 0, soap_copy_besfactory__GetActivityDocumentResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_besfactory__ActivityIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__GetActivityDocumentResponseType * SOAP_FMAC6 soap_new_besfactory__GetActivityDocumentResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetActivityDocumentResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetActivityDocumentResponseType(struct soap *soap, besfactory__GetActivityDocumentResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetActivityDocumentResponseType * SOAP_FMAC4 soap_instantiate_besfactory__GetActivityDocumentResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetActivityDocumentResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetActivityDocumentResponseType;
		if (size)
			*size = sizeof(besfactory__GetActivityDocumentResponseType);
		((besfactory__GetActivityDocumentResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetActivityDocumentResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetActivityDocumentResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__GetActivityDocumentResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetActivityDocumentResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetActivityDocumentResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetActivityDocumentResponseType %p -> %p\n", q, p));
	*(besfactory__GetActivityDocumentResponseType*)p = *(besfactory__GetActivityDocumentResponseType*)q;
}

void besfactory__GetActivityStatusResponseType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__GetActivityStatusResponseType::besfactory__ActivityIdentifier = NULL;
	this->besfactory__GetActivityStatusResponseType::besfactory__ActivityStatus = NULL;
	this->besfactory__GetActivityStatusResponseType::Fault = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__GetActivityStatusResponseType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__GetActivityStatusResponseType::besfactory__ActivityIdentifier);
	soap_serialize_PointerTobesfactory__ActivityStatusType(soap, &this->besfactory__GetActivityStatusResponseType::besfactory__ActivityStatus);
	soap_serialize_PointerToxsd__anyType(soap, &this->besfactory__GetActivityStatusResponseType::Fault);
	/* transient soap skipped */
}

int besfactory__GetActivityStatusResponseType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__GetActivityStatusResponseType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__GetActivityStatusResponseType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__GetActivityStatusResponseType(struct soap *soap, const char *tag, int id, const besfactory__GetActivityStatusResponseType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType), "besfactory:GetActivityStatusResponseType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", -1, &(a->besfactory__GetActivityStatusResponseType::besfactory__ActivityIdentifier), ""))
		return soap->error;
	if (soap_out_PointerTobesfactory__ActivityStatusType(soap, "besfactory:ActivityStatus", -1, &(a->besfactory__GetActivityStatusResponseType::besfactory__ActivityStatus), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "besfactory:Fault", -1, &(a->besfactory__GetActivityStatusResponseType::Fault), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__GetActivityStatusResponseType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__GetActivityStatusResponseType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusResponseType * SOAP_FMAC4 soap_get_besfactory__GetActivityStatusResponseType(struct soap *soap, besfactory__GetActivityStatusResponseType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__GetActivityStatusResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__GetActivityStatusResponseType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__GetActivityStatusResponseType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusResponseType * SOAP_FMAC4 soap_in_besfactory__GetActivityStatusResponseType(struct soap *soap, const char *tag, besfactory__GetActivityStatusResponseType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__GetActivityStatusResponseType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType, sizeof(besfactory__GetActivityStatusResponseType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__GetActivityStatusResponseType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_besfactory__ActivityIdentifier1 = 1;
	size_t soap_flag_besfactory__ActivityStatus1 = 1;
	size_t soap_flag_Fault1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_besfactory__ActivityIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityIdentifier", &(a->besfactory__GetActivityStatusResponseType::besfactory__ActivityIdentifier), "besfactory2:EndpointReferenceType"))
				{	soap_flag_besfactory__ActivityIdentifier1--;
					continue;
				}
			if (soap_flag_besfactory__ActivityStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__ActivityStatusType(soap, "besfactory:ActivityStatus", &(a->besfactory__GetActivityStatusResponseType::besfactory__ActivityStatus), "besfactory:ActivityStatusType"))
				{	soap_flag_besfactory__ActivityStatus1--;
					continue;
				}
			if (soap_flag_Fault1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "besfactory:Fault", &(a->besfactory__GetActivityStatusResponseType::Fault), "xsd:anyType"))
				{	soap_flag_Fault1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__GetActivityStatusResponseType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType, 0, sizeof(besfactory__GetActivityStatusResponseType), 0, soap_copy_besfactory__GetActivityStatusResponseType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_besfactory__ActivityIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__GetActivityStatusResponseType * SOAP_FMAC6 soap_new_besfactory__GetActivityStatusResponseType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__GetActivityStatusResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__GetActivityStatusResponseType(struct soap *soap, besfactory__GetActivityStatusResponseType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__GetActivityStatusResponseType * SOAP_FMAC4 soap_instantiate_besfactory__GetActivityStatusResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__GetActivityStatusResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__GetActivityStatusResponseType;
		if (size)
			*size = sizeof(besfactory__GetActivityStatusResponseType);
		((besfactory__GetActivityStatusResponseType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__GetActivityStatusResponseType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__GetActivityStatusResponseType);
		for (int i = 0; i < n; i++)
			((besfactory__GetActivityStatusResponseType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__GetActivityStatusResponseType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__GetActivityStatusResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__GetActivityStatusResponseType %p -> %p\n", q, p));
	*(besfactory__GetActivityStatusResponseType*)p = *(besfactory__GetActivityStatusResponseType*)q;
}

void besfactory__ActivityStatusType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__ActivityStatusType::__union_ActivityStatusType = 0;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__ActivityStatusType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__besfactory__union_ActivityStatusType(soap, this->besfactory__ActivityStatusType::__union_ActivityStatusType, &this->besfactory__ActivityStatusType::union_ActivityStatusType);
	/* transient soap skipped */
}

int besfactory__ActivityStatusType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__ActivityStatusType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__ActivityStatusType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__ActivityStatusType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__ActivityStatusType(struct soap *soap, const char *tag, int id, const besfactory__ActivityStatusType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__ActivityStatusType), "besfactory:ActivityStatusType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out__besfactory__union_ActivityStatusType(soap, a->besfactory__ActivityStatusType::__union_ActivityStatusType, &a->besfactory__ActivityStatusType::union_ActivityStatusType))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__ActivityStatusType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__ActivityStatusType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__ActivityStatusType * SOAP_FMAC4 soap_get_besfactory__ActivityStatusType(struct soap *soap, besfactory__ActivityStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__ActivityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__ActivityStatusType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__ActivityStatusType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__ActivityStatusType * SOAP_FMAC4 soap_in_besfactory__ActivityStatusType(struct soap *soap, const char *tag, besfactory__ActivityStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__ActivityStatusType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__ActivityStatusType, sizeof(besfactory__ActivityStatusType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__ActivityStatusType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__ActivityStatusType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
			/* transient soap skipped */
		if (!soap_in__besfactory__union_ActivityStatusType(soap, &a->__union_ActivityStatusType, &a->union_ActivityStatusType))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__ActivityStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__ActivityStatusType, 0, sizeof(besfactory__ActivityStatusType), 0, soap_copy_besfactory__ActivityStatusType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__ActivityStatusType * SOAP_FMAC6 soap_new_besfactory__ActivityStatusType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__ActivityStatusType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__ActivityStatusType(struct soap *soap, besfactory__ActivityStatusType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__ActivityStatusType * SOAP_FMAC4 soap_instantiate_besfactory__ActivityStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__ActivityStatusType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__ActivityStatusType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__ActivityStatusType;
		if (size)
			*size = sizeof(besfactory__ActivityStatusType);
		((besfactory__ActivityStatusType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__ActivityStatusType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__ActivityStatusType);
		for (int i = 0; i < n; i++)
			((besfactory__ActivityStatusType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__ActivityStatusType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__ActivityStatusType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__ActivityStatusType %p -> %p\n", q, p));
	*(besfactory__ActivityStatusType*)p = *(besfactory__ActivityStatusType*)q;
}

void besfactory__ActivityStateType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->besfactory__ActivityStateType::__any);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__ActivityStateType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->besfactory__ActivityStateType::__any);
	/* transient soap skipped */
}

int besfactory__ActivityStateType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__ActivityStateType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__ActivityStateType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__ActivityStateType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__ActivityStateType(struct soap *soap, const char *tag, int id, const besfactory__ActivityStateType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__ActivityStateType), "besfactory:ActivityStateType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->besfactory__ActivityStateType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__ActivityStateType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__ActivityStateType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__ActivityStateType * SOAP_FMAC4 soap_get_besfactory__ActivityStateType(struct soap *soap, besfactory__ActivityStateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__ActivityStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__ActivityStateType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__ActivityStateType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__ActivityStateType * SOAP_FMAC4 soap_in_besfactory__ActivityStateType(struct soap *soap, const char *tag, besfactory__ActivityStateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__ActivityStateType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__ActivityStateType, sizeof(besfactory__ActivityStateType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__ActivityStateType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__ActivityStateType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->besfactory__ActivityStateType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__ActivityStateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__ActivityStateType, 0, sizeof(besfactory__ActivityStateType), 0, soap_copy_besfactory__ActivityStateType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__ActivityStateType * SOAP_FMAC6 soap_new_besfactory__ActivityStateType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__ActivityStateType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__ActivityStateType(struct soap *soap, besfactory__ActivityStateType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__ActivityStateType * SOAP_FMAC4 soap_instantiate_besfactory__ActivityStateType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__ActivityStateType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__ActivityStateType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__ActivityStateType;
		if (size)
			*size = sizeof(besfactory__ActivityStateType);
		((besfactory__ActivityStateType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__ActivityStateType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__ActivityStateType);
		for (int i = 0; i < n; i++)
			((besfactory__ActivityStateType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__ActivityStateType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__ActivityStateType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__ActivityStateType %p -> %p\n", q, p));
	*(besfactory__ActivityStateType*)p = *(besfactory__ActivityStateType*)q;
}

void besfactory__ActivityDocumentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__ActivityDocumentType::jsdl__JobDefinition = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->besfactory__ActivityDocumentType::__any);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__ActivityDocumentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &this->besfactory__ActivityDocumentType::jsdl__JobDefinition);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->besfactory__ActivityDocumentType::__any);
	/* transient soap skipped */
}

int besfactory__ActivityDocumentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__ActivityDocumentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__ActivityDocumentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__ActivityDocumentType(struct soap *soap, const char *tag, int id, const besfactory__ActivityDocumentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType), "besfactory:ActivityDocumentType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", -1, &(a->besfactory__ActivityDocumentType::jsdl__JobDefinition), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->besfactory__ActivityDocumentType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__ActivityDocumentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__ActivityDocumentType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__ActivityDocumentType * SOAP_FMAC4 soap_get_besfactory__ActivityDocumentType(struct soap *soap, besfactory__ActivityDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__ActivityDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__ActivityDocumentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__ActivityDocumentType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__ActivityDocumentType * SOAP_FMAC4 soap_in_besfactory__ActivityDocumentType(struct soap *soap, const char *tag, besfactory__ActivityDocumentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__ActivityDocumentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType, sizeof(besfactory__ActivityDocumentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__ActivityDocumentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__ActivityDocumentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_jsdl__JobDefinition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_jsdl__JobDefinition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", &(a->besfactory__ActivityDocumentType::jsdl__JobDefinition), "jsdl:JobDefinition_Type"))
				{	soap_flag_jsdl__JobDefinition1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->besfactory__ActivityDocumentType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__ActivityDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType, 0, sizeof(besfactory__ActivityDocumentType), 0, soap_copy_besfactory__ActivityDocumentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDefinition1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__ActivityDocumentType * SOAP_FMAC6 soap_new_besfactory__ActivityDocumentType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__ActivityDocumentType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__ActivityDocumentType(struct soap *soap, besfactory__ActivityDocumentType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__ActivityDocumentType * SOAP_FMAC4 soap_instantiate_besfactory__ActivityDocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__ActivityDocumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__ActivityDocumentType;
		if (size)
			*size = sizeof(besfactory__ActivityDocumentType);
		((besfactory__ActivityDocumentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__ActivityDocumentType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__ActivityDocumentType);
		for (int i = 0; i < n; i++)
			((besfactory__ActivityDocumentType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__ActivityDocumentType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__ActivityDocumentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__ActivityDocumentType %p -> %p\n", q, p));
	*(besfactory__ActivityDocumentType*)p = *(besfactory__ActivityDocumentType*)q;
}

void besfactory__FactoryResourceAttributesDocumentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->besfactory__FactoryResourceAttributesDocumentType::IsAcceptingNewActivities);
	this->besfactory__FactoryResourceAttributesDocumentType::CommonName = NULL;
	this->besfactory__FactoryResourceAttributesDocumentType::LongDescription = NULL;
	soap_default_unsignedInt(soap, &this->besfactory__FactoryResourceAttributesDocumentType::TotalNumberOfActivities);
	soap_default_xsd__QName(soap, &this->besfactory__FactoryResourceAttributesDocumentType::LocalResourceManagerType);
	soap_default_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__FactoryResourceAttributesDocumentType::ActivityReference);
	soap_default_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->besfactory__FactoryResourceAttributesDocumentType::ContainedResourceAttributes);
	soap_default_xsd__QName(soap, &this->besfactory__FactoryResourceAttributesDocumentType::NamingProfile);
	this->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::__any);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__FactoryResourceAttributesDocumentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->besfactory__FactoryResourceAttributesDocumentType::IsAcceptingNewActivities, SOAP_TYPE_besfactory_bool);
	soap_serialize_PointerTostd__string(soap, &this->besfactory__FactoryResourceAttributesDocumentType::CommonName);
	soap_serialize_PointerTostd__string(soap, &this->besfactory__FactoryResourceAttributesDocumentType::LongDescription);
	soap_embedded(soap, &this->besfactory__FactoryResourceAttributesDocumentType::TotalNumberOfActivities, SOAP_TYPE_besfactory_unsignedInt);
	soap_serialize_xsd__QName(soap, &this->besfactory__FactoryResourceAttributesDocumentType::LocalResourceManagerType);
	soap_serialize_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, &this->besfactory__FactoryResourceAttributesDocumentType::ActivityReference);
	soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(soap, &this->besfactory__FactoryResourceAttributesDocumentType::ContainedResourceAttributes);
	soap_serialize_xsd__QName(soap, &this->besfactory__FactoryResourceAttributesDocumentType::NamingProfile);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture);
	soap_serialize_PointerTounsignedInt(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount);
	soap_serialize_PointerTounsignedLONG64(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed);
	soap_serialize_PointerTounsignedLONG64(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory);
	soap_serialize_PointerTounsignedLONG64(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::__any);
	/* transient soap skipped */
}

int besfactory__FactoryResourceAttributesDocumentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__FactoryResourceAttributesDocumentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__FactoryResourceAttributesDocumentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, const besfactory__FactoryResourceAttributesDocumentType *a, const char *type)
{
	std::string soap_tmp_LocalResourceManagerType(soap_QName2s(soap, a->LocalResourceManagerType.c_str()));
	std::string soap_tmp_NamingProfile(soap_QName2s(soap, a->NamingProfile.c_str()));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType), "besfactory:FactoryResourceAttributesDocumentType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "besfactory:OperatingSystem", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "besfactory:CPUArchitecture", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture), ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "besfactory:CPUCount", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "besfactory:CPUSpeed", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "besfactory:PhysicalMemory", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "besfactory:VirtualMemory", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::__any), ""))
		return soap->error;
	if (soap_out_bool(soap, "besfactory:IsAcceptingNewActivities", -1, &(a->besfactory__FactoryResourceAttributesDocumentType::IsAcceptingNewActivities), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "besfactory:CommonName", -1, &(a->besfactory__FactoryResourceAttributesDocumentType::CommonName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "besfactory:LongDescription", -1, &(a->besfactory__FactoryResourceAttributesDocumentType::LongDescription), ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "besfactory:TotalNumberOfActivities", -1, &(a->besfactory__FactoryResourceAttributesDocumentType::TotalNumberOfActivities), ""))
		return soap->error;
	if (soap_out_xsd__QName(soap, "besfactory:LocalResourceManagerType", -1, &soap_tmp_LocalResourceManagerType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityReference", -1, &(a->besfactory__FactoryResourceAttributesDocumentType::ActivityReference), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToxsd__anyType(soap, "besfactory:ContainedResourceAttributes", -1, &(a->besfactory__FactoryResourceAttributesDocumentType::ContainedResourceAttributes), ""))
		return soap->error;
	if (soap_out_xsd__QName(soap, "besfactory:NamingProfile", -1, &soap_tmp_NamingProfile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__FactoryResourceAttributesDocumentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__FactoryResourceAttributesDocumentType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_get_besfactory__FactoryResourceAttributesDocumentType(struct soap *soap, besfactory__FactoryResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__FactoryResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__FactoryResourceAttributesDocumentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__FactoryResourceAttributesDocumentType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_in_besfactory__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, besfactory__FactoryResourceAttributesDocumentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__FactoryResourceAttributesDocumentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType, sizeof(besfactory__FactoryResourceAttributesDocumentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__FactoryResourceAttributesDocumentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item3 = 1;
	size_t soap_flag_OperatingSystem2 = 1;
	size_t soap_flag_CPUArchitecture2 = 1;
	size_t soap_flag_CPUCount2 = 1;
	size_t soap_flag_CPUSpeed2 = 1;
	size_t soap_flag_PhysicalMemory2 = 1;
	size_t soap_flag_VirtualMemory2 = 1;
	size_t soap_flag_IsAcceptingNewActivities1 = 1;
	size_t soap_flag_CommonName1 = 1;
	size_t soap_flag_LongDescription1 = 1;
	size_t soap_flag_TotalNumberOfActivities1 = 1;
	size_t soap_flag_LocalResourceManagerType1 = 1;
	size_t soap_flag_NamingProfile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_OperatingSystem2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "besfactory:OperatingSystem", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem), "jsdl:OperatingSystem_Type"))
				{	soap_flag_OperatingSystem2--;
					continue;
				}
			if (soap_flag_CPUArchitecture2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "besfactory:CPUArchitecture", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture), "jsdl:CPUArchitecture_Type"))
				{	soap_flag_CPUArchitecture2--;
					continue;
				}
			if (soap_flag_CPUCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "besfactory:CPUCount", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount), "xsd:unsignedInt"))
				{	soap_flag_CPUCount2--;
					continue;
				}
			if (soap_flag_CPUSpeed2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "besfactory:CPUSpeed", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed), "xsd:unsignedLong"))
				{	soap_flag_CPUSpeed2--;
					continue;
				}
			if (soap_flag_PhysicalMemory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "besfactory:PhysicalMemory", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory), "xsd:unsignedLong"))
				{	soap_flag_PhysicalMemory2--;
					continue;
				}
			if (soap_flag_VirtualMemory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "besfactory:VirtualMemory", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory), "xsd:unsignedLong"))
				{	soap_flag_VirtualMemory2--;
					continue;
				}
			if (soap_flag_IsAcceptingNewActivities1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "besfactory:IsAcceptingNewActivities", &(a->besfactory__FactoryResourceAttributesDocumentType::IsAcceptingNewActivities), "xsd:boolean"))
				{	soap_flag_IsAcceptingNewActivities1--;
					continue;
				}
			if (soap_flag_CommonName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "besfactory:CommonName", &(a->besfactory__FactoryResourceAttributesDocumentType::CommonName), "xsd:string"))
				{	soap_flag_CommonName1--;
					continue;
				}
			if (soap_flag_LongDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "besfactory:LongDescription", &(a->besfactory__FactoryResourceAttributesDocumentType::LongDescription), "xsd:string"))
				{	soap_flag_LongDescription1--;
					continue;
				}
			if (soap_flag_TotalNumberOfActivities1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "besfactory:TotalNumberOfActivities", &(a->besfactory__FactoryResourceAttributesDocumentType::TotalNumberOfActivities), "xsd:unsignedInt"))
				{	soap_flag_TotalNumberOfActivities1--;
					continue;
				}
			if (soap_flag_LocalResourceManagerType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__QName(soap, "besfactory:LocalResourceManagerType", &(a->besfactory__FactoryResourceAttributesDocumentType::LocalResourceManagerType), "xsd:QName"))
				{	soap_flag_LocalResourceManagerType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, "besfactory:ActivityReference", &(a->besfactory__FactoryResourceAttributesDocumentType::ActivityReference), "besfactory2:EndpointReferenceType"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToxsd__anyType(soap, "besfactory:ContainedResourceAttributes", &(a->besfactory__FactoryResourceAttributesDocumentType::ContainedResourceAttributes), "xsd:anyType"))
					continue;
			if (soap_flag_NamingProfile1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__QName(soap, "besfactory:NamingProfile", &(a->besfactory__FactoryResourceAttributesDocumentType::NamingProfile), "xsd:QName"))
				{	soap_flag_NamingProfile1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__FactoryResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType, 0, sizeof(besfactory__FactoryResourceAttributesDocumentType), 0, soap_copy_besfactory__FactoryResourceAttributesDocumentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IsAcceptingNewActivities1 > 0 || soap_flag_TotalNumberOfActivities1 > 0 || soap_flag_LocalResourceManagerType1 > 0 || soap_flag_NamingProfile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__FactoryResourceAttributesDocumentType * SOAP_FMAC6 soap_new_besfactory__FactoryResourceAttributesDocumentType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__FactoryResourceAttributesDocumentType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__FactoryResourceAttributesDocumentType(struct soap *soap, besfactory__FactoryResourceAttributesDocumentType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__FactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_instantiate_besfactory__FactoryResourceAttributesDocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__FactoryResourceAttributesDocumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__FactoryResourceAttributesDocumentType;
		if (size)
			*size = sizeof(besfactory__FactoryResourceAttributesDocumentType);
		((besfactory__FactoryResourceAttributesDocumentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__FactoryResourceAttributesDocumentType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__FactoryResourceAttributesDocumentType);
		for (int i = 0; i < n; i++)
			((besfactory__FactoryResourceAttributesDocumentType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__FactoryResourceAttributesDocumentType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__FactoryResourceAttributesDocumentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__FactoryResourceAttributesDocumentType %p -> %p\n", q, p));
	*(besfactory__FactoryResourceAttributesDocumentType*)p = *(besfactory__FactoryResourceAttributesDocumentType*)q;
}

void besfactory__BasicFactoryResourceAttributesDocumentType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory = NULL;
	this->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::__any);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void besfactory__BasicFactoryResourceAttributesDocumentType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture);
	soap_serialize_PointerTounsignedInt(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount);
	soap_serialize_PointerTounsignedLONG64(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed);
	soap_serialize_PointerTounsignedLONG64(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory);
	soap_serialize_PointerTounsignedLONG64(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->besfactory__BasicFactoryResourceAttributesDocumentType::__any);
	/* transient soap skipped */
}

int besfactory__BasicFactoryResourceAttributesDocumentType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int besfactory__BasicFactoryResourceAttributesDocumentType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_besfactory__BasicFactoryResourceAttributesDocumentType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_besfactory__BasicFactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, const besfactory__BasicFactoryResourceAttributesDocumentType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType), "besfactory:BasicFactoryResourceAttributesDocumentType"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "besfactory:OperatingSystem", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "besfactory:CPUArchitecture", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture), ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "besfactory:CPUCount", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "besfactory:CPUSpeed", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "besfactory:PhysicalMemory", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "besfactory:VirtualMemory", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->besfactory__BasicFactoryResourceAttributesDocumentType::__any), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *besfactory__BasicFactoryResourceAttributesDocumentType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_besfactory__BasicFactoryResourceAttributesDocumentType(soap, this, tag, type);
}

SOAP_FMAC3 besfactory__BasicFactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_get_besfactory__BasicFactoryResourceAttributesDocumentType(struct soap *soap, besfactory__BasicFactoryResourceAttributesDocumentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_besfactory__BasicFactoryResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *besfactory__BasicFactoryResourceAttributesDocumentType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_besfactory__BasicFactoryResourceAttributesDocumentType(soap, tag, this, type);
}

SOAP_FMAC3 besfactory__BasicFactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_in_besfactory__BasicFactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, besfactory__BasicFactoryResourceAttributesDocumentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (besfactory__BasicFactoryResourceAttributesDocumentType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType, sizeof(besfactory__BasicFactoryResourceAttributesDocumentType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (besfactory__BasicFactoryResourceAttributesDocumentType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_OperatingSystem1 = 1;
	size_t soap_flag_CPUArchitecture1 = 1;
	size_t soap_flag_CPUCount1 = 1;
	size_t soap_flag_CPUSpeed1 = 1;
	size_t soap_flag_PhysicalMemory1 = 1;
	size_t soap_flag_VirtualMemory1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_OperatingSystem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "besfactory:OperatingSystem", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::OperatingSystem), "jsdl:OperatingSystem_Type"))
				{	soap_flag_OperatingSystem1--;
					continue;
				}
			if (soap_flag_CPUArchitecture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "besfactory:CPUArchitecture", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUArchitecture), "jsdl:CPUArchitecture_Type"))
				{	soap_flag_CPUArchitecture1--;
					continue;
				}
			if (soap_flag_CPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "besfactory:CPUCount", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUCount), "xsd:unsignedInt"))
				{	soap_flag_CPUCount1--;
					continue;
				}
			if (soap_flag_CPUSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "besfactory:CPUSpeed", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::CPUSpeed), "xsd:unsignedLong"))
				{	soap_flag_CPUSpeed1--;
					continue;
				}
			if (soap_flag_PhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "besfactory:PhysicalMemory", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::PhysicalMemory), "xsd:unsignedLong"))
				{	soap_flag_PhysicalMemory1--;
					continue;
				}
			if (soap_flag_VirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "besfactory:VirtualMemory", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::VirtualMemory), "xsd:unsignedLong"))
				{	soap_flag_VirtualMemory1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->besfactory__BasicFactoryResourceAttributesDocumentType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (besfactory__BasicFactoryResourceAttributesDocumentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType, 0, sizeof(besfactory__BasicFactoryResourceAttributesDocumentType), 0, soap_copy_besfactory__BasicFactoryResourceAttributesDocumentType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 besfactory__BasicFactoryResourceAttributesDocumentType * SOAP_FMAC6 soap_new_besfactory__BasicFactoryResourceAttributesDocumentType(struct soap *soap, int n)
{	return soap_instantiate_besfactory__BasicFactoryResourceAttributesDocumentType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_besfactory__BasicFactoryResourceAttributesDocumentType(struct soap *soap, besfactory__BasicFactoryResourceAttributesDocumentType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 besfactory__BasicFactoryResourceAttributesDocumentType * SOAP_FMAC4 soap_instantiate_besfactory__BasicFactoryResourceAttributesDocumentType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_besfactory__BasicFactoryResourceAttributesDocumentType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "besfactory:FactoryResourceAttributesDocumentType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__FactoryResourceAttributesDocumentType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__FactoryResourceAttributesDocumentType);
			((besfactory__FactoryResourceAttributesDocumentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__FactoryResourceAttributesDocumentType[n];
			if (size)
				*size = n * sizeof(besfactory__FactoryResourceAttributesDocumentType);
			for (int i = 0; i < n; i++)
				((besfactory__FactoryResourceAttributesDocumentType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__FactoryResourceAttributesDocumentType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new besfactory__BasicFactoryResourceAttributesDocumentType;
		if (size)
			*size = sizeof(besfactory__BasicFactoryResourceAttributesDocumentType);
		((besfactory__BasicFactoryResourceAttributesDocumentType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new besfactory__BasicFactoryResourceAttributesDocumentType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(besfactory__BasicFactoryResourceAttributesDocumentType);
		for (int i = 0; i < n; i++)
			((besfactory__BasicFactoryResourceAttributesDocumentType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (besfactory__BasicFactoryResourceAttributesDocumentType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_besfactory__BasicFactoryResourceAttributesDocumentType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying besfactory__BasicFactoryResourceAttributesDocumentType %p -> %p\n", q, p));
	*(besfactory__BasicFactoryResourceAttributesDocumentType*)p = *(besfactory__BasicFactoryResourceAttributesDocumentType*)q;
}

void xsd__unsignedLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedLONG64(soap, &this->xsd__unsignedLong::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__unsignedLong::__item, SOAP_TYPE_besfactory_unsignedLONG64);
	/* transient soap skipped */
}

int xsd__unsignedLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__unsignedLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const xsd__unsignedLong *a, const char *type)
{
	return soap_out_unsignedLONG64(soap, tag, id, &(a->xsd__unsignedLong::__item), "xsd:unsignedLong");
}

void *xsd__unsignedLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, xsd__unsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__unsignedLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, xsd__unsignedLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__unsignedLong, sizeof(xsd__unsignedLong), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__unsignedLong)
			return (xsd__unsignedLong *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedLONG64(soap, tag, &(a->xsd__unsignedLong::__item), "xsd:unsignedLong"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedLong * SOAP_FMAC6 soap_new_xsd__unsignedLong(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedLong(struct soap *soap, xsd__unsignedLong *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_instantiate_xsd__unsignedLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__unsignedLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedLong;
		if (size)
			*size = sizeof(xsd__unsignedLong);
		((xsd__unsignedLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedLong);
		for (int i = 0; i < n; i++)
			((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedLong*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedLong %p -> %p\n", q, p));
	*(xsd__unsignedLong*)p = *(xsd__unsignedLong*)q;
}

void xsd__unsignedInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &this->xsd__unsignedInt::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__unsignedInt::__item, SOAP_TYPE_besfactory_unsignedInt);
	/* transient soap skipped */
}

int xsd__unsignedInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__unsignedInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const xsd__unsignedInt *a, const char *type)
{
	return soap_out_unsignedInt(soap, tag, id, &(a->xsd__unsignedInt::__item), "xsd:unsignedInt");
}

void *xsd__unsignedInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, xsd__unsignedInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__unsignedInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, xsd__unsignedInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__unsignedInt, sizeof(xsd__unsignedInt), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__unsignedInt)
			return (xsd__unsignedInt *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedInt(soap, tag, &(a->xsd__unsignedInt::__item), "xsd:unsignedInt"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedInt * SOAP_FMAC6 soap_new_xsd__unsignedInt(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedInt(struct soap *soap, xsd__unsignedInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_instantiate_xsd__unsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__unsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedInt;
		if (size)
			*size = sizeof(xsd__unsignedInt);
		((xsd__unsignedInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedInt);
		for (int i = 0; i < n; i++)
			((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedInt*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedInt %p -> %p\n", q, p));
	*(xsd__unsignedInt*)p = *(xsd__unsignedInt*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->xsd__string::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_besfactory_std__string);
	soap_serialize_std__string(soap, &this->xsd__string::__item);
	/* transient soap skipped */
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__string);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__string * SOAP_FMAC6 soap_new_xsd__string(struct soap *soap, int n)
{	return soap_instantiate_xsd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string(struct soap *soap, xsd__string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string;
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->xsd__double::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__double::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__double::__item, SOAP_TYPE_besfactory_double);
	/* transient soap skipped */
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__double);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(a->xsd__double::__item), "xsd:double");
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(a->xsd__double::__item), "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__double * SOAP_FMAC6 soap_new_xsd__double(struct soap *soap, int n)
{	return soap_instantiate_xsd__double(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__double(struct soap *soap, xsd__double *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__double;
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__double[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__double);
		for (int i = 0; i < n; i++)
			((xsd__double*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->xsd__boolean::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__boolean::__item, SOAP_TYPE_besfactory_bool);
	/* transient soap skipped */
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__boolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__boolean * SOAP_FMAC6 soap_new_xsd__boolean(struct soap *soap, int n)
{	return soap_instantiate_xsd__boolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean(struct soap *soap, xsd__boolean *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean;
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__boolean[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__anyURI_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyURI_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__anyURI_::__item, SOAP_TYPE_besfactory_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI_::__item);
	/* transient soap skipped */
}

int xsd__anyURI_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__anyURI_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyURI_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI_(struct soap *soap, const char *tag, int id, const xsd__anyURI_ *a, const char *type)
{
	return soap_out_xsd__anyURI(soap, tag, id, &(a->xsd__anyURI_::__item), "xsd:anyURI");
}

void *xsd__anyURI_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_get_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyURI_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyURI_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_in_xsd__anyURI_(struct soap *soap, const char *tag, xsd__anyURI_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__anyURI_, sizeof(xsd__anyURI_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__anyURI_)
			return (xsd__anyURI_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__anyURI(soap, tag, &(a->xsd__anyURI_::__item), "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyURI_ * SOAP_FMAC6 soap_new_xsd__anyURI_(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyURI_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyURI_(struct soap *soap, xsd__anyURI_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyURI_ * SOAP_FMAC4 soap_instantiate_xsd__anyURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__anyURI_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyURI_;
		if (size)
			*size = sizeof(xsd__anyURI_);
		((xsd__anyURI_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyURI_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyURI_);
		for (int i = 0; i < n; i++)
			((xsd__anyURI_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyURI_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyURI_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyURI_ %p -> %p\n", q, p));
	*(xsd__anyURI_*)p = *(xsd__anyURI_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__anyURI(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyURI(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__anyURI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__QName_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__QName(soap, &this->xsd__QName_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__QName_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__QName(soap, &this->xsd__QName_::__item);
	/* transient soap skipped */
}

int xsd__QName_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__QName_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__QName_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName_(struct soap *soap, const char *tag, int id, const xsd__QName_ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "xsd:QName");
}

void *xsd__QName_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_get_xsd__QName_(struct soap *soap, xsd__QName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__QName_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__QName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_in_xsd__QName_(struct soap *soap, const char *tag, xsd__QName_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__QName_, sizeof(xsd__QName_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__QName_)
			return (xsd__QName_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__QName(soap, tag, &(a->xsd__QName_::__item), "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__QName_ * SOAP_FMAC6 soap_new_xsd__QName_(struct soap *soap, int n)
{	return soap_instantiate_xsd__QName_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName_(struct soap *soap, xsd__QName_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_instantiate_xsd__QName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__QName_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__QName_;
		if (size)
			*size = sizeof(xsd__QName_);
		((xsd__QName_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__QName_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__QName_);
		for (int i = 0; i < n; i++)
			((xsd__QName_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__QName_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName_ %p -> %p\n", q, p));
	*(xsd__QName_*)p = *(xsd__QName_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__QName);
	if (soap_out_xsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__QName(struct soap *soap, int n)
{	return soap_instantiate_xsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__NCName_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__NCName(soap, &this->xsd__NCName_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__NCName_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__NCName_::__item, SOAP_TYPE_besfactory_xsd__NCName);
	soap_serialize_xsd__NCName(soap, &this->xsd__NCName_::__item);
	/* transient soap skipped */
}

int xsd__NCName_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__NCName_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__NCName_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__NCName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName_(struct soap *soap, const char *tag, int id, const xsd__NCName_ *a, const char *type)
{
	return soap_out_xsd__NCName(soap, tag, id, &(a->xsd__NCName_::__item), "xsd:NCName");
}

void *xsd__NCName_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__NCName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_get_xsd__NCName_(struct soap *soap, xsd__NCName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__NCName_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__NCName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_in_xsd__NCName_(struct soap *soap, const char *tag, xsd__NCName_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__NCName_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__NCName_, sizeof(xsd__NCName_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__NCName_)
			return (xsd__NCName_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__NCName(soap, tag, &(a->xsd__NCName_::__item), "xsd:NCName"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__NCName_ * SOAP_FMAC6 soap_new_xsd__NCName_(struct soap *soap, int n)
{	return soap_instantiate_xsd__NCName_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__NCName_(struct soap *soap, xsd__NCName_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__NCName_ * SOAP_FMAC4 soap_instantiate_xsd__NCName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NCName_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__NCName_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__NCName_;
		if (size)
			*size = sizeof(xsd__NCName_);
		((xsd__NCName_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__NCName_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__NCName_);
		for (int i = 0; i < n; i++)
			((xsd__NCName_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__NCName_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__NCName_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__NCName_ %p -> %p\n", q, p));
	*(xsd__NCName_*)p = *(xsd__NCName_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NCName(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_xsd__NCName, 0, sizeof(std::string), 0, soap_copy_xsd__NCName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__NCName(struct soap *soap, int n)
{	return soap_instantiate_xsd__NCName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__NCName(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__NCName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NCName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__NCName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__NCName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__ID_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__ID(soap, &this->xsd__ID_::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__ID_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__ID_::__item, SOAP_TYPE_besfactory_xsd__ID);
	soap_serialize_xsd__ID(soap, &this->xsd__ID_::__item);
	/* transient soap skipped */
}

int xsd__ID_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__ID_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__ID_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__ID_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID_(struct soap *soap, const char *tag, int id, const xsd__ID_ *a, const char *type)
{
	return soap_out_xsd__ID(soap, tag, id, &(a->xsd__ID_::__item), "xsd:ID");
}

void *xsd__ID_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__ID_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__ID_ * SOAP_FMAC4 soap_get_xsd__ID_(struct soap *soap, xsd__ID_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__ID_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__ID_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__ID_ * SOAP_FMAC4 soap_in_xsd__ID_(struct soap *soap, const char *tag, xsd__ID_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__ID_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__ID_, sizeof(xsd__ID_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__ID_)
			return (xsd__ID_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__ID(soap, tag, &(a->xsd__ID_::__item), "xsd:ID"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__ID_ * SOAP_FMAC6 soap_new_xsd__ID_(struct soap *soap, int n)
{	return soap_instantiate_xsd__ID_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__ID_(struct soap *soap, xsd__ID_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__ID_ * SOAP_FMAC4 soap_instantiate_xsd__ID_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ID_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__ID_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__ID_;
		if (size)
			*size = sizeof(xsd__ID_);
		((xsd__ID_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__ID_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__ID_);
		for (int i = 0; i < n; i++)
			((xsd__ID_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__ID_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ID_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__ID_ %p -> %p\n", q, p));
	*(xsd__ID_*)p = *(xsd__ID_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__ID(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__ID);
	if (soap_out_xsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__ID(struct soap *soap, int n)
{	return soap_instantiate_xsd__ID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__ID(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_besfactory_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_besfactory_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_besfactory_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_besfactory_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_besfactory_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:ID"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__ID_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__ID_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__ID_);
			((xsd__ID_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__ID_[n];
			if (size)
				*size = n * sizeof(xsd__ID_);
			for (int i = 0; i < n; i++)
				((xsd__ID_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__ID_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:NCName"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__NCName_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__NCName_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__NCName_);
			((xsd__NCName_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__NCName_[n];
			if (size)
				*size = n * sizeof(xsd__NCName_);
			for (int i = 0; i < n; i++)
				((xsd__NCName_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__NCName_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:QName"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__QName_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__QName_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__QName_);
			((xsd__QName_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__QName_[n];
			if (size)
				*size = n * sizeof(xsd__QName_);
			for (int i = 0; i < n; i++)
				((xsd__QName_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__QName_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:anyURI"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__anyURI_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__anyURI_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__anyURI_);
			((xsd__anyURI_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__anyURI_[n];
			if (size)
				*size = n * sizeof(xsd__anyURI_);
			for (int i = 0; i < n; i++)
				((xsd__anyURI_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__anyURI_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__boolean[n];
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__double[n];
			if (size)
				*size = n * sizeof(xsd__double);
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__string[n];
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__unsignedInt;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedInt);
			((xsd__unsignedInt*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt);
			for (int i = 0; i < n; i++)
				((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_besfactory_xsd__unsignedLong;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedLong);
			((xsd__unsignedLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong);
			for (int i = 0; i < n; i++)
				((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:RelationshipType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__RelationshipType_;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__RelationshipType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__RelationshipType_);
			((besfactory2__RelationshipType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__RelationshipType_[n];
			if (size)
				*size = n * sizeof(besfactory2__RelationshipType_);
			for (int i = 0; i < n; i++)
				((besfactory2__RelationshipType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__RelationshipType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:FaultCodesType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__FaultCodesType_;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__FaultCodesType_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__FaultCodesType_);
			((besfactory2__FaultCodesType_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__FaultCodesType_[n];
			if (size)
				*size = n * sizeof(besfactory2__FaultCodesType_);
			for (int i = 0; i < n; i++)
				((besfactory2__FaultCodesType_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__FaultCodesType_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:ProcessorArchitectureEnumeration"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__ProcessorArchitectureEnumeration_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__ProcessorArchitectureEnumeration_);
			((jsdl__ProcessorArchitectureEnumeration_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__ProcessorArchitectureEnumeration_[n];
			if (size)
				*size = n * sizeof(jsdl__ProcessorArchitectureEnumeration_);
			for (int i = 0; i < n; i++)
				((jsdl__ProcessorArchitectureEnumeration_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__ProcessorArchitectureEnumeration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:OperatingSystemTypeEnumeration"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__OperatingSystemTypeEnumeration_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__OperatingSystemTypeEnumeration_);
			((jsdl__OperatingSystemTypeEnumeration_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__OperatingSystemTypeEnumeration_[n];
			if (size)
				*size = n * sizeof(jsdl__OperatingSystemTypeEnumeration_);
			for (int i = 0; i < n; i++)
				((jsdl__OperatingSystemTypeEnumeration_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__OperatingSystemTypeEnumeration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:FileSystemTypeEnumeration"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__FileSystemTypeEnumeration_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__FileSystemTypeEnumeration_);
			((jsdl__FileSystemTypeEnumeration_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__FileSystemTypeEnumeration_[n];
			if (size)
				*size = n * sizeof(jsdl__FileSystemTypeEnumeration_);
			for (int i = 0; i < n; i++)
				((jsdl__FileSystemTypeEnumeration_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__FileSystemTypeEnumeration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:CreationFlagEnumeration"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__CreationFlagEnumeration_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__CreationFlagEnumeration_);
			((jsdl__CreationFlagEnumeration_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__CreationFlagEnumeration_[n];
			if (size)
				*size = n * sizeof(jsdl__CreationFlagEnumeration_);
			for (int i = 0; i < n; i++)
				((jsdl__CreationFlagEnumeration_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__CreationFlagEnumeration_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:Description_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__Description_USCOREType__;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__Description_USCOREType__;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__Description_USCOREType__);
			((jsdl__Description_USCOREType__*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__Description_USCOREType__[n];
			if (size)
				*size = n * sizeof(jsdl__Description_USCOREType__);
			for (int i = 0; i < n; i++)
				((jsdl__Description_USCOREType__*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__Description_USCOREType__*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:BasicFactoryResourceAttributesDocumentType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__BasicFactoryResourceAttributesDocumentType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__BasicFactoryResourceAttributesDocumentType);
			((besfactory__BasicFactoryResourceAttributesDocumentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__BasicFactoryResourceAttributesDocumentType[n];
			if (size)
				*size = n * sizeof(besfactory__BasicFactoryResourceAttributesDocumentType);
			for (int i = 0; i < n; i++)
				((besfactory__BasicFactoryResourceAttributesDocumentType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__BasicFactoryResourceAttributesDocumentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:ActivityDocumentType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__ActivityDocumentType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__ActivityDocumentType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__ActivityDocumentType);
			((besfactory__ActivityDocumentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__ActivityDocumentType[n];
			if (size)
				*size = n * sizeof(besfactory__ActivityDocumentType);
			for (int i = 0; i < n; i++)
				((besfactory__ActivityDocumentType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__ActivityDocumentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:ActivityStateType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__ActivityStateType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__ActivityStateType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__ActivityStateType);
			((besfactory__ActivityStateType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__ActivityStateType[n];
			if (size)
				*size = n * sizeof(besfactory__ActivityStateType);
			for (int i = 0; i < n; i++)
				((besfactory__ActivityStateType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__ActivityStateType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:ActivityStatusType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__ActivityStatusType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__ActivityStatusType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__ActivityStatusType);
			((besfactory__ActivityStatusType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__ActivityStatusType[n];
			if (size)
				*size = n * sizeof(besfactory__ActivityStatusType);
			for (int i = 0; i < n; i++)
				((besfactory__ActivityStatusType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__ActivityStatusType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetActivityStatusResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetActivityStatusResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetActivityStatusResponseType);
			((besfactory__GetActivityStatusResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetActivityStatusResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__GetActivityStatusResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__GetActivityStatusResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetActivityStatusResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetActivityDocumentResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetActivityDocumentResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetActivityDocumentResponseType);
			((besfactory__GetActivityDocumentResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetActivityDocumentResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__GetActivityDocumentResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__GetActivityDocumentResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetActivityDocumentResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:TerminateActivityResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__TerminateActivityResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__TerminateActivityResponseType);
			((besfactory__TerminateActivityResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__TerminateActivityResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__TerminateActivityResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__TerminateActivityResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__TerminateActivityResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:CreateActivityType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__CreateActivityType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__CreateActivityType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__CreateActivityType);
			((besfactory__CreateActivityType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__CreateActivityType[n];
			if (size)
				*size = n * sizeof(besfactory__CreateActivityType);
			for (int i = 0; i < n; i++)
				((besfactory__CreateActivityType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__CreateActivityType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:CreateActivityResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__CreateActivityResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__CreateActivityResponseType);
			((besfactory__CreateActivityResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__CreateActivityResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__CreateActivityResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__CreateActivityResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__CreateActivityResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetActivityStatusesType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetActivityStatusesType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetActivityStatusesType);
			((besfactory__GetActivityStatusesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetActivityStatusesType[n];
			if (size)
				*size = n * sizeof(besfactory__GetActivityStatusesType);
			for (int i = 0; i < n; i++)
				((besfactory__GetActivityStatusesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetActivityStatusesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetActivityStatusesResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetActivityStatusesResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetActivityStatusesResponseType);
			((besfactory__GetActivityStatusesResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetActivityStatusesResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__GetActivityStatusesResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__GetActivityStatusesResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetActivityStatusesResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:TerminateActivitiesType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__TerminateActivitiesType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__TerminateActivitiesType);
			((besfactory__TerminateActivitiesType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__TerminateActivitiesType[n];
			if (size)
				*size = n * sizeof(besfactory__TerminateActivitiesType);
			for (int i = 0; i < n; i++)
				((besfactory__TerminateActivitiesType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__TerminateActivitiesType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:TerminateActivitiesResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__TerminateActivitiesResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__TerminateActivitiesResponseType);
			((besfactory__TerminateActivitiesResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__TerminateActivitiesResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__TerminateActivitiesResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__TerminateActivitiesResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__TerminateActivitiesResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetActivityDocumentsType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetActivityDocumentsType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetActivityDocumentsType);
			((besfactory__GetActivityDocumentsType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetActivityDocumentsType[n];
			if (size)
				*size = n * sizeof(besfactory__GetActivityDocumentsType);
			for (int i = 0; i < n; i++)
				((besfactory__GetActivityDocumentsType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetActivityDocumentsType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetActivityDocumentsResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetActivityDocumentsResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetActivityDocumentsResponseType);
			((besfactory__GetActivityDocumentsResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetActivityDocumentsResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__GetActivityDocumentsResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__GetActivityDocumentsResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetActivityDocumentsResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetFactoryAttributesDocumentType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetFactoryAttributesDocumentType);
			((besfactory__GetFactoryAttributesDocumentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentType[n];
			if (size)
				*size = n * sizeof(besfactory__GetFactoryAttributesDocumentType);
			for (int i = 0; i < n; i++)
				((besfactory__GetFactoryAttributesDocumentType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetFactoryAttributesDocumentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:GetFactoryAttributesDocumentResponseType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentResponseType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__GetFactoryAttributesDocumentResponseType);
			((besfactory__GetFactoryAttributesDocumentResponseType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__GetFactoryAttributesDocumentResponseType[n];
			if (size)
				*size = n * sizeof(besfactory__GetFactoryAttributesDocumentResponseType);
			for (int i = 0; i < n; i++)
				((besfactory__GetFactoryAttributesDocumentResponseType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__GetFactoryAttributesDocumentResponseType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:NotAcceptingNewActivitiesFaultType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__NotAcceptingNewActivitiesFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__NotAcceptingNewActivitiesFaultType);
			((besfactory__NotAcceptingNewActivitiesFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__NotAcceptingNewActivitiesFaultType[n];
			if (size)
				*size = n * sizeof(besfactory__NotAcceptingNewActivitiesFaultType);
			for (int i = 0; i < n; i++)
				((besfactory__NotAcceptingNewActivitiesFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__NotAcceptingNewActivitiesFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:UnsupportedJSDLVersionFaultType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__UnsupportedJSDLVersionFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__UnsupportedJSDLVersionFaultType);
			((besfactory__UnsupportedJSDLVersionFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__UnsupportedJSDLVersionFaultType[n];
			if (size)
				*size = n * sizeof(besfactory__UnsupportedJSDLVersionFaultType);
			for (int i = 0; i < n; i++)
				((besfactory__UnsupportedJSDLVersionFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__UnsupportedJSDLVersionFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:UnsupportedFeatureFaultType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__UnsupportedFeatureFaultType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__UnsupportedFeatureFaultType);
			((besfactory__UnsupportedFeatureFaultType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__UnsupportedFeatureFaultType[n];
			if (size)
				*size = n * sizeof(besfactory__UnsupportedFeatureFaultType);
			for (int i = 0; i < n; i++)
				((besfactory__UnsupportedFeatureFaultType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__UnsupportedFeatureFaultType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:EndpointReferenceType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__EndpointReferenceType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__EndpointReferenceType);
			((besfactory2__EndpointReferenceType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__EndpointReferenceType[n];
			if (size)
				*size = n * sizeof(besfactory2__EndpointReferenceType);
			for (int i = 0; i < n; i++)
				((besfactory2__EndpointReferenceType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__EndpointReferenceType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:ReferenceParametersType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__ReferenceParametersType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__ReferenceParametersType);
			((besfactory2__ReferenceParametersType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__ReferenceParametersType[n];
			if (size)
				*size = n * sizeof(besfactory2__ReferenceParametersType);
			for (int i = 0; i < n; i++)
				((besfactory2__ReferenceParametersType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__ReferenceParametersType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:MetadataType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__MetadataType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__MetadataType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__MetadataType);
			((besfactory2__MetadataType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__MetadataType[n];
			if (size)
				*size = n * sizeof(besfactory2__MetadataType);
			for (int i = 0; i < n; i++)
				((besfactory2__MetadataType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__MetadataType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:AttributedAnyType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__AttributedAnyType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__AttributedAnyType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__AttributedAnyType);
			((besfactory2__AttributedAnyType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__AttributedAnyType[n];
			if (size)
				*size = n * sizeof(besfactory2__AttributedAnyType);
			for (int i = 0; i < n; i++)
				((besfactory2__AttributedAnyType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__AttributedAnyType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:ProblemActionType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__ProblemActionType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__ProblemActionType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__ProblemActionType);
			((besfactory2__ProblemActionType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__ProblemActionType[n];
			if (size)
				*size = n * sizeof(besfactory2__ProblemActionType);
			for (int i = 0; i < n; i++)
				((besfactory2__ProblemActionType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__ProblemActionType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:Range_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__Range_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__Range_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__Range_USCOREType);
			((jsdl__Range_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__Range_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__Range_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__Range_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__Range_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:RangeValue_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__RangeValue_USCOREType);
			((jsdl__RangeValue_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__RangeValue_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__RangeValue_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__RangeValue_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:JobDefinition_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__JobDefinition_USCOREType);
			((jsdl__JobDefinition_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__JobDefinition_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__JobDefinition_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__JobDefinition_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:JobDescription_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__JobDescription_USCOREType);
			((jsdl__JobDescription_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__JobDescription_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__JobDescription_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__JobDescription_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:JobIdentification_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__JobIdentification_USCOREType);
			((jsdl__JobIdentification_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__JobIdentification_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__JobIdentification_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__JobIdentification_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:Application_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__Application_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__Application_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__Application_USCOREType);
			((jsdl__Application_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__Application_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__Application_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__Application_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__Application_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:Resources_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__Resources_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__Resources_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__Resources_USCOREType);
			((jsdl__Resources_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__Resources_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__Resources_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__Resources_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__Resources_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:CandidateHosts_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__CandidateHosts_USCOREType);
			((jsdl__CandidateHosts_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__CandidateHosts_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__CandidateHosts_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__CandidateHosts_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:CPUArchitecture_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__CPUArchitecture_USCOREType);
			((jsdl__CPUArchitecture_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__CPUArchitecture_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__CPUArchitecture_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__CPUArchitecture_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:FileSystem_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__FileSystem_USCOREType);
			((jsdl__FileSystem_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__FileSystem_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__FileSystem_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__FileSystem_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:OperatingSystem_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__OperatingSystem_USCOREType);
			((jsdl__OperatingSystem_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__OperatingSystem_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__OperatingSystem_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__OperatingSystem_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:OperatingSystemType_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__OperatingSystemType_USCOREType);
			((jsdl__OperatingSystemType_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__OperatingSystemType_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__OperatingSystemType_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__OperatingSystemType_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:DataStaging_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__DataStaging_USCOREType);
			((jsdl__DataStaging_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__DataStaging_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__DataStaging_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__DataStaging_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:SourceTarget_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__SourceTarget_USCOREType);
			((jsdl__SourceTarget_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__SourceTarget_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__SourceTarget_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__SourceTarget_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory:FactoryResourceAttributesDocumentType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory__FactoryResourceAttributesDocumentType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory__FactoryResourceAttributesDocumentType);
			((besfactory__FactoryResourceAttributesDocumentType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory__FactoryResourceAttributesDocumentType[n];
			if (size)
				*size = n * sizeof(besfactory__FactoryResourceAttributesDocumentType);
			for (int i = 0; i < n; i++)
				((besfactory__FactoryResourceAttributesDocumentType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory__FactoryResourceAttributesDocumentType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:RelatesToType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__RelatesToType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__RelatesToType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__RelatesToType);
			((besfactory2__RelatesToType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__RelatesToType[n];
			if (size)
				*size = n * sizeof(besfactory2__RelatesToType);
			for (int i = 0; i < n; i++)
				((besfactory2__RelatesToType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__RelatesToType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:AttributedURIType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__AttributedURIType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__AttributedURIType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__AttributedURIType);
			((besfactory2__AttributedURIType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__AttributedURIType[n];
			if (size)
				*size = n * sizeof(besfactory2__AttributedURIType);
			for (int i = 0; i < n; i++)
				((besfactory2__AttributedURIType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__AttributedURIType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:AttributedUnsignedLongType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__AttributedUnsignedLongType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__AttributedUnsignedLongType);
			((besfactory2__AttributedUnsignedLongType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__AttributedUnsignedLongType[n];
			if (size)
				*size = n * sizeof(besfactory2__AttributedUnsignedLongType);
			for (int i = 0; i < n; i++)
				((besfactory2__AttributedUnsignedLongType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__AttributedUnsignedLongType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "besfactory2:AttributedQNameType"))
	{	cp->type = SOAP_TYPE_besfactory_besfactory2__AttributedQNameType;
		if (n < 0)
		{	cp->ptr = (void*)new besfactory2__AttributedQNameType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(besfactory2__AttributedQNameType);
			((besfactory2__AttributedQNameType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new besfactory2__AttributedQNameType[n];
			if (size)
				*size = n * sizeof(besfactory2__AttributedQNameType);
			for (int i = 0; i < n; i++)
				((besfactory2__AttributedQNameType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (besfactory2__AttributedQNameType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:Boundary_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__Boundary_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__Boundary_USCOREType);
			((jsdl__Boundary_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__Boundary_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__Boundary_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__Boundary_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__Boundary_USCOREType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "jsdl:Exact_Type"))
	{	cp->type = SOAP_TYPE_besfactory_jsdl__Exact_USCOREType;
		if (n < 0)
		{	cp->ptr = (void*)new jsdl__Exact_USCOREType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(jsdl__Exact_USCOREType);
			((jsdl__Exact_USCOREType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new jsdl__Exact_USCOREType[n];
			if (size)
				*size = n * sizeof(jsdl__Exact_USCOREType);
			for (int i = 0; i < n; i++)
				((jsdl__Exact_USCOREType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (jsdl__Exact_USCOREType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___besfactory__GetFactoryAttributesDocument(struct soap *soap, struct __besfactory__GetFactoryAttributesDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->besfactory__GetFactoryAttributesDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___besfactory__GetFactoryAttributesDocument(struct soap *soap, const struct __besfactory__GetFactoryAttributesDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, &a->besfactory__GetFactoryAttributesDocument);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___besfactory__GetFactoryAttributesDocument(struct soap *soap, const struct __besfactory__GetFactoryAttributesDocument *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___besfactory__GetFactoryAttributesDocument(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___besfactory__GetFactoryAttributesDocument(struct soap *soap, const char *tag, int id, const struct __besfactory__GetFactoryAttributesDocument *a, const char *type)
{
	if (soap_out_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, "besfactory:GetFactoryAttributesDocument", -1, &a->besfactory__GetFactoryAttributesDocument, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __besfactory__GetFactoryAttributesDocument * SOAP_FMAC4 soap_get___besfactory__GetFactoryAttributesDocument(struct soap *soap, struct __besfactory__GetFactoryAttributesDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in___besfactory__GetFactoryAttributesDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __besfactory__GetFactoryAttributesDocument * SOAP_FMAC4 soap_in___besfactory__GetFactoryAttributesDocument(struct soap *soap, const char *tag, struct __besfactory__GetFactoryAttributesDocument *a, const char *type)
{
	size_t soap_flag_besfactory__GetFactoryAttributesDocument = 1;
	short soap_flag;
	a = (struct __besfactory__GetFactoryAttributesDocument *)soap_id_enter(soap, "", a, SOAP_TYPE_besfactory___besfactory__GetFactoryAttributesDocument, sizeof(struct __besfactory__GetFactoryAttributesDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___besfactory__GetFactoryAttributesDocument(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_besfactory__GetFactoryAttributesDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, "besfactory:GetFactoryAttributesDocument", &a->besfactory__GetFactoryAttributesDocument, "besfactory:GetFactoryAttributesDocumentType"))
				{	soap_flag_besfactory__GetFactoryAttributesDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __besfactory__GetFactoryAttributesDocument * SOAP_FMAC6 soap_new___besfactory__GetFactoryAttributesDocument(struct soap *soap, int n)
{	return soap_instantiate___besfactory__GetFactoryAttributesDocument(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___besfactory__GetFactoryAttributesDocument(struct soap *soap, struct __besfactory__GetFactoryAttributesDocument *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __besfactory__GetFactoryAttributesDocument * SOAP_FMAC4 soap_instantiate___besfactory__GetFactoryAttributesDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___besfactory__GetFactoryAttributesDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory___besfactory__GetFactoryAttributesDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __besfactory__GetFactoryAttributesDocument;
		if (size)
			*size = sizeof(struct __besfactory__GetFactoryAttributesDocument);
	}
	else
	{	cp->ptr = (void*)new struct __besfactory__GetFactoryAttributesDocument[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __besfactory__GetFactoryAttributesDocument);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __besfactory__GetFactoryAttributesDocument*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___besfactory__GetFactoryAttributesDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __besfactory__GetFactoryAttributesDocument %p -> %p\n", q, p));
	*(struct __besfactory__GetFactoryAttributesDocument*)p = *(struct __besfactory__GetFactoryAttributesDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___besfactory__GetActivityDocuments(struct soap *soap, struct __besfactory__GetActivityDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->besfactory__GetActivityDocuments = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___besfactory__GetActivityDocuments(struct soap *soap, const struct __besfactory__GetActivityDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory__GetActivityDocumentsType(soap, &a->besfactory__GetActivityDocuments);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___besfactory__GetActivityDocuments(struct soap *soap, const struct __besfactory__GetActivityDocuments *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___besfactory__GetActivityDocuments(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___besfactory__GetActivityDocuments(struct soap *soap, const char *tag, int id, const struct __besfactory__GetActivityDocuments *a, const char *type)
{
	if (soap_out_PointerTobesfactory__GetActivityDocumentsType(soap, "besfactory:GetActivityDocuments", -1, &a->besfactory__GetActivityDocuments, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __besfactory__GetActivityDocuments * SOAP_FMAC4 soap_get___besfactory__GetActivityDocuments(struct soap *soap, struct __besfactory__GetActivityDocuments *p, const char *tag, const char *type)
{
	if ((p = soap_in___besfactory__GetActivityDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __besfactory__GetActivityDocuments * SOAP_FMAC4 soap_in___besfactory__GetActivityDocuments(struct soap *soap, const char *tag, struct __besfactory__GetActivityDocuments *a, const char *type)
{
	size_t soap_flag_besfactory__GetActivityDocuments = 1;
	short soap_flag;
	a = (struct __besfactory__GetActivityDocuments *)soap_id_enter(soap, "", a, SOAP_TYPE_besfactory___besfactory__GetActivityDocuments, sizeof(struct __besfactory__GetActivityDocuments), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___besfactory__GetActivityDocuments(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_besfactory__GetActivityDocuments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__GetActivityDocumentsType(soap, "besfactory:GetActivityDocuments", &a->besfactory__GetActivityDocuments, "besfactory:GetActivityDocumentsType"))
				{	soap_flag_besfactory__GetActivityDocuments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __besfactory__GetActivityDocuments * SOAP_FMAC6 soap_new___besfactory__GetActivityDocuments(struct soap *soap, int n)
{	return soap_instantiate___besfactory__GetActivityDocuments(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___besfactory__GetActivityDocuments(struct soap *soap, struct __besfactory__GetActivityDocuments *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __besfactory__GetActivityDocuments * SOAP_FMAC4 soap_instantiate___besfactory__GetActivityDocuments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___besfactory__GetActivityDocuments(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory___besfactory__GetActivityDocuments, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __besfactory__GetActivityDocuments;
		if (size)
			*size = sizeof(struct __besfactory__GetActivityDocuments);
	}
	else
	{	cp->ptr = (void*)new struct __besfactory__GetActivityDocuments[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __besfactory__GetActivityDocuments);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __besfactory__GetActivityDocuments*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___besfactory__GetActivityDocuments(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __besfactory__GetActivityDocuments %p -> %p\n", q, p));
	*(struct __besfactory__GetActivityDocuments*)p = *(struct __besfactory__GetActivityDocuments*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___besfactory__TerminateActivities(struct soap *soap, struct __besfactory__TerminateActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->besfactory__TerminateActivities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___besfactory__TerminateActivities(struct soap *soap, const struct __besfactory__TerminateActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory__TerminateActivitiesType(soap, &a->besfactory__TerminateActivities);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___besfactory__TerminateActivities(struct soap *soap, const struct __besfactory__TerminateActivities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___besfactory__TerminateActivities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___besfactory__TerminateActivities(struct soap *soap, const char *tag, int id, const struct __besfactory__TerminateActivities *a, const char *type)
{
	if (soap_out_PointerTobesfactory__TerminateActivitiesType(soap, "besfactory:TerminateActivities", -1, &a->besfactory__TerminateActivities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __besfactory__TerminateActivities * SOAP_FMAC4 soap_get___besfactory__TerminateActivities(struct soap *soap, struct __besfactory__TerminateActivities *p, const char *tag, const char *type)
{
	if ((p = soap_in___besfactory__TerminateActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __besfactory__TerminateActivities * SOAP_FMAC4 soap_in___besfactory__TerminateActivities(struct soap *soap, const char *tag, struct __besfactory__TerminateActivities *a, const char *type)
{
	size_t soap_flag_besfactory__TerminateActivities = 1;
	short soap_flag;
	a = (struct __besfactory__TerminateActivities *)soap_id_enter(soap, "", a, SOAP_TYPE_besfactory___besfactory__TerminateActivities, sizeof(struct __besfactory__TerminateActivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___besfactory__TerminateActivities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_besfactory__TerminateActivities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__TerminateActivitiesType(soap, "besfactory:TerminateActivities", &a->besfactory__TerminateActivities, "besfactory:TerminateActivitiesType"))
				{	soap_flag_besfactory__TerminateActivities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __besfactory__TerminateActivities * SOAP_FMAC6 soap_new___besfactory__TerminateActivities(struct soap *soap, int n)
{	return soap_instantiate___besfactory__TerminateActivities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___besfactory__TerminateActivities(struct soap *soap, struct __besfactory__TerminateActivities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __besfactory__TerminateActivities * SOAP_FMAC4 soap_instantiate___besfactory__TerminateActivities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___besfactory__TerminateActivities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory___besfactory__TerminateActivities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __besfactory__TerminateActivities;
		if (size)
			*size = sizeof(struct __besfactory__TerminateActivities);
	}
	else
	{	cp->ptr = (void*)new struct __besfactory__TerminateActivities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __besfactory__TerminateActivities);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __besfactory__TerminateActivities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___besfactory__TerminateActivities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __besfactory__TerminateActivities %p -> %p\n", q, p));
	*(struct __besfactory__TerminateActivities*)p = *(struct __besfactory__TerminateActivities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___besfactory__GetActivityStatuses(struct soap *soap, struct __besfactory__GetActivityStatuses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->besfactory__GetActivityStatuses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___besfactory__GetActivityStatuses(struct soap *soap, const struct __besfactory__GetActivityStatuses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory__GetActivityStatusesType(soap, &a->besfactory__GetActivityStatuses);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___besfactory__GetActivityStatuses(struct soap *soap, const struct __besfactory__GetActivityStatuses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___besfactory__GetActivityStatuses(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___besfactory__GetActivityStatuses(struct soap *soap, const char *tag, int id, const struct __besfactory__GetActivityStatuses *a, const char *type)
{
	if (soap_out_PointerTobesfactory__GetActivityStatusesType(soap, "besfactory:GetActivityStatuses", -1, &a->besfactory__GetActivityStatuses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __besfactory__GetActivityStatuses * SOAP_FMAC4 soap_get___besfactory__GetActivityStatuses(struct soap *soap, struct __besfactory__GetActivityStatuses *p, const char *tag, const char *type)
{
	if ((p = soap_in___besfactory__GetActivityStatuses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __besfactory__GetActivityStatuses * SOAP_FMAC4 soap_in___besfactory__GetActivityStatuses(struct soap *soap, const char *tag, struct __besfactory__GetActivityStatuses *a, const char *type)
{
	size_t soap_flag_besfactory__GetActivityStatuses = 1;
	short soap_flag;
	a = (struct __besfactory__GetActivityStatuses *)soap_id_enter(soap, "", a, SOAP_TYPE_besfactory___besfactory__GetActivityStatuses, sizeof(struct __besfactory__GetActivityStatuses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___besfactory__GetActivityStatuses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_besfactory__GetActivityStatuses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__GetActivityStatusesType(soap, "besfactory:GetActivityStatuses", &a->besfactory__GetActivityStatuses, "besfactory:GetActivityStatusesType"))
				{	soap_flag_besfactory__GetActivityStatuses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __besfactory__GetActivityStatuses * SOAP_FMAC6 soap_new___besfactory__GetActivityStatuses(struct soap *soap, int n)
{	return soap_instantiate___besfactory__GetActivityStatuses(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___besfactory__GetActivityStatuses(struct soap *soap, struct __besfactory__GetActivityStatuses *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __besfactory__GetActivityStatuses * SOAP_FMAC4 soap_instantiate___besfactory__GetActivityStatuses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___besfactory__GetActivityStatuses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory___besfactory__GetActivityStatuses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __besfactory__GetActivityStatuses;
		if (size)
			*size = sizeof(struct __besfactory__GetActivityStatuses);
	}
	else
	{	cp->ptr = (void*)new struct __besfactory__GetActivityStatuses[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __besfactory__GetActivityStatuses);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __besfactory__GetActivityStatuses*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___besfactory__GetActivityStatuses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __besfactory__GetActivityStatuses %p -> %p\n", q, p));
	*(struct __besfactory__GetActivityStatuses*)p = *(struct __besfactory__GetActivityStatuses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___besfactory__CreateActivity(struct soap *soap, struct __besfactory__CreateActivity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->besfactory__CreateActivity = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___besfactory__CreateActivity(struct soap *soap, const struct __besfactory__CreateActivity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobesfactory__CreateActivityType(soap, &a->besfactory__CreateActivity);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___besfactory__CreateActivity(struct soap *soap, const struct __besfactory__CreateActivity *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___besfactory__CreateActivity(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___besfactory__CreateActivity(struct soap *soap, const char *tag, int id, const struct __besfactory__CreateActivity *a, const char *type)
{
	if (soap_out_PointerTobesfactory__CreateActivityType(soap, "besfactory:CreateActivity", -1, &a->besfactory__CreateActivity, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __besfactory__CreateActivity * SOAP_FMAC4 soap_get___besfactory__CreateActivity(struct soap *soap, struct __besfactory__CreateActivity *p, const char *tag, const char *type)
{
	if ((p = soap_in___besfactory__CreateActivity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __besfactory__CreateActivity * SOAP_FMAC4 soap_in___besfactory__CreateActivity(struct soap *soap, const char *tag, struct __besfactory__CreateActivity *a, const char *type)
{
	size_t soap_flag_besfactory__CreateActivity = 1;
	short soap_flag;
	a = (struct __besfactory__CreateActivity *)soap_id_enter(soap, "", a, SOAP_TYPE_besfactory___besfactory__CreateActivity, sizeof(struct __besfactory__CreateActivity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___besfactory__CreateActivity(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_besfactory__CreateActivity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobesfactory__CreateActivityType(soap, "besfactory:CreateActivity", &a->besfactory__CreateActivity, "besfactory:CreateActivityType"))
				{	soap_flag_besfactory__CreateActivity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __besfactory__CreateActivity * SOAP_FMAC6 soap_new___besfactory__CreateActivity(struct soap *soap, int n)
{	return soap_instantiate___besfactory__CreateActivity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___besfactory__CreateActivity(struct soap *soap, struct __besfactory__CreateActivity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __besfactory__CreateActivity * SOAP_FMAC4 soap_instantiate___besfactory__CreateActivity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___besfactory__CreateActivity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory___besfactory__CreateActivity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __besfactory__CreateActivity;
		if (size)
			*size = sizeof(struct __besfactory__CreateActivity);
	}
	else
	{	cp->ptr = (void*)new struct __besfactory__CreateActivity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __besfactory__CreateActivity);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __besfactory__CreateActivity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___besfactory__CreateActivity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __besfactory__CreateActivity %p -> %p\n", q, p));
	*(struct __besfactory__CreateActivity*)p = *(struct __besfactory__CreateActivity*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->besfactory__CreateActivityFaultMessage = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &a->besfactory__CreateActivityFaultMessage);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_besfactory_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "besfactory:CreateActivityFaultMessage", -1, &a->besfactory__CreateActivityFaultMessage, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_besfactory__CreateActivityFaultMessage = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_besfactory_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_besfactory__CreateActivityFaultMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "besfactory:CreateActivityFaultMessage", &a->besfactory__CreateActivityFaultMessage, "xsd:anyType"))
				{	soap_flag_besfactory__CreateActivityFaultMessage--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_besfactory_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__besfactory__union_ActivityStatusType(struct soap *soap, int choice, const union _besfactory__union_ActivityStatusType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__besfactory__union_ActivityStatusType_Pending:
		soap_serialize_PointerTobesfactory__ActivityStateType(soap, &a->Pending);
		break;
	case SOAP_UNION__besfactory__union_ActivityStatusType_Running:
		soap_serialize_PointerTobesfactory__ActivityStateType(soap, &a->Running);
		break;
	case SOAP_UNION__besfactory__union_ActivityStatusType_Cancelled:
		soap_serialize_PointerTobesfactory__ActivityStateType(soap, &a->Cancelled);
		break;
	case SOAP_UNION__besfactory__union_ActivityStatusType_Failed:
		soap_serialize_PointerTobesfactory__ActivityStateType(soap, &a->Failed);
		break;
	case SOAP_UNION__besfactory__union_ActivityStatusType_Finished:
		soap_serialize_PointerTobesfactory__ActivityStateType(soap, &a->Finished);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__besfactory__union_ActivityStatusType(struct soap *soap, int choice, const union _besfactory__union_ActivityStatusType *a)
{
	switch (choice)
	{
	case SOAP_UNION__besfactory__union_ActivityStatusType_Pending:
		return soap_out_PointerTobesfactory__ActivityStateType(soap, "besfactory:Pending", -1, &a->Pending, "");
	case SOAP_UNION__besfactory__union_ActivityStatusType_Running:
		return soap_out_PointerTobesfactory__ActivityStateType(soap, "besfactory:Running", -1, &a->Running, "");
	case SOAP_UNION__besfactory__union_ActivityStatusType_Cancelled:
		return soap_out_PointerTobesfactory__ActivityStateType(soap, "besfactory:Cancelled", -1, &a->Cancelled, "");
	case SOAP_UNION__besfactory__union_ActivityStatusType_Failed:
		return soap_out_PointerTobesfactory__ActivityStateType(soap, "besfactory:Failed", -1, &a->Failed, "");
	case SOAP_UNION__besfactory__union_ActivityStatusType_Finished:
		return soap_out_PointerTobesfactory__ActivityStateType(soap, "besfactory:Finished", -1, &a->Finished, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _besfactory__union_ActivityStatusType * SOAP_FMAC4 soap_in__besfactory__union_ActivityStatusType(struct soap *soap, int *choice, union _besfactory__union_ActivityStatusType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Pending = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTobesfactory__ActivityStateType(soap, "besfactory:Pending", &a->Pending, "besfactory:ActivityStateType"))
	{	*choice = SOAP_UNION__besfactory__union_ActivityStatusType_Pending;
		return a;
	}
	a->Running = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTobesfactory__ActivityStateType(soap, "besfactory:Running", &a->Running, "besfactory:ActivityStateType"))
	{	*choice = SOAP_UNION__besfactory__union_ActivityStatusType_Running;
		return a;
	}
	a->Cancelled = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTobesfactory__ActivityStateType(soap, "besfactory:Cancelled", &a->Cancelled, "besfactory:ActivityStateType"))
	{	*choice = SOAP_UNION__besfactory__union_ActivityStatusType_Cancelled;
		return a;
	}
	a->Failed = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTobesfactory__ActivityStateType(soap, "besfactory:Failed", &a->Failed, "besfactory:ActivityStateType"))
	{	*choice = SOAP_UNION__besfactory__union_ActivityStatusType_Failed;
		return a;
	}
	a->Finished = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTobesfactory__ActivityStateType(soap, "besfactory:Finished", &a->Finished, "besfactory:ActivityStateType"))
	{	*choice = SOAP_UNION__besfactory__union_ActivityStatusType_Finished;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, besfactory__GetFactoryAttributesDocumentResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, besfactory__GetFactoryAttributesDocumentResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentResponseType);
	if (soap_out_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, int id, besfactory__GetFactoryAttributesDocumentResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, besfactory__GetFactoryAttributesDocumentResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetFactoryAttributesDocumentResponseType(struct soap *soap, const char *tag, besfactory__GetFactoryAttributesDocumentResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetFactoryAttributesDocumentResponseType **)soap_malloc(soap, sizeof(besfactory__GetFactoryAttributesDocumentResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetFactoryAttributesDocumentResponseType *)soap_instantiate_besfactory__GetFactoryAttributesDocumentResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetFactoryAttributesDocumentResponseType ** p = (besfactory__GetFactoryAttributesDocumentResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType, sizeof(besfactory__GetFactoryAttributesDocumentResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetFactoryAttributesDocumentType(struct soap *soap, besfactory__GetFactoryAttributesDocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetFactoryAttributesDocumentType(struct soap *soap, besfactory__GetFactoryAttributesDocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetFactoryAttributesDocumentType);
	if (soap_out_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, int id, besfactory__GetFactoryAttributesDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetFactoryAttributesDocumentType(struct soap *soap, besfactory__GetFactoryAttributesDocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetFactoryAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetFactoryAttributesDocumentType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetFactoryAttributesDocumentType(struct soap *soap, const char *tag, besfactory__GetFactoryAttributesDocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetFactoryAttributesDocumentType **)soap_malloc(soap, sizeof(besfactory__GetFactoryAttributesDocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetFactoryAttributesDocumentType *)soap_instantiate_besfactory__GetFactoryAttributesDocumentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetFactoryAttributesDocumentType ** p = (besfactory__GetFactoryAttributesDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType, sizeof(besfactory__GetFactoryAttributesDocumentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetActivityDocumentsResponseType(struct soap *soap, besfactory__GetActivityDocumentsResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetActivityDocumentsResponseType(struct soap *soap, besfactory__GetActivityDocumentsResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsResponseType);
	if (soap_out_PointerTobesfactory__GetActivityDocumentsResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, int id, besfactory__GetActivityDocumentsResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetActivityDocumentsResponseType(struct soap *soap, besfactory__GetActivityDocumentsResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetActivityDocumentsResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetActivityDocumentsResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetActivityDocumentsResponseType(struct soap *soap, const char *tag, besfactory__GetActivityDocumentsResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetActivityDocumentsResponseType **)soap_malloc(soap, sizeof(besfactory__GetActivityDocumentsResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetActivityDocumentsResponseType *)soap_instantiate_besfactory__GetActivityDocumentsResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetActivityDocumentsResponseType ** p = (besfactory__GetActivityDocumentsResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType, sizeof(besfactory__GetActivityDocumentsResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetActivityDocumentsType(struct soap *soap, besfactory__GetActivityDocumentsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetActivityDocumentsType(struct soap *soap, besfactory__GetActivityDocumentsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentsType);
	if (soap_out_PointerTobesfactory__GetActivityDocumentsType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetActivityDocumentsType(struct soap *soap, const char *tag, int id, besfactory__GetActivityDocumentsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentsType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetActivityDocumentsType(struct soap *soap, besfactory__GetActivityDocumentsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetActivityDocumentsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetActivityDocumentsType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetActivityDocumentsType(struct soap *soap, const char *tag, besfactory__GetActivityDocumentsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetActivityDocumentsType **)soap_malloc(soap, sizeof(besfactory__GetActivityDocumentsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetActivityDocumentsType *)soap_instantiate_besfactory__GetActivityDocumentsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetActivityDocumentsType ** p = (besfactory__GetActivityDocumentsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType, sizeof(besfactory__GetActivityDocumentsType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__TerminateActivitiesResponseType(struct soap *soap, besfactory__TerminateActivitiesResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__TerminateActivitiesResponseType(struct soap *soap, besfactory__TerminateActivitiesResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesResponseType);
	if (soap_out_PointerTobesfactory__TerminateActivitiesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__TerminateActivitiesResponseType(struct soap *soap, const char *tag, int id, besfactory__TerminateActivitiesResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__TerminateActivitiesResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__TerminateActivitiesResponseType(struct soap *soap, besfactory__TerminateActivitiesResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__TerminateActivitiesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__TerminateActivitiesResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__TerminateActivitiesResponseType(struct soap *soap, const char *tag, besfactory__TerminateActivitiesResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__TerminateActivitiesResponseType **)soap_malloc(soap, sizeof(besfactory__TerminateActivitiesResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__TerminateActivitiesResponseType *)soap_instantiate_besfactory__TerminateActivitiesResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__TerminateActivitiesResponseType ** p = (besfactory__TerminateActivitiesResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType, sizeof(besfactory__TerminateActivitiesResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__TerminateActivitiesType(struct soap *soap, besfactory__TerminateActivitiesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__TerminateActivitiesType(struct soap *soap, besfactory__TerminateActivitiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivitiesType);
	if (soap_out_PointerTobesfactory__TerminateActivitiesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__TerminateActivitiesType(struct soap *soap, const char *tag, int id, besfactory__TerminateActivitiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__TerminateActivitiesType ** SOAP_FMAC4 soap_get_PointerTobesfactory__TerminateActivitiesType(struct soap *soap, besfactory__TerminateActivitiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__TerminateActivitiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__TerminateActivitiesType ** SOAP_FMAC4 soap_in_PointerTobesfactory__TerminateActivitiesType(struct soap *soap, const char *tag, besfactory__TerminateActivitiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__TerminateActivitiesType **)soap_malloc(soap, sizeof(besfactory__TerminateActivitiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__TerminateActivitiesType *)soap_instantiate_besfactory__TerminateActivitiesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__TerminateActivitiesType ** p = (besfactory__TerminateActivitiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType, sizeof(besfactory__TerminateActivitiesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetActivityStatusesResponseType(struct soap *soap, besfactory__GetActivityStatusesResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetActivityStatusesResponseType(struct soap *soap, besfactory__GetActivityStatusesResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesResponseType);
	if (soap_out_PointerTobesfactory__GetActivityStatusesResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetActivityStatusesResponseType(struct soap *soap, const char *tag, int id, besfactory__GetActivityStatusesResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusesResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetActivityStatusesResponseType(struct soap *soap, besfactory__GetActivityStatusesResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetActivityStatusesResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetActivityStatusesResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetActivityStatusesResponseType(struct soap *soap, const char *tag, besfactory__GetActivityStatusesResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetActivityStatusesResponseType **)soap_malloc(soap, sizeof(besfactory__GetActivityStatusesResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetActivityStatusesResponseType *)soap_instantiate_besfactory__GetActivityStatusesResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetActivityStatusesResponseType ** p = (besfactory__GetActivityStatusesResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType, sizeof(besfactory__GetActivityStatusesResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetActivityStatusesType(struct soap *soap, besfactory__GetActivityStatusesType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetActivityStatusesType(struct soap *soap, besfactory__GetActivityStatusesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusesType);
	if (soap_out_PointerTobesfactory__GetActivityStatusesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetActivityStatusesType(struct soap *soap, const char *tag, int id, besfactory__GetActivityStatusesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusesType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetActivityStatusesType(struct soap *soap, besfactory__GetActivityStatusesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetActivityStatusesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetActivityStatusesType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetActivityStatusesType(struct soap *soap, const char *tag, besfactory__GetActivityStatusesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetActivityStatusesType **)soap_malloc(soap, sizeof(besfactory__GetActivityStatusesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetActivityStatusesType *)soap_instantiate_besfactory__GetActivityStatusesType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetActivityStatusesType ** p = (besfactory__GetActivityStatusesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType, sizeof(besfactory__GetActivityStatusesType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__CreateActivityResponseType(struct soap *soap, besfactory__CreateActivityResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__CreateActivityResponseType(struct soap *soap, besfactory__CreateActivityResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityResponseType);
	if (soap_out_PointerTobesfactory__CreateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__CreateActivityResponseType(struct soap *soap, const char *tag, int id, besfactory__CreateActivityResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__CreateActivityResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__CreateActivityResponseType(struct soap *soap, besfactory__CreateActivityResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__CreateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__CreateActivityResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__CreateActivityResponseType(struct soap *soap, const char *tag, besfactory__CreateActivityResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__CreateActivityResponseType **)soap_malloc(soap, sizeof(besfactory__CreateActivityResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__CreateActivityResponseType *)soap_instantiate_besfactory__CreateActivityResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__CreateActivityResponseType ** p = (besfactory__CreateActivityResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType, sizeof(besfactory__CreateActivityResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__CreateActivityType(struct soap *soap, besfactory__CreateActivityType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__CreateActivityType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__CreateActivityType(struct soap *soap, besfactory__CreateActivityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__CreateActivityType);
	if (soap_out_PointerTobesfactory__CreateActivityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__CreateActivityType(struct soap *soap, const char *tag, int id, besfactory__CreateActivityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__CreateActivityType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__CreateActivityType ** SOAP_FMAC4 soap_get_PointerTobesfactory__CreateActivityType(struct soap *soap, besfactory__CreateActivityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__CreateActivityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__CreateActivityType ** SOAP_FMAC4 soap_in_PointerTobesfactory__CreateActivityType(struct soap *soap, const char *tag, besfactory__CreateActivityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__CreateActivityType **)soap_malloc(soap, sizeof(besfactory__CreateActivityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__CreateActivityType *)soap_instantiate_besfactory__CreateActivityType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__CreateActivityType ** p = (besfactory__CreateActivityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__CreateActivityType, sizeof(besfactory__CreateActivityType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_besfactory_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__SourceTarget_USCOREType);
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, jsdl__SourceTarget_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__SourceTarget_USCOREType **)soap_malloc(soap, sizeof(jsdl__SourceTarget_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__SourceTarget_USCOREType *)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__SourceTarget_USCOREType ** p = (jsdl__SourceTarget_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerToxsd__NCName);
	if (soap_out_PointerToxsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_xsd__NCName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__NCName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystemType_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystemType_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystemType_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystemType_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystemType_USCOREType *)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystemType_USCOREType ** p = (jsdl__OperatingSystemType_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__FileSystemTypeEnumeration);
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, enum jsdl__FileSystemTypeEnumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum jsdl__FileSystemTypeEnumeration **)soap_malloc(soap, sizeof(enum jsdl__FileSystemTypeEnumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__RangeValue_USCOREType);
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, jsdl__RangeValue_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__RangeValue_USCOREType **)soap_malloc(soap, sizeof(jsdl__RangeValue_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__RangeValue_USCOREType *)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__RangeValue_USCOREType ** p = (jsdl__RangeValue_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_besfactory_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__FileSystem_USCOREType);
	if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__FileSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__FileSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__FileSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__FileSystem_USCOREType *)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__FileSystem_USCOREType ** p = (jsdl__FileSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__CandidateHosts_USCOREType);
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CandidateHosts_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CandidateHosts_USCOREType **)soap_malloc(soap, sizeof(jsdl__CandidateHosts_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CandidateHosts_USCOREType *)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CandidateHosts_USCOREType ** p = (jsdl__CandidateHosts_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__Description_USCOREType))
		soap_serialize_jsdl__Description_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__Description_USCOREType);
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__Description_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Description_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Description_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Description_USCOREType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__DataStaging_USCOREType);
	if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, jsdl__DataStaging_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__DataStaging_USCOREType **)soap_malloc(soap, sizeof(jsdl__DataStaging_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__DataStaging_USCOREType *)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__DataStaging_USCOREType ** p = (jsdl__DataStaging_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__Resources_USCOREType);
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Resources_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Resources_USCOREType **)soap_malloc(soap, sizeof(jsdl__Resources_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Resources_USCOREType *)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Resources_USCOREType ** p = (jsdl__Resources_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__Application_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__Application_USCOREType);
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Application_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__Application_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Application_USCOREType **)soap_malloc(soap, sizeof(jsdl__Application_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Application_USCOREType *)soap_instantiate_jsdl__Application_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Application_USCOREType ** p = (jsdl__Application_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__JobIdentification_USCOREType);
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobIdentification_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobIdentification_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobIdentification_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobIdentification_USCOREType *)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobIdentification_USCOREType ** p = (jsdl__JobIdentification_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_xsd__ID))
		soap_serialize_xsd__ID(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerToxsd__ID);
	if (soap_out_PointerToxsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_xsd__ID);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__ID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__ID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__JobDescription_USCOREType);
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDescription_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDescription_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDescription_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDescription_USCOREType *)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDescription_USCOREType ** p = (jsdl__JobDescription_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__Range_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__Range_USCOREType);
	if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Range_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__Range_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Range_USCOREType **)soap_malloc(soap, sizeof(jsdl__Range_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Range_USCOREType *)soap_instantiate_jsdl__Range_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Range_USCOREType ** p = (jsdl__Range_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__Exact_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__Exact_USCOREType);
	if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Exact_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__Exact_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Exact_USCOREType **)soap_malloc(soap, sizeof(jsdl__Exact_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Exact_USCOREType *)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Exact_USCOREType ** p = (jsdl__Exact_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__Boundary_USCOREType);
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Boundary_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Boundary_USCOREType **)soap_malloc(soap, sizeof(jsdl__Boundary_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Boundary_USCOREType *)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Boundary_USCOREType ** p = (jsdl__Boundary_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory2__MetadataType(struct soap *soap, besfactory2__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory2__MetadataType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory2__MetadataType(struct soap *soap, besfactory2__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory2__MetadataType);
	if (soap_out_PointerTobesfactory2__MetadataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory2__MetadataType(struct soap *soap, const char *tag, int id, besfactory2__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory2__MetadataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory2__MetadataType ** SOAP_FMAC4 soap_get_PointerTobesfactory2__MetadataType(struct soap *soap, besfactory2__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory2__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory2__MetadataType ** SOAP_FMAC4 soap_in_PointerTobesfactory2__MetadataType(struct soap *soap, const char *tag, besfactory2__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory2__MetadataType **)soap_malloc(soap, sizeof(besfactory2__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory2__MetadataType *)soap_instantiate_besfactory2__MetadataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory2__MetadataType ** p = (besfactory2__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__MetadataType, sizeof(besfactory2__MetadataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory2__ReferenceParametersType(struct soap *soap, besfactory2__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory2__ReferenceParametersType(struct soap *soap, besfactory2__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory2__ReferenceParametersType);
	if (soap_out_PointerTobesfactory2__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory2__ReferenceParametersType(struct soap *soap, const char *tag, int id, besfactory2__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory2__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTobesfactory2__ReferenceParametersType(struct soap *soap, besfactory2__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory2__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory2__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTobesfactory2__ReferenceParametersType(struct soap *soap, const char *tag, besfactory2__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory2__ReferenceParametersType **)soap_malloc(soap, sizeof(besfactory2__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory2__ReferenceParametersType *)soap_instantiate_besfactory2__ReferenceParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory2__ReferenceParametersType ** p = (besfactory2__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType, sizeof(besfactory2__ReferenceParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory2__AttributedURIType(struct soap *soap, besfactory2__AttributedURIType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory2__AttributedURIType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory2__AttributedURIType(struct soap *soap, besfactory2__AttributedURIType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory2__AttributedURIType);
	if (soap_out_PointerTobesfactory2__AttributedURIType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory2__AttributedURIType(struct soap *soap, const char *tag, int id, besfactory2__AttributedURIType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory2__AttributedURIType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory2__AttributedURIType ** SOAP_FMAC4 soap_get_PointerTobesfactory2__AttributedURIType(struct soap *soap, besfactory2__AttributedURIType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory2__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory2__AttributedURIType ** SOAP_FMAC4 soap_in_PointerTobesfactory2__AttributedURIType(struct soap *soap, const char *tag, besfactory2__AttributedURIType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory2__AttributedURIType **)soap_malloc(soap, sizeof(besfactory2__AttributedURIType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory2__AttributedURIType *)soap_instantiate_besfactory2__AttributedURIType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory2__AttributedURIType ** p = (besfactory2__AttributedURIType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__AttributedURIType, sizeof(besfactory2__AttributedURIType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__FactoryResourceAttributesDocumentType(struct soap *soap, besfactory__FactoryResourceAttributesDocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__FactoryResourceAttributesDocumentType(struct soap *soap, besfactory__FactoryResourceAttributesDocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__FactoryResourceAttributesDocumentType);
	if (soap_out_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, int id, besfactory__FactoryResourceAttributesDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__FactoryResourceAttributesDocumentType ** SOAP_FMAC4 soap_get_PointerTobesfactory__FactoryResourceAttributesDocumentType(struct soap *soap, besfactory__FactoryResourceAttributesDocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__FactoryResourceAttributesDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__FactoryResourceAttributesDocumentType ** SOAP_FMAC4 soap_in_PointerTobesfactory__FactoryResourceAttributesDocumentType(struct soap *soap, const char *tag, besfactory__FactoryResourceAttributesDocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__FactoryResourceAttributesDocumentType **)soap_malloc(soap, sizeof(besfactory__FactoryResourceAttributesDocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__FactoryResourceAttributesDocumentType *)soap_instantiate_besfactory__FactoryResourceAttributesDocumentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__FactoryResourceAttributesDocumentType ** p = (besfactory__FactoryResourceAttributesDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType, sizeof(besfactory__FactoryResourceAttributesDocumentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, besfactory__GetActivityDocumentResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, besfactory__GetActivityDocumentResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityDocumentResponseType);
	if (soap_out_PointerTobesfactory__GetActivityDocumentResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, const char *tag, int id, besfactory__GetActivityDocumentResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetActivityDocumentResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, besfactory__GetActivityDocumentResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetActivityDocumentResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetActivityDocumentResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, const char *tag, besfactory__GetActivityDocumentResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetActivityDocumentResponseType **)soap_malloc(soap, sizeof(besfactory__GetActivityDocumentResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetActivityDocumentResponseType *)soap_instantiate_besfactory__GetActivityDocumentResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetActivityDocumentResponseType ** p = (besfactory__GetActivityDocumentResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType, sizeof(besfactory__GetActivityDocumentResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__TerminateActivityResponseType(struct soap *soap, besfactory__TerminateActivityResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__TerminateActivityResponseType(struct soap *soap, besfactory__TerminateActivityResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__TerminateActivityResponseType);
	if (soap_out_PointerTobesfactory__TerminateActivityResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__TerminateActivityResponseType(struct soap *soap, const char *tag, int id, besfactory__TerminateActivityResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__TerminateActivityResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__TerminateActivityResponseType(struct soap *soap, besfactory__TerminateActivityResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__TerminateActivityResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__TerminateActivityResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__TerminateActivityResponseType(struct soap *soap, const char *tag, besfactory__TerminateActivityResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__TerminateActivityResponseType **)soap_malloc(soap, sizeof(besfactory__TerminateActivityResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__TerminateActivityResponseType *)soap_instantiate_besfactory__TerminateActivityResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__TerminateActivityResponseType ** p = (besfactory__TerminateActivityResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType, sizeof(besfactory__TerminateActivityResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, besfactory__GetActivityStatusResponseType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, besfactory__GetActivityStatusResponseType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__GetActivityStatusResponseType);
	if (soap_out_PointerTobesfactory__GetActivityStatusResponseType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, const char *tag, int id, besfactory__GetActivityStatusResponseType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__GetActivityStatusResponseType ** SOAP_FMAC4 soap_get_PointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, besfactory__GetActivityStatusResponseType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__GetActivityStatusResponseType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__GetActivityStatusResponseType ** SOAP_FMAC4 soap_in_PointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, const char *tag, besfactory__GetActivityStatusResponseType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__GetActivityStatusResponseType **)soap_malloc(soap, sizeof(besfactory__GetActivityStatusResponseType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__GetActivityStatusResponseType *)soap_instantiate_besfactory__GetActivityStatusResponseType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__GetActivityStatusResponseType ** p = (besfactory__GetActivityStatusResponseType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType, sizeof(besfactory__GetActivityStatusResponseType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__ActivityDocumentType(struct soap *soap, besfactory__ActivityDocumentType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__ActivityDocumentType(struct soap *soap, besfactory__ActivityDocumentType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__ActivityDocumentType);
	if (soap_out_PointerTobesfactory__ActivityDocumentType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__ActivityDocumentType(struct soap *soap, const char *tag, int id, besfactory__ActivityDocumentType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__ActivityDocumentType ** SOAP_FMAC4 soap_get_PointerTobesfactory__ActivityDocumentType(struct soap *soap, besfactory__ActivityDocumentType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__ActivityDocumentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__ActivityDocumentType ** SOAP_FMAC4 soap_in_PointerTobesfactory__ActivityDocumentType(struct soap *soap, const char *tag, besfactory__ActivityDocumentType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__ActivityDocumentType **)soap_malloc(soap, sizeof(besfactory__ActivityDocumentType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__ActivityDocumentType *)soap_instantiate_besfactory__ActivityDocumentType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__ActivityDocumentType ** p = (besfactory__ActivityDocumentType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType, sizeof(besfactory__ActivityDocumentType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__ID_, sizeof(xsd__ID_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__NCName_, sizeof(xsd__NCName_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__QName_, sizeof(xsd__QName_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__anyURI_, sizeof(xsd__anyURI_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__double, sizeof(xsd__double), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__unsignedInt, sizeof(xsd__unsignedInt), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_xsd__unsignedLong, sizeof(xsd__unsignedLong), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__RelationshipType_, sizeof(besfactory2__RelationshipType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__FaultCodesType_, sizeof(besfactory2__FaultCodesType_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__ProcessorArchitectureEnumeration_, sizeof(jsdl__ProcessorArchitectureEnumeration_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__OperatingSystemTypeEnumeration_, sizeof(jsdl__OperatingSystemTypeEnumeration_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__FileSystemTypeEnumeration_, sizeof(jsdl__FileSystemTypeEnumeration_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__CreationFlagEnumeration_, sizeof(jsdl__CreationFlagEnumeration_), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Description_USCOREType__, sizeof(jsdl__Description_USCOREType__), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__BasicFactoryResourceAttributesDocumentType, sizeof(besfactory__BasicFactoryResourceAttributesDocumentType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__ActivityDocumentType, sizeof(besfactory__ActivityDocumentType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__ActivityStateType, sizeof(besfactory__ActivityStateType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__ActivityStatusType, sizeof(besfactory__ActivityStatusType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType, sizeof(besfactory__GetActivityStatusResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType, sizeof(besfactory__GetActivityDocumentResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType, sizeof(besfactory__TerminateActivityResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__CreateActivityType, sizeof(besfactory__CreateActivityType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__CreateActivityResponseType, sizeof(besfactory__CreateActivityResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesType, sizeof(besfactory__GetActivityStatusesType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityStatusesResponseType, sizeof(besfactory__GetActivityStatusesResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesType, sizeof(besfactory__TerminateActivitiesType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__TerminateActivitiesResponseType, sizeof(besfactory__TerminateActivitiesResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsType, sizeof(besfactory__GetActivityDocumentsType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetActivityDocumentsResponseType, sizeof(besfactory__GetActivityDocumentsResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentType, sizeof(besfactory__GetFactoryAttributesDocumentType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__GetFactoryAttributesDocumentResponseType, sizeof(besfactory__GetFactoryAttributesDocumentResponseType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__NotAcceptingNewActivitiesFaultType, sizeof(besfactory__NotAcceptingNewActivitiesFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__UnsupportedJSDLVersionFaultType, sizeof(besfactory__UnsupportedJSDLVersionFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__UnsupportedFeatureFaultType, sizeof(besfactory__UnsupportedFeatureFaultType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType, sizeof(besfactory2__EndpointReferenceType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__ReferenceParametersType, sizeof(besfactory2__ReferenceParametersType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__MetadataType, sizeof(besfactory2__MetadataType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__AttributedAnyType, sizeof(besfactory2__AttributedAnyType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__ProblemActionType, sizeof(besfactory2__ProblemActionType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__FactoryResourceAttributesDocumentType, sizeof(besfactory__FactoryResourceAttributesDocumentType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__RelatesToType, sizeof(besfactory2__RelatesToType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__AttributedURIType, sizeof(besfactory2__AttributedURIType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__AttributedUnsignedLongType, sizeof(besfactory2__AttributedUnsignedLongType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__AttributedQNameType, sizeof(besfactory2__AttributedQNameType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__ActivityStatusType(struct soap *soap, besfactory__ActivityStatusType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__ActivityStatusType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__ActivityStatusType(struct soap *soap, besfactory__ActivityStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStatusType);
	if (soap_out_PointerTobesfactory__ActivityStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__ActivityStatusType(struct soap *soap, const char *tag, int id, besfactory__ActivityStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__ActivityStatusType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__ActivityStatusType ** SOAP_FMAC4 soap_get_PointerTobesfactory__ActivityStatusType(struct soap *soap, besfactory__ActivityStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__ActivityStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__ActivityStatusType ** SOAP_FMAC4 soap_in_PointerTobesfactory__ActivityStatusType(struct soap *soap, const char *tag, besfactory__ActivityStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__ActivityStatusType **)soap_malloc(soap, sizeof(besfactory__ActivityStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__ActivityStatusType *)soap_instantiate_besfactory__ActivityStatusType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__ActivityStatusType ** p = (besfactory__ActivityStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__ActivityStatusType, sizeof(besfactory__ActivityStatusType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory2__EndpointReferenceType(struct soap *soap, besfactory2__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory2__EndpointReferenceType(struct soap *soap, besfactory2__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory2__EndpointReferenceType);
	if (soap_out_PointerTobesfactory2__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory2__EndpointReferenceType(struct soap *soap, const char *tag, int id, besfactory2__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory2__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTobesfactory2__EndpointReferenceType(struct soap *soap, besfactory2__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory2__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory2__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTobesfactory2__EndpointReferenceType(struct soap *soap, const char *tag, besfactory2__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory2__EndpointReferenceType **)soap_malloc(soap, sizeof(besfactory2__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory2__EndpointReferenceType *)soap_instantiate_besfactory2__EndpointReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory2__EndpointReferenceType ** p = (besfactory2__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType, sizeof(besfactory2__EndpointReferenceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobesfactory__ActivityStateType(struct soap *soap, besfactory__ActivityStateType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_besfactory__ActivityStateType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobesfactory__ActivityStateType(struct soap *soap, besfactory__ActivityStateType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTobesfactory__ActivityStateType);
	if (soap_out_PointerTobesfactory__ActivityStateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobesfactory__ActivityStateType(struct soap *soap, const char *tag, int id, besfactory__ActivityStateType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_besfactory__ActivityStateType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 besfactory__ActivityStateType ** SOAP_FMAC4 soap_get_PointerTobesfactory__ActivityStateType(struct soap *soap, besfactory__ActivityStateType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobesfactory__ActivityStateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 besfactory__ActivityStateType ** SOAP_FMAC4 soap_in_PointerTobesfactory__ActivityStateType(struct soap *soap, const char *tag, besfactory__ActivityStateType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (besfactory__ActivityStateType **)soap_malloc(soap, sizeof(besfactory__ActivityStateType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (besfactory__ActivityStateType *)soap_instantiate_besfactory__ActivityStateType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	besfactory__ActivityStateType ** p = (besfactory__ActivityStateType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_besfactory__ActivityStateType, sizeof(besfactory__ActivityStateType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__JobDefinition_USCOREType);
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDefinition_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDefinition_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDefinition_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDefinition_USCOREType *)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDefinition_USCOREType ** p = (jsdl__JobDefinition_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_besfactory_unsignedLONG64);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_besfactory_unsignedInt);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTounsignedInt);
	if (soap_out_PointerTounsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_unsignedInt);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_unsignedInt, sizeof(unsigned int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__CPUArchitecture_USCOREType);
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CPUArchitecture_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CPUArchitecture_USCOREType **)soap_malloc(soap, sizeof(jsdl__CPUArchitecture_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CPUArchitecture_USCOREType *)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CPUArchitecture_USCOREType ** p = (jsdl__CPUArchitecture_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_PointerTojsdl__OperatingSystem_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystem_USCOREType *)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystem_USCOREType ** p = (jsdl__OperatingSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_besfactory_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_besfactory__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_besfactory__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_besfactory_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_besfactory_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_besfactory_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_besfactory_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, std::vector<xsd__anyType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const std::vector<xsd__anyType * >*a)
{
	for (std::vector<xsd__anyType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToxsd__anyType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const char *tag, int id, const std::vector<xsd__anyType * >*a, const char *type)
{
	for (std::vector<xsd__anyType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToxsd__anyType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xsd__anyType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, const char *tag, std::vector<xsd__anyType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToxsd__anyType(soap, -1)))
		return NULL;
	xsd__anyType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_xsd__anyType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerToxsd__anyType, sizeof(xsd__anyType), 1))
				break;
			if (!soap_in_PointerToxsd__anyType(soap, tag, NULL, "xsd:anyType"))
				break;
		}
		else
		{
			if (!soap_in_PointerToxsd__anyType(soap, tag, &n, "xsd:anyType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<xsd__anyType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, std::vector<xsd__anyType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<xsd__anyType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToxsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerToxsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<xsd__anyType * >;
		if (size)
			*size = sizeof(std::vector<xsd__anyType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<xsd__anyType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<xsd__anyType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<xsd__anyType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToxsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<xsd__anyType * > %p -> %p\n", q, p));
	*(std::vector<xsd__anyType * >*)p = *(std::vector<xsd__anyType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, std::vector<jsdl__FileSystem_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const std::vector<jsdl__FileSystem_USCOREType * >*a)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__FileSystem_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1)))
		return NULL;
	jsdl__FileSystem_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_jsdl__FileSystem_USCOREType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, NULL, "jsdl:FileSystem_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, &n, "jsdl:FileSystem_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__FileSystem_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, std::vector<jsdl__FileSystem_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__FileSystem_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__FileSystem_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__FileSystem_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__FileSystem_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__FileSystem_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__FileSystem_USCOREType * >*)p = *(std::vector<jsdl__FileSystem_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, std::vector<jsdl__DataStaging_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const std::vector<jsdl__DataStaging_USCOREType * >*a)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__DataStaging_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1)))
		return NULL;
	jsdl__DataStaging_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_jsdl__DataStaging_USCOREType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, NULL, "jsdl:DataStaging_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, &n, "jsdl:DataStaging_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__DataStaging_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, std::vector<jsdl__DataStaging_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__DataStaging_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__DataStaging_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__DataStaging_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__DataStaging_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__DataStaging_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__DataStaging_USCOREType * >*)p = *(std::vector<jsdl__DataStaging_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, std::vector<jsdl__Range_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const std::vector<jsdl__Range_USCOREType * >*a)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Range_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1)))
		return NULL;
	jsdl__Range_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_jsdl__Range_USCOREType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, NULL, "jsdl:Range_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, &n, "jsdl:Range_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__Range_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, std::vector<jsdl__Range_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__Range_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__Range_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__Range_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Range_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Range_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Range_USCOREType * >*)p = *(std::vector<jsdl__Range_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, std::vector<jsdl__Exact_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const std::vector<jsdl__Exact_USCOREType * >*a)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Exact_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1)))
		return NULL;
	jsdl__Exact_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_jsdl__Exact_USCOREType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, NULL, "jsdl:Exact_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, &n, "jsdl:Exact_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__Exact_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, std::vector<jsdl__Exact_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__Exact_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__Exact_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__Exact_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Exact_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Exact_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Exact_USCOREType * >*)p = *(std::vector<jsdl__Exact_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_std__string, SOAP_TYPE_besfactory_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, std::vector<besfactory__GetActivityDocumentResponseType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, const std::vector<besfactory__GetActivityDocumentResponseType * >*a)
{
	for (std::vector<besfactory__GetActivityDocumentResponseType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobesfactory__GetActivityDocumentResponseType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, const char *tag, int id, const std::vector<besfactory__GetActivityDocumentResponseType * >*a, const char *type)
{
	for (std::vector<besfactory__GetActivityDocumentResponseType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobesfactory__GetActivityDocumentResponseType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<besfactory__GetActivityDocumentResponseType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, const char *tag, std::vector<besfactory__GetActivityDocumentResponseType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(soap, -1)))
		return NULL;
	besfactory__GetActivityDocumentResponseType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_besfactory__GetActivityDocumentResponseType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType, sizeof(besfactory__GetActivityDocumentResponseType), 1))
				break;
			if (!soap_in_PointerTobesfactory__GetActivityDocumentResponseType(soap, tag, NULL, "besfactory:GetActivityDocumentResponseType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobesfactory__GetActivityDocumentResponseType(soap, tag, &n, "besfactory:GetActivityDocumentResponseType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<besfactory__GetActivityDocumentResponseType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, std::vector<besfactory__GetActivityDocumentResponseType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<besfactory__GetActivityDocumentResponseType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<besfactory__GetActivityDocumentResponseType * >;
		if (size)
			*size = sizeof(std::vector<besfactory__GetActivityDocumentResponseType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<besfactory__GetActivityDocumentResponseType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<besfactory__GetActivityDocumentResponseType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<besfactory__GetActivityDocumentResponseType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobesfactory__GetActivityDocumentResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<besfactory__GetActivityDocumentResponseType * > %p -> %p\n", q, p));
	*(std::vector<besfactory__GetActivityDocumentResponseType * >*)p = *(std::vector<besfactory__GetActivityDocumentResponseType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, std::vector<besfactory__TerminateActivityResponseType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, const std::vector<besfactory__TerminateActivityResponseType * >*a)
{
	for (std::vector<besfactory__TerminateActivityResponseType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobesfactory__TerminateActivityResponseType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, const char *tag, int id, const std::vector<besfactory__TerminateActivityResponseType * >*a, const char *type)
{
	for (std::vector<besfactory__TerminateActivityResponseType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobesfactory__TerminateActivityResponseType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<besfactory__TerminateActivityResponseType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, const char *tag, std::vector<besfactory__TerminateActivityResponseType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(soap, -1)))
		return NULL;
	besfactory__TerminateActivityResponseType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_besfactory__TerminateActivityResponseType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType, sizeof(besfactory__TerminateActivityResponseType), 1))
				break;
			if (!soap_in_PointerTobesfactory__TerminateActivityResponseType(soap, tag, NULL, "besfactory:TerminateActivityResponseType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobesfactory__TerminateActivityResponseType(soap, tag, &n, "besfactory:TerminateActivityResponseType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<besfactory__TerminateActivityResponseType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, std::vector<besfactory__TerminateActivityResponseType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<besfactory__TerminateActivityResponseType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<besfactory__TerminateActivityResponseType * >;
		if (size)
			*size = sizeof(std::vector<besfactory__TerminateActivityResponseType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<besfactory__TerminateActivityResponseType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<besfactory__TerminateActivityResponseType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<besfactory__TerminateActivityResponseType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobesfactory__TerminateActivityResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<besfactory__TerminateActivityResponseType * > %p -> %p\n", q, p));
	*(std::vector<besfactory__TerminateActivityResponseType * >*)p = *(std::vector<besfactory__TerminateActivityResponseType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, std::vector<besfactory__GetActivityStatusResponseType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, const std::vector<besfactory__GetActivityStatusResponseType * >*a)
{
	for (std::vector<besfactory__GetActivityStatusResponseType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobesfactory__GetActivityStatusResponseType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, const char *tag, int id, const std::vector<besfactory__GetActivityStatusResponseType * >*a, const char *type)
{
	for (std::vector<besfactory__GetActivityStatusResponseType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobesfactory__GetActivityStatusResponseType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<besfactory__GetActivityStatusResponseType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, const char *tag, std::vector<besfactory__GetActivityStatusResponseType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(soap, -1)))
		return NULL;
	besfactory__GetActivityStatusResponseType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_besfactory__GetActivityStatusResponseType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType, sizeof(besfactory__GetActivityStatusResponseType), 1))
				break;
			if (!soap_in_PointerTobesfactory__GetActivityStatusResponseType(soap, tag, NULL, "besfactory:GetActivityStatusResponseType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobesfactory__GetActivityStatusResponseType(soap, tag, &n, "besfactory:GetActivityStatusResponseType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<besfactory__GetActivityStatusResponseType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, std::vector<besfactory__GetActivityStatusResponseType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<besfactory__GetActivityStatusResponseType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<besfactory__GetActivityStatusResponseType * >;
		if (size)
			*size = sizeof(std::vector<besfactory__GetActivityStatusResponseType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<besfactory__GetActivityStatusResponseType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<besfactory__GetActivityStatusResponseType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<besfactory__GetActivityStatusResponseType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobesfactory__GetActivityStatusResponseType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<besfactory__GetActivityStatusResponseType * > %p -> %p\n", q, p));
	*(std::vector<besfactory__GetActivityStatusResponseType * >*)p = *(std::vector<besfactory__GetActivityStatusResponseType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, std::vector<besfactory2__EndpointReferenceType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, const std::vector<besfactory2__EndpointReferenceType * >*a)
{
	for (std::vector<besfactory2__EndpointReferenceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobesfactory2__EndpointReferenceType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, const char *tag, int id, const std::vector<besfactory2__EndpointReferenceType * >*a, const char *type)
{
	for (std::vector<besfactory2__EndpointReferenceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobesfactory2__EndpointReferenceType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<besfactory2__EndpointReferenceType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, const char *tag, std::vector<besfactory2__EndpointReferenceType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, -1)))
		return NULL;
	besfactory2__EndpointReferenceType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory_besfactory2__EndpointReferenceType, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType, sizeof(besfactory2__EndpointReferenceType), 1))
				break;
			if (!soap_in_PointerTobesfactory2__EndpointReferenceType(soap, tag, NULL, "besfactory2:EndpointReferenceType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobesfactory2__EndpointReferenceType(soap, tag, &n, "besfactory2:EndpointReferenceType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<besfactory2__EndpointReferenceType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, std::vector<besfactory2__EndpointReferenceType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<besfactory2__EndpointReferenceType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<besfactory2__EndpointReferenceType * >;
		if (size)
			*size = sizeof(std::vector<besfactory2__EndpointReferenceType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<besfactory2__EndpointReferenceType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<besfactory2__EndpointReferenceType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<besfactory2__EndpointReferenceType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobesfactory2__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<besfactory2__EndpointReferenceType * > %p -> %p\n", q, p));
	*(std::vector<besfactory2__EndpointReferenceType * >*)p = *(std::vector<besfactory2__EndpointReferenceType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_besfactory__XML, SOAP_TYPE_besfactory_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_besfactory_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

} // namespace besfactory


/* End of besfactoryC.cpp */
