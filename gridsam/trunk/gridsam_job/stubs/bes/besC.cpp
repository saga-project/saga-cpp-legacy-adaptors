/* besC.cpp
   Generated by gSOAP 2.7.11 from ./wsdl/wsdl/basic-execution-service.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "besH.h"

namespace bes {

SOAP_SOURCE_STAMP("@(#) besC.cpp ver 2.7.11 2008-09-23 14:41:30 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_bes_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_bes_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bes_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bes_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_bes_jsdl__CreationFlagEnumeration:
		return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration:
		return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration:
		return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration:
		return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_bes_addressing__FaultCodesType:
		return soap_in_addressing__FaultCodesType(soap, NULL, NULL, "addressing:FaultCodesType");
	case SOAP_TYPE_bes_addressing__RelationshipType:
		return soap_in_addressing__RelationshipType(soap, NULL, NULL, "addressing:RelationshipType");
	case SOAP_TYPE_bes_bes__state_change_response_enumeration:
		return soap_in_bes__state_change_response_enumeration(soap, NULL, NULL, "bes:state-change-response-enumeration");
	case SOAP_TYPE_bes_bes__data_staging_state_enumeration:
		return soap_in_bes__data_staging_state_enumeration(soap, NULL, NULL, "bes:data-staging-state-enumeration");
	case SOAP_TYPE_bes_bes__overall_state_enumeration:
		return soap_in_bes__overall_state_enumeration(soap, NULL, NULL, "bes:overall-state-enumeration");
	case SOAP_TYPE_bes_jsdl__Description_USCOREType:
		return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType:
		return soap_in_addressing__FaultCodesOpenEnumType(soap, NULL, NULL, "addressing:FaultCodesOpenEnumType");
	case SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum:
		return soap_in_addressing__RelationshipTypeOpenEnum(soap, NULL, NULL, "addressing:RelationshipTypeOpenEnum");
	case SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType:
		return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_bes_jsdl__DataStaging_USCOREType:
		return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType:
		return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType:
		return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_bes_jsdl__FileSystem_USCOREType:
		return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType:
		return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType:
		return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_bes_jsdl__Resources_USCOREType:
		return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_bes_jsdl__Application_USCOREType:
		return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType:
		return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_bes_jsdl__JobDescription_USCOREType:
		return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType:
		return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_bes_jsdl__RangeValue_USCOREType:
		return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_bes_jsdl__Range_USCOREType:
		return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_bes_jsdl__Exact_USCOREType:
		return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_bes_jsdl__Boundary_USCOREType:
		return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType:
		return soap_in_addressing__AttributedNonNegativeIntegerType(soap, NULL, NULL, "addressing:AttributedNonNegativeIntegerType");
	case SOAP_TYPE_bes_addressing__AttributedURIType:
		return soap_in_addressing__AttributedURIType(soap, NULL, NULL, "addressing:AttributedURIType");
	case SOAP_TYPE_bes_addressing__RelatesToType:
		return soap_in_addressing__RelatesToType(soap, NULL, NULL, "addressing:RelatesToType");
	case SOAP_TYPE_bes_addressing__MetadataType:
		return soap_in_addressing__MetadataType(soap, NULL, NULL, "addressing:MetadataType");
	case SOAP_TYPE_bes_addressing__ReferenceParametersType:
		return soap_in_addressing__ReferenceParametersType(soap, NULL, NULL, "addressing:ReferenceParametersType");
	case SOAP_TYPE_bes_addressing__EndpointReferenceType:
		return soap_in_addressing__EndpointReferenceType(soap, NULL, NULL, "addressing:EndpointReferenceType");
	case SOAP_TYPE_bes_bes__BackendFaultType:
		return soap_in_bes__BackendFaultType(soap, NULL, NULL, "bes:BackendFaultType");
	case SOAP_TYPE_bes_bes__JobSpecificationFaultType:
		return soap_in_bes__JobSpecificationFaultType(soap, NULL, NULL, "bes:JobSpecificationFaultType");
	case SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType:
		return soap_in_bes__UnsupportedFeatureFaultType(soap, NULL, NULL, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType:
		return soap_in_bes__UnsupportedJSDLFaultType(soap, NULL, NULL, "bes:UnsupportedJSDLFaultType");
	case SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType:
		return soap_in_bes__BadlyFormedJSDLDocumentFaultType(soap, NULL, NULL, "bes:BadlyFormedJSDLDocumentFaultType");
	case SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType:
		return soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_bes_bes__activity_jsdl_document_type:
		return soap_in_bes__activity_jsdl_document_type(soap, NULL, NULL, "bes:activity-jsdl-document-type");
	case SOAP_TYPE_bes_bes__state_change_response_type:
		return soap_in_bes__state_change_response_type(soap, NULL, NULL, "bes:state-change-response-type");
	case SOAP_TYPE_bes_bes__state_change_request_type:
		return soap_in_bes__state_change_request_type(soap, NULL, NULL, "bes:state-change-request-type");
	case SOAP_TYPE_bes_bes__requested_state_change_type:
		return soap_in_bes__requested_state_change_type(soap, NULL, NULL, "bes:requested-state-change-type");
	case SOAP_TYPE_bes_bes__activity_status_type:
		return soap_in_bes__activity_status_type(soap, NULL, NULL, "bes:activity-status-type");
	case SOAP_TYPE_bes_bes__data_stage_status_type:
		return soap_in_bes__data_stage_status_type(soap, NULL, NULL, "bes:data-stage-status-type");
	case SOAP_TYPE_bes_bes__overall_status_type:
		return soap_in_bes__overall_status_type(soap, NULL, NULL, "bes:overall-status-type");
	case SOAP_TYPE_bes_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_bes_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_bes_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_bes_xsd__NCName:
		return soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_bes_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_bes_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocumentsResponse:
		return soap_in_PointerTo_bes__GetActivityJSDLDocumentsResponse(soap, NULL, NULL, "bes:GetActivityJSDLDocumentsResponse");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocuments:
		return soap_in_PointerTo_bes__GetActivityJSDLDocuments(soap, NULL, NULL, "bes:GetActivityJSDLDocuments");
	case SOAP_TYPE_bes_PointerTo_bes__IsAcceptingNewActivitiesResponse:
		return soap_in_PointerTo_bes__IsAcceptingNewActivitiesResponse(soap, NULL, NULL, "bes:IsAcceptingNewActivitiesResponse");
	case SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChangesResponse:
		return soap_in_PointerTo_bes__RequestActivityStateChangesResponse(soap, NULL, NULL, "bes:RequestActivityStateChangesResponse");
	case SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChanges:
		return soap_in_PointerTo_bes__RequestActivityStateChanges(soap, NULL, NULL, "bes:RequestActivityStateChanges");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityStatusResponse:
		return soap_in_PointerTo_bes__GetActivityStatusResponse(soap, NULL, NULL, "bes:GetActivityStatusResponse");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityStatus:
		return soap_in_PointerTo_bes__GetActivityStatus(soap, NULL, NULL, "bes:GetActivityStatus");
	case SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDLResponse:
		return soap_in_PointerTo_bes__CreateActivityFromJSDLResponse(soap, NULL, NULL, "bes:CreateActivityFromJSDLResponse");
	case SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDL:
		return soap_in_PointerTo_bes__CreateActivityFromJSDL(soap, NULL, NULL, "bes:CreateActivityFromJSDL");
	case SOAP_TYPE_bes_PointerTobes__UnsupportedJSDLFaultType:
		return soap_in_PointerTobes__UnsupportedJSDLFaultType(soap, NULL, NULL, "bes:UnsupportedJSDLFaultType");
	case SOAP_TYPE_bes_PointerTobes__UnsupportedFeatureFaultType:
		return soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, NULL, NULL, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_bes_PointerTobes__NotAcceptingNewActivitiesFaultType:
		return soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_bes_PointerTobes__JobSpecificationFaultType:
		return soap_in_PointerTobes__JobSpecificationFaultType(soap, NULL, NULL, "bes:JobSpecificationFaultType");
	case SOAP_TYPE_bes_PointerTobes__BadlyFormedJSDLDocumentFaultType:
		return soap_in_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, NULL, NULL, "bes:BadlyFormedJSDLDocumentFaultType");
	case SOAP_TYPE_bes_PointerTobes__BackendFaultType:
		return soap_in_PointerTobes__BackendFaultType(soap, NULL, NULL, "bes:BackendFaultType");
	case SOAP_TYPE_bes_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_bes_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_bes_PointerTojsdl__SourceTarget_USCOREType:
		return soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_bes_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_bes_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_bes_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_bes_PointerTojsdl__RangeValue_USCOREType:
		return soap_in_PointerTojsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_bes_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_bes_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_bes_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_bes_PointerTojsdl__FileSystem_USCOREType:
		return soap_in_PointerTojsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_bes_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Description_USCOREType:
		return soap_in_PointerTojsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_bes_PointerTojsdl__DataStaging_USCOREType:
		return soap_in_PointerTojsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Resources_USCOREType:
		return soap_in_PointerTojsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Application_USCOREType:
		return soap_in_PointerTojsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_bes_PointerTojsdl__JobIdentification_USCOREType:
		return soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_bes_PointerToxsd__ID:
		return soap_in_PointerToxsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_bes_PointerTojsdl__JobDescription_USCOREType:
		return soap_in_PointerTojsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Range_USCOREType:
		return soap_in_PointerTojsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Exact_USCOREType:
		return soap_in_PointerTojsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Boundary_USCOREType:
		return soap_in_PointerTojsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_bes_PointerToaddressing__MetadataType:
		return soap_in_PointerToaddressing__MetadataType(soap, NULL, NULL, "addressing:MetadataType");
	case SOAP_TYPE_bes_PointerToaddressing__ReferenceParametersType:
		return soap_in_PointerToaddressing__ReferenceParametersType(soap, NULL, NULL, "addressing:ReferenceParametersType");
	case SOAP_TYPE_bes_PointerToaddressing__AttributedURIType:
		return soap_in_PointerToaddressing__AttributedURIType(soap, NULL, NULL, "addressing:AttributedURIType");
	case SOAP_TYPE_bes_PointerTobes__activity_jsdl_document_type:
		return soap_in_PointerTobes__activity_jsdl_document_type(soap, NULL, NULL, "bes:activity-jsdl-document-type");
	case SOAP_TYPE_bes_PointerTobes__state_change_response_type:
		return soap_in_PointerTobes__state_change_response_type(soap, NULL, NULL, "bes:state-change-response-type");
	case SOAP_TYPE_bes_PointerTobes__state_change_request_type:
		return soap_in_PointerTobes__state_change_request_type(soap, NULL, NULL, "bes:state-change-request-type");
	case SOAP_TYPE_bes_PointerTobes__activity_status_type:
		return soap_in_PointerTobes__activity_status_type(soap, NULL, NULL, "bes:activity-status-type");
	case SOAP_TYPE_bes_PointerTojsdl__JobDefinition_USCOREType:
		return soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_bes_PointerTobes__requested_state_change_type:
		return soap_in_PointerTobes__requested_state_change_type(soap, NULL, NULL, "bes:requested-state-change-type");
	case SOAP_TYPE_bes_PointerTobes__data_stage_status_type:
		return soap_in_PointerTobes__data_stage_status_type(soap, NULL, NULL, "bes:data-stage-status-type");
	case SOAP_TYPE_bes_PointerTobes__overall_status_type:
		return soap_in_PointerTobes__overall_status_type(soap, NULL, NULL, "bes:overall-status-type");
	case SOAP_TYPE_bes_PointerToaddressing__EndpointReferenceType:
		return soap_in_PointerToaddressing__EndpointReferenceType(soap, NULL, NULL, "addressing:EndpointReferenceType");
	case SOAP_TYPE_bes_PointerTobes__data_staging_state_enumeration:
		return soap_in_PointerTobes__data_staging_state_enumeration(soap, NULL, NULL, "bes:data-staging-state-enumeration");
	case SOAP_TYPE_bes_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_bes_PointerTobes__overall_state_enumeration:
		return soap_in_PointerTobes__overall_state_enumeration(soap, NULL, NULL, "bes:overall-state-enumeration");
	case SOAP_TYPE_bes_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "jsdl:Description_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__Description_USCOREType;
			return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:FaultCodesOpenEnumType"))
		{	*type = SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType;
			return soap_in_addressing__FaultCodesOpenEnumType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:RelationshipTypeOpenEnum"))
		{	*type = SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum;
			return soap_in_addressing__RelationshipTypeOpenEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:SourceTarget_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType;
			return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:DataStaging_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__DataStaging_USCOREType;
			return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType;
			return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystem_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType;
			return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystem_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__FileSystem_USCOREType;
			return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType;
			return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CandidateHosts_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType;
			return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Resources_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__Resources_USCOREType;
			return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Application_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__Application_USCOREType;
			return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobIdentification_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType;
			return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDescription_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__JobDescription_USCOREType;
			return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDefinition_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType;
			return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:RangeValue_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__RangeValue_USCOREType;
			return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Range_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__Range_USCOREType;
			return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Exact_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__Exact_USCOREType;
			return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Boundary_Type"))
		{	*type = SOAP_TYPE_bes_jsdl__Boundary_USCOREType;
			return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:AttributedNonNegativeIntegerType"))
		{	*type = SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType;
			return soap_in_addressing__AttributedNonNegativeIntegerType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:AttributedURIType"))
		{	*type = SOAP_TYPE_bes_addressing__AttributedURIType;
			return soap_in_addressing__AttributedURIType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:RelatesToType"))
		{	*type = SOAP_TYPE_bes_addressing__RelatesToType;
			return soap_in_addressing__RelatesToType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:MetadataType"))
		{	*type = SOAP_TYPE_bes_addressing__MetadataType;
			return soap_in_addressing__MetadataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:ReferenceParametersType"))
		{	*type = SOAP_TYPE_bes_addressing__ReferenceParametersType;
			return soap_in_addressing__ReferenceParametersType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:EndpointReferenceType"))
		{	*type = SOAP_TYPE_bes_addressing__EndpointReferenceType;
			return soap_in_addressing__EndpointReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:BackendFaultType"))
		{	*type = SOAP_TYPE_bes_bes__BackendFaultType;
			return soap_in_bes__BackendFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:JobSpecificationFaultType"))
		{	*type = SOAP_TYPE_bes_bes__JobSpecificationFaultType;
			return soap_in_bes__JobSpecificationFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:UnsupportedFeatureFaultType"))
		{	*type = SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType;
			return soap_in_bes__UnsupportedFeatureFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:UnsupportedJSDLFaultType"))
		{	*type = SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType;
			return soap_in_bes__UnsupportedJSDLFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:BadlyFormedJSDLDocumentFaultType"))
		{	*type = SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType;
			return soap_in_bes__BadlyFormedJSDLDocumentFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:NotAcceptingNewActivitiesFaultType"))
		{	*type = SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType;
			return soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:activity-jsdl-document-type"))
		{	*type = SOAP_TYPE_bes_bes__activity_jsdl_document_type;
			return soap_in_bes__activity_jsdl_document_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:state-change-response-type"))
		{	*type = SOAP_TYPE_bes_bes__state_change_response_type;
			return soap_in_bes__state_change_response_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:state-change-request-type"))
		{	*type = SOAP_TYPE_bes_bes__state_change_request_type;
			return soap_in_bes__state_change_request_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:requested-state-change-type"))
		{	*type = SOAP_TYPE_bes_bes__requested_state_change_type;
			return soap_in_bes__requested_state_change_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:activity-status-type"))
		{	*type = SOAP_TYPE_bes_bes__activity_status_type;
			return soap_in_bes__activity_status_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:data-stage-status-type"))
		{	*type = SOAP_TYPE_bes_bes__data_stage_status_type;
			return soap_in_bes__data_stage_status_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:overall-status-type"))
		{	*type = SOAP_TYPE_bes_bes__overall_status_type;
			return soap_in_bes__overall_status_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_bes_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_bes_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_bes_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_bes_xsd__NCName;
			return soap_in_xsd__NCName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_bes_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_bes_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_bes_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_bes_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_bes_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bes_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CreationFlagEnumeration"))
		{	*type = SOAP_TYPE_bes_jsdl__CreationFlagEnumeration;
			return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration;
			return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration;
			return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:ProcessorArchitectureEnumeration"))
		{	*type = SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration;
			return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:FaultCodesType"))
		{	*type = SOAP_TYPE_bes_addressing__FaultCodesType;
			return soap_in_addressing__FaultCodesType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "addressing:RelationshipType"))
		{	*type = SOAP_TYPE_bes_addressing__RelationshipType;
			return soap_in_addressing__RelationshipType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:state-change-response-enumeration"))
		{	*type = SOAP_TYPE_bes_bes__state_change_response_enumeration;
			return soap_in_bes__state_change_response_enumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:data-staging-state-enumeration"))
		{	*type = SOAP_TYPE_bes_bes__data_staging_state_enumeration;
			return soap_in_bes__data_staging_state_enumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:overall-state-enumeration"))
		{	*type = SOAP_TYPE_bes_bes__overall_state_enumeration;
			return soap_in_bes__overall_state_enumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_bes_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "bes:GetActivityJSDLDocumentsResponse"))
		{	*type = SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse;
			return soap_in__bes__GetActivityJSDLDocumentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityJSDLDocuments"))
		{	*type = SOAP_TYPE_bes__bes__GetActivityJSDLDocuments;
			return soap_in__bes__GetActivityJSDLDocuments(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:IsAcceptingNewActivitiesResponse"))
		{	*type = SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse;
			return soap_in__bes__IsAcceptingNewActivitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:RequestActivityStateChangesResponse"))
		{	*type = SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse;
			return soap_in__bes__RequestActivityStateChangesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:RequestActivityStateChanges"))
		{	*type = SOAP_TYPE_bes__bes__RequestActivityStateChanges;
			return soap_in__bes__RequestActivityStateChanges(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityStatusResponse"))
		{	*type = SOAP_TYPE_bes__bes__GetActivityStatusResponse;
			return soap_in__bes__GetActivityStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:GetActivityStatus"))
		{	*type = SOAP_TYPE_bes__bes__GetActivityStatus;
			return soap_in__bes__GetActivityStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CreateActivityFromJSDLResponse"))
		{	*type = SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse;
			return soap_in__bes__CreateActivityFromJSDLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bes:CreateActivityFromJSDL"))
		{	*type = SOAP_TYPE_bes__bes__CreateActivityFromJSDL;
			return soap_in__bes__CreateActivityFromJSDL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_bes__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_bes_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_bes_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bes_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_bes_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_bes_jsdl__CreationFlagEnumeration:
		return soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, (const enum jsdl__CreationFlagEnumeration *)ptr, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration:
		return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration:
		return soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration:
		return soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_bes_addressing__FaultCodesType:
		return soap_out_addressing__FaultCodesType(soap, tag, id, (const enum addressing__FaultCodesType *)ptr, "addressing:FaultCodesType");
	case SOAP_TYPE_bes_addressing__RelationshipType:
		return soap_out_addressing__RelationshipType(soap, tag, id, (const enum addressing__RelationshipType *)ptr, "addressing:RelationshipType");
	case SOAP_TYPE_bes_bes__state_change_response_enumeration:
		return soap_out_bes__state_change_response_enumeration(soap, tag, id, (const enum bes__state_change_response_enumeration *)ptr, "bes:state-change-response-enumeration");
	case SOAP_TYPE_bes_bes__data_staging_state_enumeration:
		return soap_out_bes__data_staging_state_enumeration(soap, tag, id, (const enum bes__data_staging_state_enumeration *)ptr, "bes:data-staging-state-enumeration");
	case SOAP_TYPE_bes_bes__overall_state_enumeration:
		return soap_out_bes__overall_state_enumeration(soap, tag, id, (const enum bes__overall_state_enumeration *)ptr, "bes:overall-state-enumeration");
	case SOAP_TYPE_bes_jsdl__Description_USCOREType:
		return soap_out_jsdl__Description_USCOREType(soap, tag, id, (const std::string *)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType:
		return soap_out_addressing__FaultCodesOpenEnumType(soap, tag, id, (const std::string *)ptr, "addressing:FaultCodesOpenEnumType");
	case SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum:
		return soap_out_addressing__RelationshipTypeOpenEnum(soap, tag, id, (const std::string *)ptr, "addressing:RelationshipTypeOpenEnum");
	case SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType:
		return ((jsdl__SourceTarget_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_bes_jsdl__DataStaging_USCOREType:
		return ((jsdl__DataStaging_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:DataStaging_Type");
	case SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType:
		return ((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType:
		return ((jsdl__OperatingSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_bes_jsdl__FileSystem_USCOREType:
		return ((jsdl__FileSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:FileSystem_Type");
	case SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType:
		return ((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType:
		return ((jsdl__CandidateHosts_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_bes_jsdl__Resources_USCOREType:
		return ((jsdl__Resources_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Resources_Type");
	case SOAP_TYPE_bes_jsdl__Application_USCOREType:
		return ((jsdl__Application_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Application_Type");
	case SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType:
		return ((jsdl__JobIdentification_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_bes_jsdl__JobDescription_USCOREType:
		return ((jsdl__JobDescription_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDescription_Type");
	case SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType:
		return ((jsdl__JobDefinition_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_bes_jsdl__RangeValue_USCOREType:
		return ((jsdl__RangeValue_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:RangeValue_Type");
	case SOAP_TYPE_bes_jsdl__Range_USCOREType:
		return ((jsdl__Range_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Range_Type");
	case SOAP_TYPE_bes_jsdl__Exact_USCOREType:
		return ((jsdl__Exact_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Exact_Type");
	case SOAP_TYPE_bes_jsdl__Boundary_USCOREType:
		return ((jsdl__Boundary_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Boundary_Type");
	case SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType:
		return ((addressing__AttributedNonNegativeIntegerType *)ptr)->soap_out(soap, tag, id, "addressing:AttributedNonNegativeIntegerType");
	case SOAP_TYPE_bes_addressing__AttributedURIType:
		return ((addressing__AttributedURIType *)ptr)->soap_out(soap, tag, id, "addressing:AttributedURIType");
	case SOAP_TYPE_bes_addressing__RelatesToType:
		return ((addressing__RelatesToType *)ptr)->soap_out(soap, tag, id, "addressing:RelatesToType");
	case SOAP_TYPE_bes_addressing__MetadataType:
		return ((addressing__MetadataType *)ptr)->soap_out(soap, tag, id, "addressing:MetadataType");
	case SOAP_TYPE_bes_addressing__ReferenceParametersType:
		return ((addressing__ReferenceParametersType *)ptr)->soap_out(soap, tag, id, "addressing:ReferenceParametersType");
	case SOAP_TYPE_bes_addressing__EndpointReferenceType:
		return ((addressing__EndpointReferenceType *)ptr)->soap_out(soap, tag, id, "addressing:EndpointReferenceType");
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse:
		return ((_bes__GetActivityJSDLDocumentsResponse *)ptr)->soap_out(soap, "bes:GetActivityJSDLDocumentsResponse", id, NULL);
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocuments:
		return ((_bes__GetActivityJSDLDocuments *)ptr)->soap_out(soap, "bes:GetActivityJSDLDocuments", id, NULL);
	case SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse:
		return ((_bes__IsAcceptingNewActivitiesResponse *)ptr)->soap_out(soap, "bes:IsAcceptingNewActivitiesResponse", id, NULL);
	case SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse:
		return ((_bes__RequestActivityStateChangesResponse *)ptr)->soap_out(soap, "bes:RequestActivityStateChangesResponse", id, NULL);
	case SOAP_TYPE_bes__bes__RequestActivityStateChanges:
		return ((_bes__RequestActivityStateChanges *)ptr)->soap_out(soap, "bes:RequestActivityStateChanges", id, NULL);
	case SOAP_TYPE_bes__bes__GetActivityStatusResponse:
		return ((_bes__GetActivityStatusResponse *)ptr)->soap_out(soap, "bes:GetActivityStatusResponse", id, NULL);
	case SOAP_TYPE_bes__bes__GetActivityStatus:
		return ((_bes__GetActivityStatus *)ptr)->soap_out(soap, "bes:GetActivityStatus", id, NULL);
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse:
		return ((_bes__CreateActivityFromJSDLResponse *)ptr)->soap_out(soap, "bes:CreateActivityFromJSDLResponse", id, NULL);
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDL:
		return ((_bes__CreateActivityFromJSDL *)ptr)->soap_out(soap, "bes:CreateActivityFromJSDL", id, NULL);
	case SOAP_TYPE_bes_bes__BackendFaultType:
		return ((bes__BackendFaultType *)ptr)->soap_out(soap, tag, id, "bes:BackendFaultType");
	case SOAP_TYPE_bes_bes__JobSpecificationFaultType:
		return ((bes__JobSpecificationFaultType *)ptr)->soap_out(soap, tag, id, "bes:JobSpecificationFaultType");
	case SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType:
		return ((bes__UnsupportedFeatureFaultType *)ptr)->soap_out(soap, tag, id, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType:
		return ((bes__UnsupportedJSDLFaultType *)ptr)->soap_out(soap, tag, id, "bes:UnsupportedJSDLFaultType");
	case SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType:
		return ((bes__BadlyFormedJSDLDocumentFaultType *)ptr)->soap_out(soap, tag, id, "bes:BadlyFormedJSDLDocumentFaultType");
	case SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType:
		return ((bes__NotAcceptingNewActivitiesFaultType *)ptr)->soap_out(soap, tag, id, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_bes_bes__activity_jsdl_document_type:
		return ((bes__activity_jsdl_document_type *)ptr)->soap_out(soap, tag, id, "bes:activity-jsdl-document-type");
	case SOAP_TYPE_bes_bes__state_change_response_type:
		return ((bes__state_change_response_type *)ptr)->soap_out(soap, tag, id, "bes:state-change-response-type");
	case SOAP_TYPE_bes_bes__state_change_request_type:
		return ((bes__state_change_request_type *)ptr)->soap_out(soap, tag, id, "bes:state-change-request-type");
	case SOAP_TYPE_bes_bes__requested_state_change_type:
		return ((bes__requested_state_change_type *)ptr)->soap_out(soap, tag, id, "bes:requested-state-change-type");
	case SOAP_TYPE_bes_bes__activity_status_type:
		return ((bes__activity_status_type *)ptr)->soap_out(soap, tag, id, "bes:activity-status-type");
	case SOAP_TYPE_bes_bes__data_stage_status_type:
		return ((bes__data_stage_status_type *)ptr)->soap_out(soap, tag, id, "bes:data-stage-status-type");
	case SOAP_TYPE_bes_bes__overall_status_type:
		return ((bes__overall_status_type *)ptr)->soap_out(soap, tag, id, "bes:overall-status-type");
	case SOAP_TYPE_bes_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_bes_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_bes_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_bes_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_bes_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_bes_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocumentsResponse:
		return soap_out_PointerTo_bes__GetActivityJSDLDocumentsResponse(soap, tag, id, (_bes__GetActivityJSDLDocumentsResponse *const*)ptr, "bes:GetActivityJSDLDocumentsResponse");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocuments:
		return soap_out_PointerTo_bes__GetActivityJSDLDocuments(soap, tag, id, (_bes__GetActivityJSDLDocuments *const*)ptr, "bes:GetActivityJSDLDocuments");
	case SOAP_TYPE_bes_PointerTo_bes__IsAcceptingNewActivitiesResponse:
		return soap_out_PointerTo_bes__IsAcceptingNewActivitiesResponse(soap, tag, id, (_bes__IsAcceptingNewActivitiesResponse *const*)ptr, "bes:IsAcceptingNewActivitiesResponse");
	case SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChangesResponse:
		return soap_out_PointerTo_bes__RequestActivityStateChangesResponse(soap, tag, id, (_bes__RequestActivityStateChangesResponse *const*)ptr, "bes:RequestActivityStateChangesResponse");
	case SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChanges:
		return soap_out_PointerTo_bes__RequestActivityStateChanges(soap, tag, id, (_bes__RequestActivityStateChanges *const*)ptr, "bes:RequestActivityStateChanges");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityStatusResponse:
		return soap_out_PointerTo_bes__GetActivityStatusResponse(soap, tag, id, (_bes__GetActivityStatusResponse *const*)ptr, "bes:GetActivityStatusResponse");
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityStatus:
		return soap_out_PointerTo_bes__GetActivityStatus(soap, tag, id, (_bes__GetActivityStatus *const*)ptr, "bes:GetActivityStatus");
	case SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDLResponse:
		return soap_out_PointerTo_bes__CreateActivityFromJSDLResponse(soap, tag, id, (_bes__CreateActivityFromJSDLResponse *const*)ptr, "bes:CreateActivityFromJSDLResponse");
	case SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDL:
		return soap_out_PointerTo_bes__CreateActivityFromJSDL(soap, tag, id, (_bes__CreateActivityFromJSDL *const*)ptr, "bes:CreateActivityFromJSDL");
	case SOAP_TYPE_bes_PointerTobes__UnsupportedJSDLFaultType:
		return soap_out_PointerTobes__UnsupportedJSDLFaultType(soap, tag, id, (bes__UnsupportedJSDLFaultType *const*)ptr, "bes:UnsupportedJSDLFaultType");
	case SOAP_TYPE_bes_PointerTobes__UnsupportedFeatureFaultType:
		return soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, tag, id, (bes__UnsupportedFeatureFaultType *const*)ptr, "bes:UnsupportedFeatureFaultType");
	case SOAP_TYPE_bes_PointerTobes__NotAcceptingNewActivitiesFaultType:
		return soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, id, (bes__NotAcceptingNewActivitiesFaultType *const*)ptr, "bes:NotAcceptingNewActivitiesFaultType");
	case SOAP_TYPE_bes_PointerTobes__JobSpecificationFaultType:
		return soap_out_PointerTobes__JobSpecificationFaultType(soap, tag, id, (bes__JobSpecificationFaultType *const*)ptr, "bes:JobSpecificationFaultType");
	case SOAP_TYPE_bes_PointerTobes__BadlyFormedJSDLDocumentFaultType:
		return soap_out_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, tag, id, (bes__BadlyFormedJSDLDocumentFaultType *const*)ptr, "bes:BadlyFormedJSDLDocumentFaultType");
	case SOAP_TYPE_bes_PointerTobes__BackendFaultType:
		return soap_out_PointerTobes__BackendFaultType(soap, tag, id, (bes__BackendFaultType *const*)ptr, "bes:BackendFaultType");
	case SOAP_TYPE_bes_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_bes_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_bes_PointerTojsdl__SourceTarget_USCOREType:
		return soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, (jsdl__SourceTarget_USCOREType *const*)ptr, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_bes_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_bes_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, (jsdl__OperatingSystemType_USCOREType *const*)ptr, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_bes_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, (enum jsdl__FileSystemTypeEnumeration *const*)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_bes_PointerTojsdl__RangeValue_USCOREType:
		return soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, (jsdl__RangeValue_USCOREType *const*)ptr, "jsdl:RangeValue_Type");
	case SOAP_TYPE_bes_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, (jsdl__CPUArchitecture_USCOREType *const*)ptr, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_bes_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, (jsdl__OperatingSystem_USCOREType *const*)ptr, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_bes_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_bes_PointerTojsdl__FileSystem_USCOREType:
		return soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, (jsdl__FileSystem_USCOREType *const*)ptr, "jsdl:FileSystem_Type");
	case SOAP_TYPE_bes_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, (jsdl__CandidateHosts_USCOREType *const*)ptr, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Description_USCOREType:
		return soap_out_PointerTojsdl__Description_USCOREType(soap, tag, id, (std::string *const*)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_bes_PointerTojsdl__DataStaging_USCOREType:
		return soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, (jsdl__DataStaging_USCOREType *const*)ptr, "jsdl:DataStaging_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Resources_USCOREType:
		return soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, (jsdl__Resources_USCOREType *const*)ptr, "jsdl:Resources_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Application_USCOREType:
		return soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, (jsdl__Application_USCOREType *const*)ptr, "jsdl:Application_Type");
	case SOAP_TYPE_bes_PointerTojsdl__JobIdentification_USCOREType:
		return soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, (jsdl__JobIdentification_USCOREType *const*)ptr, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_bes_PointerToxsd__ID:
		return soap_out_PointerToxsd__ID(soap, tag, id, (std::string *const*)ptr, "xsd:ID");
	case SOAP_TYPE_bes_PointerTojsdl__JobDescription_USCOREType:
		return soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, (jsdl__JobDescription_USCOREType *const*)ptr, "jsdl:JobDescription_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Range_USCOREType:
		return soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, (jsdl__Range_USCOREType *const*)ptr, "jsdl:Range_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Exact_USCOREType:
		return soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, (jsdl__Exact_USCOREType *const*)ptr, "jsdl:Exact_Type");
	case SOAP_TYPE_bes_PointerTojsdl__Boundary_USCOREType:
		return soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, (jsdl__Boundary_USCOREType *const*)ptr, "jsdl:Boundary_Type");
	case SOAP_TYPE_bes_PointerToaddressing__MetadataType:
		return soap_out_PointerToaddressing__MetadataType(soap, tag, id, (addressing__MetadataType *const*)ptr, "addressing:MetadataType");
	case SOAP_TYPE_bes_PointerToaddressing__ReferenceParametersType:
		return soap_out_PointerToaddressing__ReferenceParametersType(soap, tag, id, (addressing__ReferenceParametersType *const*)ptr, "addressing:ReferenceParametersType");
	case SOAP_TYPE_bes_PointerToaddressing__AttributedURIType:
		return soap_out_PointerToaddressing__AttributedURIType(soap, tag, id, (addressing__AttributedURIType *const*)ptr, "addressing:AttributedURIType");
	case SOAP_TYPE_bes_PointerTobes__activity_jsdl_document_type:
		return soap_out_PointerTobes__activity_jsdl_document_type(soap, tag, id, (bes__activity_jsdl_document_type *const*)ptr, "bes:activity-jsdl-document-type");
	case SOAP_TYPE_bes_PointerTobes__state_change_response_type:
		return soap_out_PointerTobes__state_change_response_type(soap, tag, id, (bes__state_change_response_type *const*)ptr, "bes:state-change-response-type");
	case SOAP_TYPE_bes_PointerTobes__state_change_request_type:
		return soap_out_PointerTobes__state_change_request_type(soap, tag, id, (bes__state_change_request_type *const*)ptr, "bes:state-change-request-type");
	case SOAP_TYPE_bes_PointerTobes__activity_status_type:
		return soap_out_PointerTobes__activity_status_type(soap, tag, id, (bes__activity_status_type *const*)ptr, "bes:activity-status-type");
	case SOAP_TYPE_bes_PointerTojsdl__JobDefinition_USCOREType:
		return soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, (jsdl__JobDefinition_USCOREType *const*)ptr, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_bes_PointerTobes__requested_state_change_type:
		return soap_out_PointerTobes__requested_state_change_type(soap, tag, id, (bes__requested_state_change_type *const*)ptr, "bes:requested-state-change-type");
	case SOAP_TYPE_bes_PointerTobes__data_stage_status_type:
		return soap_out_PointerTobes__data_stage_status_type(soap, tag, id, (bes__data_stage_status_type *const*)ptr, "bes:data-stage-status-type");
	case SOAP_TYPE_bes_PointerTobes__overall_status_type:
		return soap_out_PointerTobes__overall_status_type(soap, tag, id, (bes__overall_status_type *const*)ptr, "bes:overall-status-type");
	case SOAP_TYPE_bes_PointerToaddressing__EndpointReferenceType:
		return soap_out_PointerToaddressing__EndpointReferenceType(soap, tag, id, (addressing__EndpointReferenceType *const*)ptr, "addressing:EndpointReferenceType");
	case SOAP_TYPE_bes_PointerTobes__data_staging_state_enumeration:
		return soap_out_PointerTobes__data_staging_state_enumeration(soap, tag, id, (enum bes__data_staging_state_enumeration *const*)ptr, "bes:data-staging-state-enumeration");
	case SOAP_TYPE_bes_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_bes_PointerTobes__overall_state_enumeration:
		return soap_out_PointerTobes__overall_state_enumeration(soap, tag, id, (enum bes__overall_state_enumeration *const*)ptr, "bes:overall-state-enumeration");
	case SOAP_TYPE_bes__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_bes_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_bes_jsdl__Description_USCOREType:
		soap_serialize_jsdl__Description_USCOREType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType:
		soap_serialize_addressing__FaultCodesOpenEnumType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum:
		soap_serialize_addressing__RelationshipTypeOpenEnum(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType:
		((jsdl__SourceTarget_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__DataStaging_USCOREType:
		((jsdl__DataStaging_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType:
		((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType:
		((jsdl__OperatingSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__FileSystem_USCOREType:
		((jsdl__FileSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType:
		((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType:
		((jsdl__CandidateHosts_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__Resources_USCOREType:
		((jsdl__Resources_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__Application_USCOREType:
		((jsdl__Application_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType:
		((jsdl__JobIdentification_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__JobDescription_USCOREType:
		((jsdl__JobDescription_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType:
		((jsdl__JobDefinition_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__RangeValue_USCOREType:
		((jsdl__RangeValue_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__Range_USCOREType:
		((jsdl__Range_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__Exact_USCOREType:
		((jsdl__Exact_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_jsdl__Boundary_USCOREType:
		((jsdl__Boundary_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType:
		((addressing__AttributedNonNegativeIntegerType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_addressing__AttributedURIType:
		((addressing__AttributedURIType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_addressing__RelatesToType:
		((addressing__RelatesToType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_addressing__MetadataType:
		((addressing__MetadataType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_addressing__ReferenceParametersType:
		((addressing__ReferenceParametersType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_addressing__EndpointReferenceType:
		((addressing__EndpointReferenceType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse:
		((_bes__GetActivityJSDLDocumentsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocuments:
		((_bes__GetActivityJSDLDocuments *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse:
		((_bes__IsAcceptingNewActivitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse:
		((_bes__RequestActivityStateChangesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__RequestActivityStateChanges:
		((_bes__RequestActivityStateChanges *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__GetActivityStatusResponse:
		((_bes__GetActivityStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__GetActivityStatus:
		((_bes__GetActivityStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse:
		((_bes__CreateActivityFromJSDLResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDL:
		((_bes__CreateActivityFromJSDL *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__BackendFaultType:
		((bes__BackendFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__JobSpecificationFaultType:
		((bes__JobSpecificationFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType:
		((bes__UnsupportedFeatureFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType:
		((bes__UnsupportedJSDLFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType:
		((bes__BadlyFormedJSDLDocumentFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType:
		((bes__NotAcceptingNewActivitiesFaultType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__activity_jsdl_document_type:
		((bes__activity_jsdl_document_type *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__state_change_response_type:
		((bes__state_change_response_type *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__state_change_request_type:
		((bes__state_change_request_type *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__requested_state_change_type:
		((bes__requested_state_change_type *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__activity_status_type:
		((bes__activity_status_type *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__data_stage_status_type:
		((bes__data_stage_status_type *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_bes__overall_status_type:
		((bes__overall_status_type *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_bes_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_bes___bes__GetActivityJSDLDocuments:
		soap_serialize___bes__GetActivityJSDLDocuments(soap, (const struct __bes__GetActivityJSDLDocuments *)ptr);
		break;
	case SOAP_TYPE_bes___bes__IsAcceptingNewActivities:
		soap_serialize___bes__IsAcceptingNewActivities(soap, (const struct __bes__IsAcceptingNewActivities *)ptr);
		break;
	case SOAP_TYPE_bes___bes__StartAcceptingNewActivities:
		soap_serialize___bes__StartAcceptingNewActivities(soap, (const struct __bes__StartAcceptingNewActivities *)ptr);
		break;
	case SOAP_TYPE_bes___bes__StopAcceptingNewActivities:
		soap_serialize___bes__StopAcceptingNewActivities(soap, (const struct __bes__StopAcceptingNewActivities *)ptr);
		break;
	case SOAP_TYPE_bes___bes__RequestActivityStateChanges:
		soap_serialize___bes__RequestActivityStateChanges(soap, (const struct __bes__RequestActivityStateChanges *)ptr);
		break;
	case SOAP_TYPE_bes___bes__GetActivityStatus:
		soap_serialize___bes__GetActivityStatus(soap, (const struct __bes__GetActivityStatus *)ptr);
		break;
	case SOAP_TYPE_bes___bes__CreateActivityFromJSDL:
		soap_serialize___bes__CreateActivityFromJSDL(soap, (const struct __bes__CreateActivityFromJSDL *)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocumentsResponse:
		soap_serialize_PointerTo_bes__GetActivityJSDLDocumentsResponse(soap, (_bes__GetActivityJSDLDocumentsResponse *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocuments:
		soap_serialize_PointerTo_bes__GetActivityJSDLDocuments(soap, (_bes__GetActivityJSDLDocuments *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__IsAcceptingNewActivitiesResponse:
		soap_serialize_PointerTo_bes__IsAcceptingNewActivitiesResponse(soap, (_bes__IsAcceptingNewActivitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChangesResponse:
		soap_serialize_PointerTo_bes__RequestActivityStateChangesResponse(soap, (_bes__RequestActivityStateChangesResponse *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChanges:
		soap_serialize_PointerTo_bes__RequestActivityStateChanges(soap, (_bes__RequestActivityStateChanges *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityStatusResponse:
		soap_serialize_PointerTo_bes__GetActivityStatusResponse(soap, (_bes__GetActivityStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__GetActivityStatus:
		soap_serialize_PointerTo_bes__GetActivityStatus(soap, (_bes__GetActivityStatus *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDLResponse:
		soap_serialize_PointerTo_bes__CreateActivityFromJSDLResponse(soap, (_bes__CreateActivityFromJSDLResponse *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDL:
		soap_serialize_PointerTo_bes__CreateActivityFromJSDL(soap, (_bes__CreateActivityFromJSDL *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__UnsupportedJSDLFaultType:
		soap_serialize_PointerTobes__UnsupportedJSDLFaultType(soap, (bes__UnsupportedJSDLFaultType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__UnsupportedFeatureFaultType:
		soap_serialize_PointerTobes__UnsupportedFeatureFaultType(soap, (bes__UnsupportedFeatureFaultType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__NotAcceptingNewActivitiesFaultType:
		soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, (bes__NotAcceptingNewActivitiesFaultType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__JobSpecificationFaultType:
		soap_serialize_PointerTobes__JobSpecificationFaultType(soap, (bes__JobSpecificationFaultType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__BadlyFormedJSDLDocumentFaultType:
		soap_serialize_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, (bes__BadlyFormedJSDLDocumentFaultType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__BackendFaultType:
		soap_serialize_PointerTobes__BackendFaultType(soap, (bes__BackendFaultType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__SourceTarget_USCOREType:
		soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, (jsdl__SourceTarget_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__OperatingSystemType_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, (jsdl__OperatingSystemType_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__FileSystemTypeEnumeration:
		soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, (enum jsdl__FileSystemTypeEnumeration *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__RangeValue_USCOREType:
		soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, (jsdl__RangeValue_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__CPUArchitecture_USCOREType:
		soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, (jsdl__CPUArchitecture_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__OperatingSystem_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, (jsdl__OperatingSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__FileSystem_USCOREType:
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, (jsdl__FileSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__CandidateHosts_USCOREType:
		soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, (jsdl__CandidateHosts_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__Description_USCOREType:
		soap_serialize_PointerTojsdl__Description_USCOREType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__DataStaging_USCOREType:
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, (jsdl__DataStaging_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__Resources_USCOREType:
		soap_serialize_PointerTojsdl__Resources_USCOREType(soap, (jsdl__Resources_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__Application_USCOREType:
		soap_serialize_PointerTojsdl__Application_USCOREType(soap, (jsdl__Application_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__JobIdentification_USCOREType:
		soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, (jsdl__JobIdentification_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerToxsd__ID:
		soap_serialize_PointerToxsd__ID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__JobDescription_USCOREType:
		soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, (jsdl__JobDescription_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__Range_USCOREType:
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, (jsdl__Range_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__Exact_USCOREType:
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, (jsdl__Exact_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__Boundary_USCOREType:
		soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, (jsdl__Boundary_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerToaddressing__MetadataType:
		soap_serialize_PointerToaddressing__MetadataType(soap, (addressing__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerToaddressing__ReferenceParametersType:
		soap_serialize_PointerToaddressing__ReferenceParametersType(soap, (addressing__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerToaddressing__AttributedURIType:
		soap_serialize_PointerToaddressing__AttributedURIType(soap, (addressing__AttributedURIType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__activity_jsdl_document_type:
		soap_serialize_PointerTobes__activity_jsdl_document_type(soap, (bes__activity_jsdl_document_type *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__state_change_response_type:
		soap_serialize_PointerTobes__state_change_response_type(soap, (bes__state_change_response_type *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__state_change_request_type:
		soap_serialize_PointerTobes__state_change_request_type(soap, (bes__state_change_request_type *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__activity_status_type:
		soap_serialize_PointerTobes__activity_status_type(soap, (bes__activity_status_type *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTojsdl__JobDefinition_USCOREType:
		soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, (jsdl__JobDefinition_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__requested_state_change_type:
		soap_serialize_PointerTobes__requested_state_change_type(soap, (bes__requested_state_change_type *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__data_stage_status_type:
		soap_serialize_PointerTobes__data_stage_status_type(soap, (bes__data_stage_status_type *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__overall_status_type:
		soap_serialize_PointerTobes__overall_status_type(soap, (bes__overall_status_type *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerToaddressing__EndpointReferenceType:
		soap_serialize_PointerToaddressing__EndpointReferenceType(soap, (addressing__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__data_staging_state_enumeration:
		soap_serialize_PointerTobes__data_staging_state_enumeration(soap, (enum bes__data_staging_state_enumeration *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_bes_PointerTobes__overall_state_enumeration:
		soap_serialize_PointerTobes__overall_state_enumeration(soap, (enum bes__overall_state_enumeration *const*)ptr);
		break;
	case SOAP_TYPE_bes__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_bes_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_bes_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__overall_status_type:
		return (void*)soap_instantiate_bes__overall_status_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__data_stage_status_type:
		return (void*)soap_instantiate_bes__data_stage_status_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__activity_status_type:
		return (void*)soap_instantiate_bes__activity_status_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__requested_state_change_type:
		return (void*)soap_instantiate_bes__requested_state_change_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__state_change_request_type:
		return (void*)soap_instantiate_bes__state_change_request_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__state_change_response_type:
		return (void*)soap_instantiate_bes__state_change_response_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__activity_jsdl_document_type:
		return (void*)soap_instantiate_bes__activity_jsdl_document_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType:
		return (void*)soap_instantiate_bes__NotAcceptingNewActivitiesFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType:
		return (void*)soap_instantiate_bes__BadlyFormedJSDLDocumentFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType:
		return (void*)soap_instantiate_bes__UnsupportedJSDLFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType:
		return (void*)soap_instantiate_bes__UnsupportedFeatureFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__JobSpecificationFaultType:
		return (void*)soap_instantiate_bes__JobSpecificationFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_bes__BackendFaultType:
		return (void*)soap_instantiate_bes__BackendFaultType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDL:
		return (void*)soap_instantiate__bes__CreateActivityFromJSDL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse:
		return (void*)soap_instantiate__bes__CreateActivityFromJSDLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__GetActivityStatus:
		return (void*)soap_instantiate__bes__GetActivityStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__GetActivityStatusResponse:
		return (void*)soap_instantiate__bes__GetActivityStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__RequestActivityStateChanges:
		return (void*)soap_instantiate__bes__RequestActivityStateChanges(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse:
		return (void*)soap_instantiate__bes__RequestActivityStateChangesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse:
		return (void*)soap_instantiate__bes__IsAcceptingNewActivitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocuments:
		return (void*)soap_instantiate__bes__GetActivityJSDLDocuments(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse:
		return (void*)soap_instantiate__bes__GetActivityJSDLDocumentsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__EndpointReferenceType:
		return (void*)soap_instantiate_addressing__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__ReferenceParametersType:
		return (void*)soap_instantiate_addressing__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__MetadataType:
		return (void*)soap_instantiate_addressing__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__Range_USCOREType:
		return (void*)soap_instantiate_jsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__RangeValue_USCOREType:
		return (void*)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__JobDescription_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType:
		return (void*)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__Application_USCOREType:
		return (void*)soap_instantiate_jsdl__Application_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__Resources_USCOREType:
		return (void*)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType:
		return (void*)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType:
		return (void*)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType:
		return (void*)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__RelatesToType:
		return (void*)soap_instantiate_addressing__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__AttributedURIType:
		return (void*)soap_instantiate_addressing__AttributedURIType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType:
		return (void*)soap_instantiate_addressing__AttributedNonNegativeIntegerType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__Boundary_USCOREType:
		return (void*)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__Exact_USCOREType:
		return (void*)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_bes_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_bes___bes__CreateActivityFromJSDL:
		return (void*)soap_instantiate___bes__CreateActivityFromJSDL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes___bes__GetActivityStatus:
		return (void*)soap_instantiate___bes__GetActivityStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes___bes__RequestActivityStateChanges:
		return (void*)soap_instantiate___bes__RequestActivityStateChanges(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes___bes__StopAcceptingNewActivities:
		return (void*)soap_instantiate___bes__StopAcceptingNewActivities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes___bes__StartAcceptingNewActivities:
		return (void*)soap_instantiate___bes__StartAcceptingNewActivities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes___bes__IsAcceptingNewActivities:
		return (void*)soap_instantiate___bes__IsAcceptingNewActivities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes___bes__GetActivityJSDLDocuments:
		return (void*)soap_instantiate___bes__GetActivityJSDLDocuments(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_bes_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_bes_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_bes_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_bes_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_bes_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum:
		return (void*)soap_instantiate_addressing__RelationshipTypeOpenEnum(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType:
		return (void*)soap_instantiate_addressing__FaultCodesOpenEnumType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_jsdl__Description_USCOREType:
		return (void*)soap_instantiate_jsdl__Description_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_response_type:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_response_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_request_type:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_request_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_status_type:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobes__activity_status_type(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__data_stage_status_type:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTobes__data_stage_status_type(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_bes_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__overall_status_type:
		if (p->size < 0)
			delete (bes__overall_status_type*)p->ptr;
		else
			delete[] (bes__overall_status_type*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__data_stage_status_type:
		if (p->size < 0)
			delete (bes__data_stage_status_type*)p->ptr;
		else
			delete[] (bes__data_stage_status_type*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__activity_status_type:
		if (p->size < 0)
			delete (bes__activity_status_type*)p->ptr;
		else
			delete[] (bes__activity_status_type*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__requested_state_change_type:
		if (p->size < 0)
			delete (bes__requested_state_change_type*)p->ptr;
		else
			delete[] (bes__requested_state_change_type*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__state_change_request_type:
		if (p->size < 0)
			delete (bes__state_change_request_type*)p->ptr;
		else
			delete[] (bes__state_change_request_type*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__state_change_response_type:
		if (p->size < 0)
			delete (bes__state_change_response_type*)p->ptr;
		else
			delete[] (bes__state_change_response_type*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__activity_jsdl_document_type:
		if (p->size < 0)
			delete (bes__activity_jsdl_document_type*)p->ptr;
		else
			delete[] (bes__activity_jsdl_document_type*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType:
		if (p->size < 0)
			delete (bes__NotAcceptingNewActivitiesFaultType*)p->ptr;
		else
			delete[] (bes__NotAcceptingNewActivitiesFaultType*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType:
		if (p->size < 0)
			delete (bes__BadlyFormedJSDLDocumentFaultType*)p->ptr;
		else
			delete[] (bes__BadlyFormedJSDLDocumentFaultType*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType:
		if (p->size < 0)
			delete (bes__UnsupportedJSDLFaultType*)p->ptr;
		else
			delete[] (bes__UnsupportedJSDLFaultType*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType:
		if (p->size < 0)
			delete (bes__UnsupportedFeatureFaultType*)p->ptr;
		else
			delete[] (bes__UnsupportedFeatureFaultType*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__JobSpecificationFaultType:
		if (p->size < 0)
			delete (bes__JobSpecificationFaultType*)p->ptr;
		else
			delete[] (bes__JobSpecificationFaultType*)p->ptr;
		break;
	case SOAP_TYPE_bes_bes__BackendFaultType:
		if (p->size < 0)
			delete (bes__BackendFaultType*)p->ptr;
		else
			delete[] (bes__BackendFaultType*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDL:
		if (p->size < 0)
			delete (_bes__CreateActivityFromJSDL*)p->ptr;
		else
			delete[] (_bes__CreateActivityFromJSDL*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse:
		if (p->size < 0)
			delete (_bes__CreateActivityFromJSDLResponse*)p->ptr;
		else
			delete[] (_bes__CreateActivityFromJSDLResponse*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__GetActivityStatus:
		if (p->size < 0)
			delete (_bes__GetActivityStatus*)p->ptr;
		else
			delete[] (_bes__GetActivityStatus*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__GetActivityStatusResponse:
		if (p->size < 0)
			delete (_bes__GetActivityStatusResponse*)p->ptr;
		else
			delete[] (_bes__GetActivityStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__RequestActivityStateChanges:
		if (p->size < 0)
			delete (_bes__RequestActivityStateChanges*)p->ptr;
		else
			delete[] (_bes__RequestActivityStateChanges*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse:
		if (p->size < 0)
			delete (_bes__RequestActivityStateChangesResponse*)p->ptr;
		else
			delete[] (_bes__RequestActivityStateChangesResponse*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse:
		if (p->size < 0)
			delete (_bes__IsAcceptingNewActivitiesResponse*)p->ptr;
		else
			delete[] (_bes__IsAcceptingNewActivitiesResponse*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocuments:
		if (p->size < 0)
			delete (_bes__GetActivityJSDLDocuments*)p->ptr;
		else
			delete[] (_bes__GetActivityJSDLDocuments*)p->ptr;
		break;
	case SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse:
		if (p->size < 0)
			delete (_bes__GetActivityJSDLDocumentsResponse*)p->ptr;
		else
			delete[] (_bes__GetActivityJSDLDocumentsResponse*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__EndpointReferenceType:
		if (p->size < 0)
			delete (addressing__EndpointReferenceType*)p->ptr;
		else
			delete[] (addressing__EndpointReferenceType*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__ReferenceParametersType:
		if (p->size < 0)
			delete (addressing__ReferenceParametersType*)p->ptr;
		else
			delete[] (addressing__ReferenceParametersType*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__MetadataType:
		if (p->size < 0)
			delete (addressing__MetadataType*)p->ptr;
		else
			delete[] (addressing__MetadataType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__Range_USCOREType:
		if (p->size < 0)
			delete (jsdl__Range_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Range_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__RangeValue_USCOREType:
		if (p->size < 0)
			delete (jsdl__RangeValue_USCOREType*)p->ptr;
		else
			delete[] (jsdl__RangeValue_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobDefinition_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobDefinition_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__JobDescription_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobDescription_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobDescription_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobIdentification_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobIdentification_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__Application_USCOREType:
		if (p->size < 0)
			delete (jsdl__Application_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Application_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__Resources_USCOREType:
		if (p->size < 0)
			delete (jsdl__Resources_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Resources_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType:
		if (p->size < 0)
			delete (jsdl__CandidateHosts_USCOREType*)p->ptr;
		else
			delete[] (jsdl__CandidateHosts_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType:
		if (p->size < 0)
			delete (jsdl__CPUArchitecture_USCOREType*)p->ptr;
		else
			delete[] (jsdl__CPUArchitecture_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__FileSystem_USCOREType:
		if (p->size < 0)
			delete (jsdl__FileSystem_USCOREType*)p->ptr;
		else
			delete[] (jsdl__FileSystem_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType:
		if (p->size < 0)
			delete (jsdl__OperatingSystem_USCOREType*)p->ptr;
		else
			delete[] (jsdl__OperatingSystem_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType:
		if (p->size < 0)
			delete (jsdl__OperatingSystemType_USCOREType*)p->ptr;
		else
			delete[] (jsdl__OperatingSystemType_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__DataStaging_USCOREType:
		if (p->size < 0)
			delete (jsdl__DataStaging_USCOREType*)p->ptr;
		else
			delete[] (jsdl__DataStaging_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType:
		if (p->size < 0)
			delete (jsdl__SourceTarget_USCOREType*)p->ptr;
		else
			delete[] (jsdl__SourceTarget_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__RelatesToType:
		if (p->size < 0)
			delete (addressing__RelatesToType*)p->ptr;
		else
			delete[] (addressing__RelatesToType*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__AttributedURIType:
		if (p->size < 0)
			delete (addressing__AttributedURIType*)p->ptr;
		else
			delete[] (addressing__AttributedURIType*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType:
		if (p->size < 0)
			delete (addressing__AttributedNonNegativeIntegerType*)p->ptr;
		else
			delete[] (addressing__AttributedNonNegativeIntegerType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__Boundary_USCOREType:
		if (p->size < 0)
			delete (jsdl__Boundary_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Boundary_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__Exact_USCOREType:
		if (p->size < 0)
			delete (jsdl__Exact_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Exact_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_bes_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_bes___bes__CreateActivityFromJSDL:
		if (p->size < 0)
			delete (struct __bes__CreateActivityFromJSDL*)p->ptr;
		else
			delete[] (struct __bes__CreateActivityFromJSDL*)p->ptr;
		break;
	case SOAP_TYPE_bes___bes__GetActivityStatus:
		if (p->size < 0)
			delete (struct __bes__GetActivityStatus*)p->ptr;
		else
			delete[] (struct __bes__GetActivityStatus*)p->ptr;
		break;
	case SOAP_TYPE_bes___bes__RequestActivityStateChanges:
		if (p->size < 0)
			delete (struct __bes__RequestActivityStateChanges*)p->ptr;
		else
			delete[] (struct __bes__RequestActivityStateChanges*)p->ptr;
		break;
	case SOAP_TYPE_bes___bes__StopAcceptingNewActivities:
		if (p->size < 0)
			delete (struct __bes__StopAcceptingNewActivities*)p->ptr;
		else
			delete[] (struct __bes__StopAcceptingNewActivities*)p->ptr;
		break;
	case SOAP_TYPE_bes___bes__StartAcceptingNewActivities:
		if (p->size < 0)
			delete (struct __bes__StartAcceptingNewActivities*)p->ptr;
		else
			delete[] (struct __bes__StartAcceptingNewActivities*)p->ptr;
		break;
	case SOAP_TYPE_bes___bes__IsAcceptingNewActivities:
		if (p->size < 0)
			delete (struct __bes__IsAcceptingNewActivities*)p->ptr;
		else
			delete[] (struct __bes__IsAcceptingNewActivities*)p->ptr;
		break;
	case SOAP_TYPE_bes___bes__GetActivityJSDLDocuments:
		if (p->size < 0)
			delete (struct __bes__GetActivityJSDLDocuments*)p->ptr;
		else
			delete[] (struct __bes__GetActivityJSDLDocuments*)p->ptr;
		break;
	case SOAP_TYPE_bes_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_bes_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_bes_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_bes_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_bes_xsd__ID:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_xsd__NCName:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_xsd__QName:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_xsd__anyURI:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_xsd__nonNegativeInteger:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_jsdl__Description_USCOREType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__Range_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__Range_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__Exact_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__Exact_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOf_XML:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type:
		if (p->size < 0)
			delete (std::vector<bes__activity_jsdl_document_type * >*)p->ptr;
		else
			delete[] (std::vector<bes__activity_jsdl_document_type * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_response_type:
		if (p->size < 0)
			delete (std::vector<bes__state_change_response_type * >*)p->ptr;
		else
			delete[] (std::vector<bes__state_change_response_type * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_request_type:
		if (p->size < 0)
			delete (std::vector<bes__state_change_request_type * >*)p->ptr;
		else
			delete[] (std::vector<bes__state_change_request_type * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_status_type:
		if (p->size < 0)
			delete (std::vector<bes__activity_status_type * >*)p->ptr;
		else
			delete[] (std::vector<bes__activity_status_type * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType:
		if (p->size < 0)
			delete (std::vector<addressing__EndpointReferenceType * >*)p->ptr;
		else
			delete[] (std::vector<addressing__EndpointReferenceType * >*)p->ptr;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__data_stage_status_type:
		if (p->size < 0)
			delete (std::vector<bes__data_stage_status_type * >*)p->ptr;
		else
			delete[] (std::vector<bes__data_stage_status_type * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__FileSystem_USCOREType * >*)p)[len] = *(jsdl__FileSystem_USCOREType **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__DataStaging_USCOREType * >*)p)[len] = *(jsdl__DataStaging_USCOREType **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Range_USCOREType * >*)p)[len] = *(jsdl__Range_USCOREType **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Exact_USCOREType * >*)p)[len] = *(jsdl__Exact_USCOREType **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<bes__activity_jsdl_document_type * >*)p)[len] = *(bes__activity_jsdl_document_type **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_response_type:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<bes__state_change_response_type * >*)p)[len] = *(bes__state_change_response_type **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_request_type:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<bes__state_change_request_type * >*)p)[len] = *(bes__state_change_request_type **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_status_type:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<bes__activity_status_type * >*)p)[len] = *(bes__activity_status_type **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<addressing__EndpointReferenceType * >*)p)[len] = *(addressing__EndpointReferenceType **)q;
		break;
	case SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__data_stage_status_type:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<bes__data_stage_status_type * >*)p)[len] = *(bes__data_stage_status_type **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_bes_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_bes_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_bes_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_bes_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_bes_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_bes_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__CreationFlagEnumeration
	*a = SOAP_DEFAULT_jsdl__CreationFlagEnumeration;
#else
	*a = (enum jsdl__CreationFlagEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__CreationFlagEnumeration(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_jsdl__CreationFlagEnumeration);
	if (soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__CreationFlagEnumeration[] =
{	{ (long)jsdl__CreationFlagEnumeration__overwrite, "overwrite" },
	{ (long)jsdl__CreationFlagEnumeration__append, "append" },
	{ (long)jsdl__CreationFlagEnumeration__dontOverwrite, "dontOverwrite" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__CreationFlagEnumeration2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__CreationFlagEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__CreationFlagEnumeration), type) || soap_send(soap, soap_jsdl__CreationFlagEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CreationFlagEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__CreationFlagEnumeration(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__CreationFlagEnumeration, s);
	if (map)
		*a = (enum jsdl__CreationFlagEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__CreationFlagEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__CreationFlagEnumeration, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__CreationFlagEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__CreationFlagEnumeration, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration;
#else
	*a = (enum jsdl__FileSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__FileSystemTypeEnumeration(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration);
	if (soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__FileSystemTypeEnumeration[] =
{	{ (long)jsdl__FileSystemTypeEnumeration__swap, "swap" },
	{ (long)jsdl__FileSystemTypeEnumeration__temporary, "temporary" },
	{ (long)jsdl__FileSystemTypeEnumeration__spool, "spool" },
	{ (long)jsdl__FileSystemTypeEnumeration__normal, "normal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__FileSystemTypeEnumeration2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__FileSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__FileSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__FileSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__FileSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__FileSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__FileSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration;
#else
	*a = (enum jsdl__OperatingSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration);
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__OperatingSystemTypeEnumeration[] =
{	{ (long)jsdl__OperatingSystemTypeEnumeration__Unknown, "Unknown" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACOS, "MACOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ATTUNIX, "ATTUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DGUX, "DGUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DECNT, "DECNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Tru64_USCOREUNIX, "Tru64_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenVMS, "OpenVMS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HPUX, "HPUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__AIX, "AIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MVS, "MVS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS400, "OS400" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE2, "OS_2" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__JavaVM, "JavaVM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MSDOS, "MSDOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN3x, "WIN3x" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN95, "WIN95" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN98, "WIN98" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINNT, "WINNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINCE, "WINCE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NCR3000, "NCR3000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetWare, "NetWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OSF, "OSF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DC_USCOREOS, "DC_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Reliant_USCOREUNIX, "Reliant_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREUnixWare, "SCO_UnixWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREOpenServer, "SCO_OpenServer" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Sequent, "Sequent" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IRIX, "IRIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Solaris, "Solaris" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SunOS, "SunOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__U6000, "U6000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ASERIES, "ASERIES" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNSK, "TandemNSK" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNT, "TandemNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BS2000, "BS2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__LINUX, "LINUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Lynx, "Lynx" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__XENIX, "XENIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VM, "VM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Interactive_USCOREUNIX, "Interactive_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BSDUNIX, "BSDUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__FreeBSD, "FreeBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetBSD, "NetBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__GNU_USCOREHurd, "GNU_Hurd" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS9, "OS9" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACH_USCOREKernel, "MACH_Kernel" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Inferno, "Inferno" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__QNX, "QNX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__EPOC, "EPOC" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IxWorks, "IxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VxWorks, "VxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MiNT, "MiNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BeOS, "BeOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HP_USCOREMPE, "HP_MPE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NextStep, "NextStep" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__PalmPilot, "PalmPilot" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Rhapsody, "Rhapsody" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORE2000, "Windows_2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Dedicated, "Dedicated" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE390, "OS_390" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VSE, "VSE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TPF, "TPF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORER_USCOREMe, "Windows_R_Me" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Caldera_USCOREOpen_USCOREUNIX, "Caldera_Open_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenBSD, "OpenBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Not_USCOREApplicable, "Not_Applicable" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCOREXP, "Windows_XP" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__z_USCOREOS, "z_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__OperatingSystemTypeEnumeration2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__OperatingSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__OperatingSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__OperatingSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__OperatingSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 68)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__OperatingSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__OperatingSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration
	*a = SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration;
#else
	*a = (enum jsdl__ProcessorArchitectureEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration);
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__ProcessorArchitectureEnumeration[] =
{	{ (long)jsdl__ProcessorArchitectureEnumeration__sparc, "sparc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__powerpc, "powerpc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86, "x86" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE32, "x86_32" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE64, "x86_64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__parisc, "parisc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__mips, "mips" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__ia64, "ia64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__arm, "arm" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__ProcessorArchitectureEnumeration2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__ProcessorArchitectureEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration), type) || soap_send(soap, soap_jsdl__ProcessorArchitectureEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__ProcessorArchitectureEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__ProcessorArchitectureEnumeration, s);
	if (map)
		*a = (enum jsdl__ProcessorArchitectureEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__ProcessorArchitectureEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__ProcessorArchitectureEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_addressing__FaultCodesType(struct soap *soap, enum addressing__FaultCodesType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_addressing__FaultCodesType
	*a = SOAP_DEFAULT_addressing__FaultCodesType;
#else
	*a = (enum addressing__FaultCodesType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_addressing__FaultCodesType(struct soap *soap, const enum addressing__FaultCodesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_addressing__FaultCodesType);
	if (soap_out_addressing__FaultCodesType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_addressing__FaultCodesType[] =
{	{ (long)addressing__FaultCodesType__addressing__InvalidMessageInformationHeader, "addressing:InvalidMessageInformationHeader" },
	{ (long)addressing__FaultCodesType__addressing__MessageInformationHeaderRequired, "addressing:MessageInformationHeaderRequired" },
	{ (long)addressing__FaultCodesType__addressing__DestinationUnreachable, "addressing:DestinationUnreachable" },
	{ (long)addressing__FaultCodesType__addressing__ActionNotSupported, "addressing:ActionNotSupported" },
	{ (long)addressing__FaultCodesType__addressing__EndpointUnavailable, "addressing:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_addressing__FaultCodesType2s(struct soap *soap, enum addressing__FaultCodesType n)
{	const char *s = soap_code_str(soap_codes_addressing__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__FaultCodesType(struct soap *soap, const char *tag, int id, const enum addressing__FaultCodesType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_addressing__FaultCodesType), type) || soap_send(soap, soap_addressing__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum addressing__FaultCodesType * SOAP_FMAC4 soap_get_addressing__FaultCodesType(struct soap *soap, enum addressing__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2addressing__FaultCodesType(struct soap *soap, const char *s, enum addressing__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return SOAP_OK;
	soap_s2QName(soap, s, &t);
	map = soap_code(soap_codes_addressing__FaultCodesType, t);
	if (map)
		*a = (enum addressing__FaultCodesType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum addressing__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum addressing__FaultCodesType * SOAP_FMAC4 soap_in_addressing__FaultCodesType(struct soap *soap, const char *tag, enum addressing__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum addressing__FaultCodesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__FaultCodesType, sizeof(enum addressing__FaultCodesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2addressing__FaultCodesType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum addressing__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_addressing__FaultCodesType, 0, sizeof(enum addressing__FaultCodesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_addressing__RelationshipType(struct soap *soap, enum addressing__RelationshipType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_addressing__RelationshipType
	*a = SOAP_DEFAULT_addressing__RelationshipType;
#else
	*a = (enum addressing__RelationshipType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_addressing__RelationshipType(struct soap *soap, const enum addressing__RelationshipType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_addressing__RelationshipType);
	if (soap_out_addressing__RelationshipType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_addressing__RelationshipType[] =
{	{ (long)addressing__RelationshipType__http___x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f03_x002faddressing_x002freply, "http://www.w3.org/2005/03/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_addressing__RelationshipType2s(struct soap *soap, enum addressing__RelationshipType n)
{	const char *s = soap_code_str(soap_codes_addressing__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__RelationshipType(struct soap *soap, const char *tag, int id, const enum addressing__RelationshipType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_addressing__RelationshipType), type) || soap_send(soap, soap_addressing__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum addressing__RelationshipType * SOAP_FMAC4 soap_get_addressing__RelationshipType(struct soap *soap, enum addressing__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2addressing__RelationshipType(struct soap *soap, const char *s, enum addressing__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_addressing__RelationshipType, s);
	if (map)
		*a = (enum addressing__RelationshipType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum addressing__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum addressing__RelationshipType * SOAP_FMAC4 soap_in_addressing__RelationshipType(struct soap *soap, const char *tag, enum addressing__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum addressing__RelationshipType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__RelationshipType, sizeof(enum addressing__RelationshipType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2addressing__RelationshipType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum addressing__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_addressing__RelationshipType, 0, sizeof(enum addressing__RelationshipType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__state_change_response_enumeration(struct soap *soap, enum bes__state_change_response_enumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bes__state_change_response_enumeration
	*a = SOAP_DEFAULT_bes__state_change_response_enumeration;
#else
	*a = (enum bes__state_change_response_enumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__state_change_response_enumeration(struct soap *soap, const enum bes__state_change_response_enumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_bes__state_change_response_enumeration);
	if (soap_out_bes__state_change_response_enumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bes__state_change_response_enumeration[] =
{	{ (long)bes__state_change_response_enumeration__Succeeded, "Succeeded" },
	{ (long)bes__state_change_response_enumeration__Failed, "Failed" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bes__state_change_response_enumeration2s(struct soap *soap, enum bes__state_change_response_enumeration n)
{	const char *s = soap_code_str(soap_codes_bes__state_change_response_enumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__state_change_response_enumeration(struct soap *soap, const char *tag, int id, const enum bes__state_change_response_enumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__state_change_response_enumeration), type) || soap_send(soap, soap_bes__state_change_response_enumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum bes__state_change_response_enumeration * SOAP_FMAC4 soap_get_bes__state_change_response_enumeration(struct soap *soap, enum bes__state_change_response_enumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__state_change_response_enumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bes__state_change_response_enumeration(struct soap *soap, const char *s, enum bes__state_change_response_enumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bes__state_change_response_enumeration, s);
	if (map)
		*a = (enum bes__state_change_response_enumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum bes__state_change_response_enumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum bes__state_change_response_enumeration * SOAP_FMAC4 soap_in_bes__state_change_response_enumeration(struct soap *soap, const char *tag, enum bes__state_change_response_enumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum bes__state_change_response_enumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__state_change_response_enumeration, sizeof(enum bes__state_change_response_enumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bes__state_change_response_enumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum bes__state_change_response_enumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__state_change_response_enumeration, 0, sizeof(enum bes__state_change_response_enumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__data_staging_state_enumeration(struct soap *soap, enum bes__data_staging_state_enumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bes__data_staging_state_enumeration
	*a = SOAP_DEFAULT_bes__data_staging_state_enumeration;
#else
	*a = (enum bes__data_staging_state_enumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__data_staging_state_enumeration(struct soap *soap, const enum bes__data_staging_state_enumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_bes__data_staging_state_enumeration);
	if (soap_out_bes__data_staging_state_enumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bes__data_staging_state_enumeration[] =
{	{ (long)bes__data_staging_state_enumeration__New, "New" },
	{ (long)bes__data_staging_state_enumeration__Pending, "Pending" },
	{ (long)bes__data_staging_state_enumeration__StagingIn, "StagingIn" },
	{ (long)bes__data_staging_state_enumeration__Waiting, "Waiting" },
	{ (long)bes__data_staging_state_enumeration__StagingOut, "StagingOut" },
	{ (long)bes__data_staging_state_enumeration__Blocked, "Blocked" },
	{ (long)bes__data_staging_state_enumeration__Suspended, "Suspended" },
	{ (long)bes__data_staging_state_enumeration__Done, "Done" },
	{ (long)bes__data_staging_state_enumeration__NotKnown, "NotKnown" },
	{ (long)bes__data_staging_state_enumeration__Terminated, "Terminated" },
	{ (long)bes__data_staging_state_enumeration__Exception, "Exception" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bes__data_staging_state_enumeration2s(struct soap *soap, enum bes__data_staging_state_enumeration n)
{	const char *s = soap_code_str(soap_codes_bes__data_staging_state_enumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__data_staging_state_enumeration(struct soap *soap, const char *tag, int id, const enum bes__data_staging_state_enumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__data_staging_state_enumeration), type) || soap_send(soap, soap_bes__data_staging_state_enumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum bes__data_staging_state_enumeration * SOAP_FMAC4 soap_get_bes__data_staging_state_enumeration(struct soap *soap, enum bes__data_staging_state_enumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__data_staging_state_enumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bes__data_staging_state_enumeration(struct soap *soap, const char *s, enum bes__data_staging_state_enumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bes__data_staging_state_enumeration, s);
	if (map)
		*a = (enum bes__data_staging_state_enumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum bes__data_staging_state_enumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum bes__data_staging_state_enumeration * SOAP_FMAC4 soap_in_bes__data_staging_state_enumeration(struct soap *soap, const char *tag, enum bes__data_staging_state_enumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum bes__data_staging_state_enumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__data_staging_state_enumeration, sizeof(enum bes__data_staging_state_enumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bes__data_staging_state_enumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum bes__data_staging_state_enumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__data_staging_state_enumeration, 0, sizeof(enum bes__data_staging_state_enumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bes__overall_state_enumeration(struct soap *soap, enum bes__overall_state_enumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bes__overall_state_enumeration
	*a = SOAP_DEFAULT_bes__overall_state_enumeration;
#else
	*a = (enum bes__overall_state_enumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bes__overall_state_enumeration(struct soap *soap, const enum bes__overall_state_enumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_bes__overall_state_enumeration);
	if (soap_out_bes__overall_state_enumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bes__overall_state_enumeration[] =
{	{ (long)bes__overall_state_enumeration__New, "New" },
	{ (long)bes__overall_state_enumeration__Pending, "Pending" },
	{ (long)bes__overall_state_enumeration__StagingIn, "StagingIn" },
	{ (long)bes__overall_state_enumeration__ExecutionPending, "ExecutionPending" },
	{ (long)bes__overall_state_enumeration__Running, "Running" },
	{ (long)bes__overall_state_enumeration__ExecutionComplete, "ExecutionComplete" },
	{ (long)bes__overall_state_enumeration__StagingOut, "StagingOut" },
	{ (long)bes__overall_state_enumeration__CleaningUp, "CleaningUp" },
	{ (long)bes__overall_state_enumeration__Suspended, "Suspended" },
	{ (long)bes__overall_state_enumeration__ShuttingDown, "ShuttingDown" },
	{ (long)bes__overall_state_enumeration__NotKnown, "NotKnown" },
	{ (long)bes__overall_state_enumeration__Other, "Other" },
	{ (long)bes__overall_state_enumeration__Done, "Done" },
	{ (long)bes__overall_state_enumeration__Terminated, "Terminated" },
	{ (long)bes__overall_state_enumeration__Exception, "Exception" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bes__overall_state_enumeration2s(struct soap *soap, enum bes__overall_state_enumeration n)
{	const char *s = soap_code_str(soap_codes_bes__overall_state_enumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__overall_state_enumeration(struct soap *soap, const char *tag, int id, const enum bes__overall_state_enumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__overall_state_enumeration), type) || soap_send(soap, soap_bes__overall_state_enumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum bes__overall_state_enumeration * SOAP_FMAC4 soap_get_bes__overall_state_enumeration(struct soap *soap, enum bes__overall_state_enumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__overall_state_enumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bes__overall_state_enumeration(struct soap *soap, const char *s, enum bes__overall_state_enumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bes__overall_state_enumeration, s);
	if (map)
		*a = (enum bes__overall_state_enumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 14)))
			return soap->error = SOAP_TYPE;
		*a = (enum bes__overall_state_enumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum bes__overall_state_enumeration * SOAP_FMAC4 soap_in_bes__overall_state_enumeration(struct soap *soap, const char *tag, enum bes__overall_state_enumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum bes__overall_state_enumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__overall_state_enumeration, sizeof(enum bes__overall_state_enumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bes__overall_state_enumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum bes__overall_state_enumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__overall_state_enumeration, 0, sizeof(enum bes__overall_state_enumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Description_USCOREType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Description_USCOREType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Description_USCOREType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_jsdl__Description_USCOREType);
	if (soap_out_jsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_jsdl__Description_USCOREType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_jsdl__Description_USCOREType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_jsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_jsdl__Description_USCOREType, 0, sizeof(std::string), 0, soap_copy_jsdl__Description_USCOREType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_jsdl__Description_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Description_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Description_USCOREType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_jsdl__Description_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Description_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__Description_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Description_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_addressing__FaultCodesOpenEnumType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_addressing__FaultCodesOpenEnumType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_addressing__FaultCodesOpenEnumType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType);
	if (soap_out_addressing__FaultCodesOpenEnumType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_addressing__FaultCodesOpenEnumType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_addressing__FaultCodesOpenEnumType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType, 0, sizeof(std::string), 0, soap_copy_addressing__FaultCodesOpenEnumType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_addressing__FaultCodesOpenEnumType(struct soap *soap, int n)
{	return soap_instantiate_addressing__FaultCodesOpenEnumType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__FaultCodesOpenEnumType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_addressing__FaultCodesOpenEnumType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__FaultCodesOpenEnumType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__FaultCodesOpenEnumType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_addressing__RelationshipTypeOpenEnum(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_addressing__RelationshipTypeOpenEnum(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_addressing__RelationshipTypeOpenEnum(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum);
	if (soap_out_addressing__RelationshipTypeOpenEnum(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_addressing__RelationshipTypeOpenEnum(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_addressing__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum, 0, sizeof(std::string), 0, soap_copy_addressing__RelationshipTypeOpenEnum);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_addressing__RelationshipTypeOpenEnum(struct soap *soap, int n)
{	return soap_instantiate_addressing__RelationshipTypeOpenEnum(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__RelationshipTypeOpenEnum(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_addressing__RelationshipTypeOpenEnum(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__RelationshipTypeOpenEnum(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__RelationshipTypeOpenEnum(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void jsdl__SourceTarget_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__SourceTarget_USCOREType::jsdl__URI = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	this->jsdl__SourceTarget_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__SourceTarget_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->jsdl__SourceTarget_USCOREType::jsdl__URI);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__SourceTarget_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__SourceTarget_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "jsdl:URI", -1, &(a->jsdl__SourceTarget_USCOREType::jsdl__URI), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__SourceTarget_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__SourceTarget_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__SourceTarget_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get_jsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__SourceTarget_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__SourceTarget_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__SourceTarget_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__SourceTarget_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__URI1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "jsdl:URI", &(a->jsdl__SourceTarget_USCOREType::jsdl__URI), "xsd:anyURI"))
				{	soap_flag_jsdl__URI1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__SourceTarget_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType, 0, sizeof(jsdl__SourceTarget_USCOREType), 0, soap_copy_jsdl__SourceTarget_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__SourceTarget_USCOREType * SOAP_FMAC6 soap_new_jsdl__SourceTarget_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__SourceTarget_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__SourceTarget_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__SourceTarget_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType;
		if (size)
			*size = sizeof(jsdl__SourceTarget_USCOREType);
		((jsdl__SourceTarget_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__SourceTarget_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__SourceTarget_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__SourceTarget_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__SourceTarget_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__SourceTarget_USCOREType %p -> %p\n", q, p));
	*(jsdl__SourceTarget_USCOREType*)p = *(jsdl__SourceTarget_USCOREType*)q;
}

void jsdl__DataStaging_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName);
	this->jsdl__DataStaging_USCOREType::jsdl__FilesystemName = NULL;
	soap_default_jsdl__CreationFlagEnumeration(soap, &this->jsdl__DataStaging_USCOREType::jsdl__CreationFlag);
	this->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination = NULL;
	this->jsdl__DataStaging_USCOREType::jsdl__Source = NULL;
	this->jsdl__DataStaging_USCOREType::jsdl__Target = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	this->jsdl__DataStaging_USCOREType::name = NULL;
	this->jsdl__DataStaging_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__DataStaging_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName, SOAP_TYPE_bes_std__string);
	soap_serialize_std__string(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName);
	soap_serialize_PointerToxsd__NCName(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FilesystemName);
	soap_serialize_PointerTobool(soap, &this->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::jsdl__Source);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::jsdl__Target);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__DataStaging_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__DataStaging_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (((jsdl__DataStaging_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((jsdl__DataStaging_USCOREType*)a)->name->c_str());
	if (((jsdl__DataStaging_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__DataStaging_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType), type))
		return soap->error;
	if (soap_out_std__string(soap, "jsdl:FileName", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__FileName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__NCName(soap, "jsdl:FilesystemName", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__FilesystemName), ""))
		return soap->error;
	if (soap_out_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__CreationFlag), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "jsdl:DeleteOnTermination", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__Source), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__Target), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__DataStaging_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__DataStaging_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__DataStaging_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get_jsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__DataStaging_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__DataStaging_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__DataStaging_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__DataStaging_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__DataStaging_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdl__DataStaging_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((jsdl__DataStaging_USCOREType*)a)->name->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__DataStaging_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__FileName1 = 1;
	size_t soap_flag_jsdl__FilesystemName1 = 1;
	size_t soap_flag_jsdl__CreationFlag1 = 1;
	size_t soap_flag_jsdl__DeleteOnTermination1 = 1;
	size_t soap_flag_jsdl__Source1 = 1;
	size_t soap_flag_jsdl__Target1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jsdl:FileName", &(a->jsdl__DataStaging_USCOREType::jsdl__FileName), "xsd:string"))
				{	soap_flag_jsdl__FileName1--;
					continue;
				}
			if (soap_flag_jsdl__FilesystemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__NCName(soap, "jsdl:FilesystemName", &(a->jsdl__DataStaging_USCOREType::jsdl__FilesystemName), "xsd:NCName"))
				{	soap_flag_jsdl__FilesystemName1--;
					continue;
				}
			if (soap_flag_jsdl__CreationFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", &(a->jsdl__DataStaging_USCOREType::jsdl__CreationFlag), "jsdl:CreationFlagEnumeration"))
				{	soap_flag_jsdl__CreationFlag1--;
					continue;
				}
			if (soap_flag_jsdl__DeleteOnTermination1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "jsdl:DeleteOnTermination", &(a->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination), "xsd:boolean"))
				{	soap_flag_jsdl__DeleteOnTermination1--;
					continue;
				}
			if (soap_flag_jsdl__Source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", &(a->jsdl__DataStaging_USCOREType::jsdl__Source), "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Source1--;
					continue;
				}
			if (soap_flag_jsdl__Target1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", &(a->jsdl__DataStaging_USCOREType::jsdl__Target), "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Target1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__DataStaging_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType, 0, sizeof(jsdl__DataStaging_USCOREType), 0, soap_copy_jsdl__DataStaging_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__FileName1 > 0 || soap_flag_jsdl__CreationFlag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__DataStaging_USCOREType * SOAP_FMAC6 soap_new_jsdl__DataStaging_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__DataStaging_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType;
		if (size)
			*size = sizeof(jsdl__DataStaging_USCOREType);
		((jsdl__DataStaging_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__DataStaging_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__DataStaging_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__DataStaging_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__DataStaging_USCOREType %p -> %p\n", q, p));
	*(jsdl__DataStaging_USCOREType*)p = *(jsdl__DataStaging_USCOREType*)q;
}

void jsdl__OperatingSystemType_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, &this->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	this->jsdl__OperatingSystemType_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystemType_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystemType_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__OperatingSystemType_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", -1, &(a->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystemType_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystemType_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__OperatingSystemType_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystemType_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystemType_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__OperatingSystemName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", &(a->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName), "jsdl:OperatingSystemTypeEnumeration"))
				{	soap_flag_jsdl__OperatingSystemName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType, 0, sizeof(jsdl__OperatingSystemType_USCOREType), 0, soap_copy_jsdl__OperatingSystemType_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__OperatingSystemName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC6 soap_new_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystemType_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType;
		if (size)
			*size = sizeof(jsdl__OperatingSystemType_USCOREType);
		((jsdl__OperatingSystemType_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystemType_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystemType_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystemType_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystemType_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystemType_USCOREType*)p = *(jsdl__OperatingSystemType_USCOREType*)q;
}

void jsdl__OperatingSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType = NULL;
	this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion = NULL;
	this->jsdl__OperatingSystem_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	this->jsdl__OperatingSystem_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__OperatingSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:OperatingSystemVersion", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__OperatingSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__OperatingSystemType1 = 1;
	size_t soap_flag_jsdl__OperatingSystemVersion1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType), "jsdl:OperatingSystemType_Type"))
				{	soap_flag_jsdl__OperatingSystemType1--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystemVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:OperatingSystemVersion", &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion), "xsd:string"))
				{	soap_flag_jsdl__OperatingSystemVersion1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__OperatingSystem_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType, 0, sizeof(jsdl__OperatingSystem_USCOREType), 0, soap_copy_jsdl__OperatingSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__OperatingSystem_USCOREType * SOAP_FMAC6 soap_new_jsdl__OperatingSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__OperatingSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType;
		if (size)
			*size = sizeof(jsdl__OperatingSystem_USCOREType);
		((jsdl__OperatingSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystem_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystem_USCOREType*)p = *(jsdl__OperatingSystem_USCOREType*)q;
}

void jsdl__FileSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__FileSystem_USCOREType::jsdl__FileSystemType = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__Description = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__MountPoint = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__DiskSpace = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	soap_default_xsd__NCName(soap, &this->jsdl__FileSystem_USCOREType::name);
	this->jsdl__FileSystem_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__FileSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, &this->jsdl__FileSystem_USCOREType::jsdl__FileSystemType);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::jsdl__Description);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__FileSystem_USCOREType::jsdl__MountPoint);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::jsdl__DiskSpace);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__FileSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__FileSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (!((jsdl__FileSystem_USCOREType*)a)->name.empty())
		soap_set_attr(soap, "name", ((jsdl__FileSystem_USCOREType*)a)->name.c_str());
	if (((jsdl__FileSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__FileSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__FileSystemType), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:MountPoint", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__MountPoint), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__DiskSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__FileSystem_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__FileSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__FileSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__FileSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__FileSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__FileSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__FileSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__FileSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((jsdl__FileSystem_USCOREType*)a)->name.assign(s);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__FileSystem_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__FileSystemType1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	size_t soap_flag_jsdl__MountPoint1 = 1;
	size_t soap_flag_jsdl__DiskSpace1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", &(a->jsdl__FileSystem_USCOREType::jsdl__FileSystemType), "jsdl:FileSystemTypeEnumeration"))
				{	soap_flag_jsdl__FileSystemType1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__FileSystem_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap_flag_jsdl__MountPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:MountPoint", &(a->jsdl__FileSystem_USCOREType::jsdl__MountPoint), "xsd:string"))
				{	soap_flag_jsdl__MountPoint1--;
					continue;
				}
			if (soap_flag_jsdl__DiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", &(a->jsdl__FileSystem_USCOREType::jsdl__DiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__DiskSpace1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__FileSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType, 0, sizeof(jsdl__FileSystem_USCOREType), 0, soap_copy_jsdl__FileSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__FileSystem_USCOREType * SOAP_FMAC6 soap_new_jsdl__FileSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__FileSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType;
		if (size)
			*size = sizeof(jsdl__FileSystem_USCOREType);
		((jsdl__FileSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__FileSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__FileSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__FileSystem_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__FileSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__FileSystem_USCOREType*)p = *(jsdl__FileSystem_USCOREType*)q;
}

void jsdl__CPUArchitecture_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, &this->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	this->jsdl__CPUArchitecture_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__CPUArchitecture_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__CPUArchitecture_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__CPUArchitecture_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", -1, &(a->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__CPUArchitecture_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CPUArchitecture_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get_jsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__CPUArchitecture_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CPUArchitecture_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CPUArchitecture_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__CPUArchitectureName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CPUArchitectureName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", &(a->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName), "jsdl:ProcessorArchitectureEnumeration"))
				{	soap_flag_jsdl__CPUArchitectureName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType, 0, sizeof(jsdl__CPUArchitecture_USCOREType), 0, soap_copy_jsdl__CPUArchitecture_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__CPUArchitectureName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC6 soap_new_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CPUArchitecture_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType;
		if (size)
			*size = sizeof(jsdl__CPUArchitecture_USCOREType);
		((jsdl__CPUArchitecture_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CPUArchitecture_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CPUArchitecture_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CPUArchitecture_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CPUArchitecture_USCOREType %p -> %p\n", q, p));
	*(jsdl__CPUArchitecture_USCOREType*)p = *(jsdl__CPUArchitecture_USCOREType*)q;
}

void jsdl__CandidateHosts_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::jsdl__HostName);
	/* transient soap skipped */
}

void jsdl__CandidateHosts_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::jsdl__HostName);
	/* transient soap skipped */
}

int jsdl__CandidateHosts_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__CandidateHosts_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:HostName", -1, &(a->jsdl__CandidateHosts_USCOREType::jsdl__HostName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__CandidateHosts_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CandidateHosts_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get_jsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__CandidateHosts_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CandidateHosts_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CandidateHosts_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:HostName", &(a->jsdl__CandidateHosts_USCOREType::jsdl__HostName), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType, 0, sizeof(jsdl__CandidateHosts_USCOREType), 0, soap_copy_jsdl__CandidateHosts_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__CandidateHosts_USCOREType * SOAP_FMAC6 soap_new_jsdl__CandidateHosts_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__CandidateHosts_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CandidateHosts_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType;
		if (size)
			*size = sizeof(jsdl__CandidateHosts_USCOREType);
		((jsdl__CandidateHosts_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CandidateHosts_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CandidateHosts_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CandidateHosts_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CandidateHosts_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CandidateHosts_USCOREType %p -> %p\n", q, p));
	*(jsdl__CandidateHosts_USCOREType*)p = *(jsdl__CandidateHosts_USCOREType*)q;
}

void jsdl__Resources_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Resources_USCOREType::jsdl__CandidateHosts = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__FileSystem);
	this->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution = NULL;
	this->jsdl__Resources_USCOREType::jsdl__OperatingSystem = NULL;
	this->jsdl__Resources_USCOREType::jsdl__CPUArchitecture = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalCPUTime = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalCPUCount = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalResourceCount = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	this->jsdl__Resources_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Resources_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__CandidateHosts);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__FileSystem);
	soap_serialize_PointerTobool(soap, &this->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__CPUArchitecture);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalResourceCount);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Resources_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__Resources_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Resources_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Resources_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Resources_USCOREType *a, const char *type)
{
	if (((jsdl__Resources_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Resources_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__Resources_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", -1, &(a->jsdl__Resources_USCOREType::jsdl__CandidateHosts), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", -1, &(a->jsdl__Resources_USCOREType::jsdl__FileSystem), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "jsdl:ExclusiveExecution", -1, &(a->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", -1, &(a->jsdl__Resources_USCOREType::jsdl__OperatingSystem), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", -1, &(a->jsdl__Resources_USCOREType::jsdl__CPUArchitecture), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalResourceCount), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Resources_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Resources_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Resources_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get_jsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Resources_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Resources_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Resources_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__Resources_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Resources_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Resources_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__CandidateHosts1 = 1;
	size_t soap_flag_jsdl__ExclusiveExecution1 = 1;
	size_t soap_flag_jsdl__OperatingSystem1 = 1;
	size_t soap_flag_jsdl__CPUArchitecture1 = 1;
	size_t soap_flag_jsdl__IndividualCPUSpeed1 = 1;
	size_t soap_flag_jsdl__IndividualCPUTime1 = 1;
	size_t soap_flag_jsdl__IndividualCPUCount1 = 1;
	size_t soap_flag_jsdl__IndividualNetworkBandwidth1 = 1;
	size_t soap_flag_jsdl__IndividualPhysicalMemory1 = 1;
	size_t soap_flag_jsdl__IndividualVirtualMemory1 = 1;
	size_t soap_flag_jsdl__IndividualDiskSpace1 = 1;
	size_t soap_flag_jsdl__TotalCPUTime1 = 1;
	size_t soap_flag_jsdl__TotalCPUCount1 = 1;
	size_t soap_flag_jsdl__TotalPhysicalMemory1 = 1;
	size_t soap_flag_jsdl__TotalVirtualMemory1 = 1;
	size_t soap_flag_jsdl__TotalDiskSpace1 = 1;
	size_t soap_flag_jsdl__TotalResourceCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CandidateHosts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", &(a->jsdl__Resources_USCOREType::jsdl__CandidateHosts), "jsdl:CandidateHosts_Type"))
				{	soap_flag_jsdl__CandidateHosts1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", &(a->jsdl__Resources_USCOREType::jsdl__FileSystem), "jsdl:FileSystem_Type"))
					continue;
			if (soap_flag_jsdl__ExclusiveExecution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "jsdl:ExclusiveExecution", &(a->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution), "xsd:boolean"))
				{	soap_flag_jsdl__ExclusiveExecution1--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", &(a->jsdl__Resources_USCOREType::jsdl__OperatingSystem), "jsdl:OperatingSystem_Type"))
				{	soap_flag_jsdl__OperatingSystem1--;
					continue;
				}
			if (soap_flag_jsdl__CPUArchitecture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", &(a->jsdl__Resources_USCOREType::jsdl__CPUArchitecture), "jsdl:CPUArchitecture_Type"))
				{	soap_flag_jsdl__CPUArchitecture1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUSpeed1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUTime1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUCount1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualNetworkBandwidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", &(a->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualNetworkBandwidth1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", &(a->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualPhysicalMemory1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", &(a->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualVirtualMemory1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", &(a->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualDiskSpace1--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUTime1--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUCount1--;
					continue;
				}
			if (soap_flag_jsdl__TotalPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", &(a->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalPhysicalMemory1--;
					continue;
				}
			if (soap_flag_jsdl__TotalVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", &(a->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalVirtualMemory1--;
					continue;
				}
			if (soap_flag_jsdl__TotalDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", &(a->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalDiskSpace1--;
					continue;
				}
			if (soap_flag_jsdl__TotalResourceCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", &(a->jsdl__Resources_USCOREType::jsdl__TotalResourceCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalResourceCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Resources_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__Resources_USCOREType, 0, sizeof(jsdl__Resources_USCOREType), 0, soap_copy_jsdl__Resources_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Resources_USCOREType * SOAP_FMAC6 soap_new_jsdl__Resources_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Resources_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Resources_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Resources_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__Resources_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Resources_USCOREType;
		if (size)
			*size = sizeof(jsdl__Resources_USCOREType);
		((jsdl__Resources_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Resources_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Resources_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Resources_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Resources_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Resources_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Resources_USCOREType %p -> %p\n", q, p));
	*(jsdl__Resources_USCOREType*)p = *(jsdl__Resources_USCOREType*)q;
}

void jsdl__Application_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Application_USCOREType::jsdl__ApplicationName = NULL;
	this->jsdl__Application_USCOREType::jsdl__ApplicationVersion = NULL;
	this->jsdl__Application_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	this->jsdl__Application_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Application_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::jsdl__ApplicationName);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::jsdl__ApplicationVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__Application_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Application_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__Application_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Application_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Application_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Application_USCOREType *a, const char *type)
{
	if (((jsdl__Application_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Application_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__Application_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:ApplicationName", -1, &(a->jsdl__Application_USCOREType::jsdl__ApplicationName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:ApplicationVersion", -1, &(a->jsdl__Application_USCOREType::jsdl__ApplicationVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__Application_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Application_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Application_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Application_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_get_jsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Application_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Application_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_in_jsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Application_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__Application_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Application_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Application_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__ApplicationName1 = 1;
	size_t soap_flag_jsdl__ApplicationVersion1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__ApplicationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:ApplicationName", &(a->jsdl__Application_USCOREType::jsdl__ApplicationName), "xsd:string"))
				{	soap_flag_jsdl__ApplicationName1--;
					continue;
				}
			if (soap_flag_jsdl__ApplicationVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:ApplicationVersion", &(a->jsdl__Application_USCOREType::jsdl__ApplicationVersion), "xsd:string"))
				{	soap_flag_jsdl__ApplicationVersion1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__Application_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Application_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__Application_USCOREType, 0, sizeof(jsdl__Application_USCOREType), 0, soap_copy_jsdl__Application_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Application_USCOREType * SOAP_FMAC6 soap_new_jsdl__Application_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Application_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Application_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Application_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__Application_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Application_USCOREType;
		if (size)
			*size = sizeof(jsdl__Application_USCOREType);
		((jsdl__Application_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Application_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Application_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Application_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Application_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Application_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Application_USCOREType %p -> %p\n", q, p));
	*(jsdl__Application_USCOREType*)p = *(jsdl__Application_USCOREType*)q;
}

void jsdl__JobIdentification_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobIdentification_USCOREType::jsdl__JobName = NULL;
	this->jsdl__JobIdentification_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobProject);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	this->jsdl__JobIdentification_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobIdentification_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobName);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobProject);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobIdentification_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobIdentification_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:JobName", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobName), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:JobAnnotation", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:JobProject", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobProject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobIdentification_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobIdentification_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobIdentification_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobIdentification_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobIdentification_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobIdentification_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobIdentification_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__JobName1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:JobName", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobName), "xsd:string"))
				{	soap_flag_jsdl__JobName1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__JobIdentification_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:JobAnnotation", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:JobProject", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobProject), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobIdentification_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType, 0, sizeof(jsdl__JobIdentification_USCOREType), 0, soap_copy_jsdl__JobIdentification_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobIdentification_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobIdentification_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobIdentification_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobIdentification_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobIdentification_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobIdentification_USCOREType);
		((jsdl__JobIdentification_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobIdentification_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobIdentification_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobIdentification_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobIdentification_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobIdentification_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobIdentification_USCOREType*)p = *(jsdl__JobIdentification_USCOREType*)q;
}

void jsdl__JobDescription_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDescription_USCOREType::jsdl__JobIdentification = NULL;
	this->jsdl__JobDescription_USCOREType::jsdl__Application = NULL;
	this->jsdl__JobDescription_USCOREType::jsdl__Resources = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__DataStaging);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	this->jsdl__JobDescription_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobDescription_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__JobIdentification);
	soap_serialize_PointerTojsdl__Application_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__Application);
	soap_serialize_PointerTojsdl__Resources_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__Resources);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__DataStaging);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDescription_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobDescription_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (((jsdl__JobDescription_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDescription_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__JobIdentification), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__Application), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__Resources), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__DataStaging), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDescription_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDescription_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDescription_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobDescription_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDescription_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDescription_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__JobDescription_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDescription_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDescription_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__JobIdentification1 = 1;
	size_t soap_flag_jsdl__Application1 = 1;
	size_t soap_flag_jsdl__Resources1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobIdentification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", &(a->jsdl__JobDescription_USCOREType::jsdl__JobIdentification), "jsdl:JobIdentification_Type"))
				{	soap_flag_jsdl__JobIdentification1--;
					continue;
				}
			if (soap_flag_jsdl__Application1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", &(a->jsdl__JobDescription_USCOREType::jsdl__Application), "jsdl:Application_Type"))
				{	soap_flag_jsdl__Application1--;
					continue;
				}
			if (soap_flag_jsdl__Resources1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", &(a->jsdl__JobDescription_USCOREType::jsdl__Resources), "jsdl:Resources_Type"))
				{	soap_flag_jsdl__Resources1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", &(a->jsdl__JobDescription_USCOREType::jsdl__DataStaging), "jsdl:DataStaging_Type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDescription_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType, 0, sizeof(jsdl__JobDescription_USCOREType), 0, soap_copy_jsdl__JobDescription_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobDescription_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobDescription_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobDescription_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobDescription_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDescription_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobDescription_USCOREType);
		((jsdl__JobDescription_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDescription_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDescription_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDescription_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDescription_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDescription_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDescription_USCOREType*)p = *(jsdl__JobDescription_USCOREType*)q;
}

void jsdl__JobDefinition_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDefinition_USCOREType::jsdl__JobDescription = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	this->jsdl__JobDefinition_USCOREType::id = NULL;
	this->jsdl__JobDefinition_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobDefinition_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, &this->jsdl__JobDefinition_USCOREType::jsdl__JobDescription);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDefinition_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobDefinition_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (((jsdl__JobDefinition_USCOREType*)a)->id)
		soap_set_attr(soap, "id", ((jsdl__JobDefinition_USCOREType*)a)->id->c_str());
	if (((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", -1, &(a->jsdl__JobDefinition_USCOREType::jsdl__JobDescription), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDefinition_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDefinition_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDefinition_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobDefinition_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDefinition_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDefinition_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDefinition_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdl__JobDefinition_USCOREType*)a)->id = soap_new_std__string(soap, -1);
				((jsdl__JobDefinition_USCOREType*)a)->id->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__JobDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", &(a->jsdl__JobDefinition_USCOREType::jsdl__JobDescription), "jsdl:JobDescription_Type"))
				{	soap_flag_jsdl__JobDescription1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDefinition_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType, 0, sizeof(jsdl__JobDefinition_USCOREType), 0, soap_copy_jsdl__JobDefinition_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDescription1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobDefinition_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobDefinition_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobDefinition_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobDefinition_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDefinition_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobDefinition_USCOREType);
		((jsdl__JobDefinition_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDefinition_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDefinition_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDefinition_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDefinition_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDefinition_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDefinition_USCOREType*)p = *(jsdl__JobDefinition_USCOREType*)q;
}

void jsdl__RangeValue_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__RangeValue_USCOREType::UpperBoundedRange = NULL;
	this->jsdl__RangeValue_USCOREType::LowerBoundedRange = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	this->jsdl__RangeValue_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__RangeValue_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::UpperBoundedRange);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::LowerBoundedRange);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	/* transient soap skipped */
}

int jsdl__RangeValue_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__RangeValue_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (((jsdl__RangeValue_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__RangeValue_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, &(a->jsdl__RangeValue_USCOREType::Exact), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "jsdl:Range", -1, &(a->jsdl__RangeValue_USCOREType::Range), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__RangeValue_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__RangeValue_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get_jsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__RangeValue_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__RangeValue_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__RangeValue_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__RangeValue_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__RangeValue_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__RangeValue_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_UpperBoundedRange1 = 1;
	size_t soap_flag_LowerBoundedRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange1--;
					continue;
				}
			if (soap_flag_LowerBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "jsdl:Exact", &(a->jsdl__RangeValue_USCOREType::Exact), "jsdl:Exact_Type"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "jsdl:Range", &(a->jsdl__RangeValue_USCOREType::Range), "jsdl:Range_Type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType, 0, sizeof(jsdl__RangeValue_USCOREType), 0, soap_copy_jsdl__RangeValue_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__RangeValue_USCOREType * SOAP_FMAC6 soap_new_jsdl__RangeValue_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__RangeValue_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__RangeValue_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__RangeValue_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType;
		if (size)
			*size = sizeof(jsdl__RangeValue_USCOREType);
		((jsdl__RangeValue_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__RangeValue_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__RangeValue_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__RangeValue_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__RangeValue_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__RangeValue_USCOREType %p -> %p\n", q, p));
	*(jsdl__RangeValue_USCOREType*)p = *(jsdl__RangeValue_USCOREType*)q;
}

void jsdl__Range_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Range_USCOREType::LowerBound = NULL;
	this->jsdl__Range_USCOREType::UpperBound = NULL;
	this->jsdl__Range_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Range_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::LowerBound);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::UpperBound);
	/* transient soap skipped */
}

int jsdl__Range_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__Range_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Range_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Range_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Range_USCOREType *a, const char *type)
{
	if (((jsdl__Range_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Range_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_jsdl__Range_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", -1, &(a->jsdl__Range_USCOREType::LowerBound), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", -1, &(a->jsdl__Range_USCOREType::UpperBound), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Range_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Range_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_get_jsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Range_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Range_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_in_jsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Range_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__Range_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Range_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Range_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_LowerBound1 = 1;
	size_t soap_flag_UpperBound1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LowerBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", &(a->jsdl__Range_USCOREType::LowerBound), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBound1--;
					continue;
				}
			if (soap_flag_UpperBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", &(a->jsdl__Range_USCOREType::UpperBound), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBound1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Range_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_jsdl__Range_USCOREType, 0, sizeof(jsdl__Range_USCOREType), 0, soap_copy_jsdl__Range_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LowerBound1 > 0 || soap_flag_UpperBound1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Range_USCOREType * SOAP_FMAC6 soap_new_jsdl__Range_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Range_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Range_USCOREType;
		if (size)
			*size = sizeof(jsdl__Range_USCOREType);
		((jsdl__Range_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Range_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Range_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Range_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Range_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Range_USCOREType %p -> %p\n", q, p));
	*(jsdl__Range_USCOREType*)p = *(jsdl__Range_USCOREType*)q;
}

void jsdl__Exact_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Exact_USCOREType::__item);
	this->jsdl__Exact_USCOREType::epsilon = NULL;
	this->jsdl__Exact_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Exact_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Exact_USCOREType::__item, SOAP_TYPE_bes_double);
	/* transient soap skipped */
}

int jsdl__Exact_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__Exact_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Exact_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Exact_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Exact_USCOREType *a, const char *type)
{
	if (((jsdl__Exact_USCOREType*)a)->epsilon)
		soap_set_attr(soap, "epsilon", soap_double2s(soap, *((jsdl__Exact_USCOREType*)a)->epsilon));
	if (((jsdl__Exact_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Exact_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &a->jsdl__Exact_USCOREType::__item, "");
}

void *jsdl__Exact_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Exact_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_get_jsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Exact_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Exact_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_in_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Exact_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__Exact_USCOREType)
			return (jsdl__Exact_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "epsilon", 0);
		if (t)
		{
			if (!(((jsdl__Exact_USCOREType*)a)->epsilon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((jsdl__Exact_USCOREType*)a)->epsilon))
				return NULL;
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Exact_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Exact_USCOREType::__item), "jsdl:Exact_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__Exact_USCOREType * SOAP_FMAC6 soap_new_jsdl__Exact_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Exact_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Exact_USCOREType;
		if (size)
			*size = sizeof(jsdl__Exact_USCOREType);
		((jsdl__Exact_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Exact_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Exact_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Exact_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Exact_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Exact_USCOREType %p -> %p\n", q, p));
	*(jsdl__Exact_USCOREType*)p = *(jsdl__Exact_USCOREType*)q;
}

void jsdl__Boundary_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Boundary_USCOREType::__item);
	this->jsdl__Boundary_USCOREType::exclusiveBound = NULL;
	this->jsdl__Boundary_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Boundary_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Boundary_USCOREType::__item, SOAP_TYPE_bes_double);
	/* transient soap skipped */
}

int jsdl__Boundary_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_jsdl__Boundary_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Boundary_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Boundary_USCOREType *a, const char *type)
{
	if (((jsdl__Boundary_USCOREType*)a)->exclusiveBound)
		soap_set_attr(soap, "exclusiveBound", soap_bool2s(soap, *((jsdl__Boundary_USCOREType*)a)->exclusiveBound));
	if (((jsdl__Boundary_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Boundary_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &a->jsdl__Boundary_USCOREType::__item, "");
}

void *jsdl__Boundary_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Boundary_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_get_jsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Boundary_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Boundary_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_in_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Boundary_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_jsdl__Boundary_USCOREType)
			return (jsdl__Boundary_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "exclusiveBound", 0);
		if (t)
		{
			if (!(((jsdl__Boundary_USCOREType*)a)->exclusiveBound = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((jsdl__Boundary_USCOREType*)a)->exclusiveBound))
			return NULL;
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Boundary_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Boundary_USCOREType::__item), "jsdl:Boundary_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__Boundary_USCOREType * SOAP_FMAC6 soap_new_jsdl__Boundary_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Boundary_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Boundary_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Boundary_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_jsdl__Boundary_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Boundary_USCOREType;
		if (size)
			*size = sizeof(jsdl__Boundary_USCOREType);
		((jsdl__Boundary_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Boundary_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Boundary_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Boundary_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Boundary_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Boundary_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Boundary_USCOREType %p -> %p\n", q, p));
	*(jsdl__Boundary_USCOREType*)p = *(jsdl__Boundary_USCOREType*)q;
}

void addressing__AttributedNonNegativeIntegerType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->addressing__AttributedNonNegativeIntegerType::__item);
	this->addressing__AttributedNonNegativeIntegerType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void addressing__AttributedNonNegativeIntegerType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &this->addressing__AttributedNonNegativeIntegerType::__item);
	/* transient soap skipped */
}

int addressing__AttributedNonNegativeIntegerType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int addressing__AttributedNonNegativeIntegerType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_addressing__AttributedNonNegativeIntegerType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__AttributedNonNegativeIntegerType(struct soap *soap, const char *tag, int id, const addressing__AttributedNonNegativeIntegerType *a, const char *type)
{
	if (((addressing__AttributedNonNegativeIntegerType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((addressing__AttributedNonNegativeIntegerType*)a)->__anyAttribute);
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->addressing__AttributedNonNegativeIntegerType::__item, "");
}

void *addressing__AttributedNonNegativeIntegerType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_addressing__AttributedNonNegativeIntegerType(soap, this, tag, type);
}

SOAP_FMAC3 addressing__AttributedNonNegativeIntegerType * SOAP_FMAC4 soap_get_addressing__AttributedNonNegativeIntegerType(struct soap *soap, addressing__AttributedNonNegativeIntegerType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__AttributedNonNegativeIntegerType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *addressing__AttributedNonNegativeIntegerType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_addressing__AttributedNonNegativeIntegerType(soap, tag, this, type);
}

SOAP_FMAC3 addressing__AttributedNonNegativeIntegerType * SOAP_FMAC4 soap_in_addressing__AttributedNonNegativeIntegerType(struct soap *soap, const char *tag, addressing__AttributedNonNegativeIntegerType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (addressing__AttributedNonNegativeIntegerType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType, sizeof(addressing__AttributedNonNegativeIntegerType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType)
			return (addressing__AttributedNonNegativeIntegerType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((addressing__AttributedNonNegativeIntegerType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->addressing__AttributedNonNegativeIntegerType::__item), "addressing:AttributedNonNegativeIntegerType"))
		return NULL;
	return a;
}

SOAP_FMAC5 addressing__AttributedNonNegativeIntegerType * SOAP_FMAC6 soap_new_addressing__AttributedNonNegativeIntegerType(struct soap *soap, int n)
{	return soap_instantiate_addressing__AttributedNonNegativeIntegerType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__AttributedNonNegativeIntegerType(struct soap *soap, addressing__AttributedNonNegativeIntegerType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 addressing__AttributedNonNegativeIntegerType * SOAP_FMAC4 soap_instantiate_addressing__AttributedNonNegativeIntegerType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__AttributedNonNegativeIntegerType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new addressing__AttributedNonNegativeIntegerType;
		if (size)
			*size = sizeof(addressing__AttributedNonNegativeIntegerType);
		((addressing__AttributedNonNegativeIntegerType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new addressing__AttributedNonNegativeIntegerType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(addressing__AttributedNonNegativeIntegerType);
		for (int i = 0; i < n; i++)
			((addressing__AttributedNonNegativeIntegerType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (addressing__AttributedNonNegativeIntegerType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__AttributedNonNegativeIntegerType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying addressing__AttributedNonNegativeIntegerType %p -> %p\n", q, p));
	*(addressing__AttributedNonNegativeIntegerType*)p = *(addressing__AttributedNonNegativeIntegerType*)q;
}

void addressing__AttributedURIType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->addressing__AttributedURIType::__item);
	this->addressing__AttributedURIType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void addressing__AttributedURIType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->addressing__AttributedURIType::__item, SOAP_TYPE_bes_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->addressing__AttributedURIType::__item);
	/* transient soap skipped */
}

int addressing__AttributedURIType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_addressing__AttributedURIType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int addressing__AttributedURIType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_addressing__AttributedURIType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__AttributedURIType(struct soap *soap, const char *tag, int id, const addressing__AttributedURIType *a, const char *type)
{
	if (((addressing__AttributedURIType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((addressing__AttributedURIType*)a)->__anyAttribute);
	return soap_out_xsd__anyURI(soap, tag, id, &a->addressing__AttributedURIType::__item, "");
}

void *addressing__AttributedURIType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_addressing__AttributedURIType(soap, this, tag, type);
}

SOAP_FMAC3 addressing__AttributedURIType * SOAP_FMAC4 soap_get_addressing__AttributedURIType(struct soap *soap, addressing__AttributedURIType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *addressing__AttributedURIType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_addressing__AttributedURIType(soap, tag, this, type);
}

SOAP_FMAC3 addressing__AttributedURIType * SOAP_FMAC4 soap_in_addressing__AttributedURIType(struct soap *soap, const char *tag, addressing__AttributedURIType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (addressing__AttributedURIType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__AttributedURIType, sizeof(addressing__AttributedURIType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_addressing__AttributedURIType)
			return (addressing__AttributedURIType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((addressing__AttributedURIType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &(a->addressing__AttributedURIType::__item), "addressing:AttributedURIType"))
		return NULL;
	return a;
}

SOAP_FMAC5 addressing__AttributedURIType * SOAP_FMAC6 soap_new_addressing__AttributedURIType(struct soap *soap, int n)
{	return soap_instantiate_addressing__AttributedURIType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__AttributedURIType(struct soap *soap, addressing__AttributedURIType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 addressing__AttributedURIType * SOAP_FMAC4 soap_instantiate_addressing__AttributedURIType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__AttributedURIType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__AttributedURIType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new addressing__AttributedURIType;
		if (size)
			*size = sizeof(addressing__AttributedURIType);
		((addressing__AttributedURIType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new addressing__AttributedURIType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(addressing__AttributedURIType);
		for (int i = 0; i < n; i++)
			((addressing__AttributedURIType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (addressing__AttributedURIType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__AttributedURIType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying addressing__AttributedURIType %p -> %p\n", q, p));
	*(addressing__AttributedURIType*)p = *(addressing__AttributedURIType*)q;
}

void addressing__RelatesToType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->addressing__RelatesToType::__item);
	soap_default_addressing__RelationshipTypeOpenEnum(soap, &this->addressing__RelatesToType::RelationshipType);
	this->addressing__RelatesToType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void addressing__RelatesToType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->addressing__RelatesToType::__item, SOAP_TYPE_bes_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->addressing__RelatesToType::__item);
	/* transient soap skipped */
}

int addressing__RelatesToType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_addressing__RelatesToType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int addressing__RelatesToType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_addressing__RelatesToType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__RelatesToType(struct soap *soap, const char *tag, int id, const addressing__RelatesToType *a, const char *type)
{
	if (!((addressing__RelatesToType*)a)->RelationshipType.empty())
		soap_set_attr(soap, "RelationshipType", ((addressing__RelatesToType*)a)->RelationshipType.c_str());
	if (((addressing__RelatesToType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((addressing__RelatesToType*)a)->__anyAttribute);
	return soap_out_xsd__anyURI(soap, tag, id, &a->addressing__RelatesToType::__item, "");
}

void *addressing__RelatesToType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_addressing__RelatesToType(soap, this, tag, type);
}

SOAP_FMAC3 addressing__RelatesToType * SOAP_FMAC4 soap_get_addressing__RelatesToType(struct soap *soap, addressing__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *addressing__RelatesToType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_addressing__RelatesToType(soap, tag, this, type);
}

SOAP_FMAC3 addressing__RelatesToType * SOAP_FMAC4 soap_in_addressing__RelatesToType(struct soap *soap, const char *tag, addressing__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (addressing__RelatesToType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__RelatesToType, sizeof(addressing__RelatesToType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_addressing__RelatesToType)
			return (addressing__RelatesToType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "RelationshipType", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((addressing__RelatesToType*)a)->RelationshipType.assign(s);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((addressing__RelatesToType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__anyURI(soap, tag, &(a->addressing__RelatesToType::__item), "addressing:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC5 addressing__RelatesToType * SOAP_FMAC6 soap_new_addressing__RelatesToType(struct soap *soap, int n)
{	return soap_instantiate_addressing__RelatesToType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__RelatesToType(struct soap *soap, addressing__RelatesToType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 addressing__RelatesToType * SOAP_FMAC4 soap_instantiate_addressing__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__RelatesToType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__RelatesToType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new addressing__RelatesToType;
		if (size)
			*size = sizeof(addressing__RelatesToType);
		((addressing__RelatesToType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new addressing__RelatesToType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(addressing__RelatesToType);
		for (int i = 0; i < n; i++)
			((addressing__RelatesToType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (addressing__RelatesToType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__RelatesToType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying addressing__RelatesToType %p -> %p\n", q, p));
	*(addressing__RelatesToType*)p = *(addressing__RelatesToType*)q;
}

void addressing__MetadataType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->addressing__MetadataType::__any);
	this->addressing__MetadataType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void addressing__MetadataType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->addressing__MetadataType::__any);
	/* transient soap skipped */
}

int addressing__MetadataType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_addressing__MetadataType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int addressing__MetadataType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_addressing__MetadataType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__MetadataType(struct soap *soap, const char *tag, int id, const addressing__MetadataType *a, const char *type)
{
	if (((addressing__MetadataType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((addressing__MetadataType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_addressing__MetadataType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->addressing__MetadataType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *addressing__MetadataType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_addressing__MetadataType(soap, this, tag, type);
}

SOAP_FMAC3 addressing__MetadataType * SOAP_FMAC4 soap_get_addressing__MetadataType(struct soap *soap, addressing__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *addressing__MetadataType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_addressing__MetadataType(soap, tag, this, type);
}

SOAP_FMAC3 addressing__MetadataType * SOAP_FMAC4 soap_in_addressing__MetadataType(struct soap *soap, const char *tag, addressing__MetadataType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (addressing__MetadataType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__MetadataType, sizeof(addressing__MetadataType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_addressing__MetadataType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (addressing__MetadataType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((addressing__MetadataType*)a)->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->addressing__MetadataType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (addressing__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_addressing__MetadataType, 0, sizeof(addressing__MetadataType), 0, soap_copy_addressing__MetadataType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 addressing__MetadataType * SOAP_FMAC6 soap_new_addressing__MetadataType(struct soap *soap, int n)
{	return soap_instantiate_addressing__MetadataType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__MetadataType(struct soap *soap, addressing__MetadataType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 addressing__MetadataType * SOAP_FMAC4 soap_instantiate_addressing__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__MetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__MetadataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new addressing__MetadataType;
		if (size)
			*size = sizeof(addressing__MetadataType);
		((addressing__MetadataType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new addressing__MetadataType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(addressing__MetadataType);
		for (int i = 0; i < n; i++)
			((addressing__MetadataType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (addressing__MetadataType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__MetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying addressing__MetadataType %p -> %p\n", q, p));
	*(addressing__MetadataType*)p = *(addressing__MetadataType*)q;
}

void addressing__ReferenceParametersType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &this->addressing__ReferenceParametersType::__any);
	this->addressing__ReferenceParametersType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void addressing__ReferenceParametersType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->addressing__ReferenceParametersType::__any);
	/* transient soap skipped */
}

int addressing__ReferenceParametersType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_addressing__ReferenceParametersType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int addressing__ReferenceParametersType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_addressing__ReferenceParametersType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__ReferenceParametersType(struct soap *soap, const char *tag, int id, const addressing__ReferenceParametersType *a, const char *type)
{
	if (((addressing__ReferenceParametersType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((addressing__ReferenceParametersType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_addressing__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->addressing__ReferenceParametersType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *addressing__ReferenceParametersType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_addressing__ReferenceParametersType(soap, this, tag, type);
}

SOAP_FMAC3 addressing__ReferenceParametersType * SOAP_FMAC4 soap_get_addressing__ReferenceParametersType(struct soap *soap, addressing__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *addressing__ReferenceParametersType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_addressing__ReferenceParametersType(soap, tag, this, type);
}

SOAP_FMAC3 addressing__ReferenceParametersType * SOAP_FMAC4 soap_in_addressing__ReferenceParametersType(struct soap *soap, const char *tag, addressing__ReferenceParametersType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (addressing__ReferenceParametersType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__ReferenceParametersType, sizeof(addressing__ReferenceParametersType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_addressing__ReferenceParametersType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (addressing__ReferenceParametersType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((addressing__ReferenceParametersType*)a)->__anyAttribute))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->addressing__ReferenceParametersType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (addressing__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_addressing__ReferenceParametersType, 0, sizeof(addressing__ReferenceParametersType), 0, soap_copy_addressing__ReferenceParametersType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 addressing__ReferenceParametersType * SOAP_FMAC6 soap_new_addressing__ReferenceParametersType(struct soap *soap, int n)
{	return soap_instantiate_addressing__ReferenceParametersType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__ReferenceParametersType(struct soap *soap, addressing__ReferenceParametersType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 addressing__ReferenceParametersType * SOAP_FMAC4 soap_instantiate_addressing__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__ReferenceParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new addressing__ReferenceParametersType;
		if (size)
			*size = sizeof(addressing__ReferenceParametersType);
		((addressing__ReferenceParametersType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new addressing__ReferenceParametersType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(addressing__ReferenceParametersType);
		for (int i = 0; i < n; i++)
			((addressing__ReferenceParametersType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (addressing__ReferenceParametersType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying addressing__ReferenceParametersType %p -> %p\n", q, p));
	*(addressing__ReferenceParametersType*)p = *(addressing__ReferenceParametersType*)q;
}

void addressing__EndpointReferenceType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->addressing__EndpointReferenceType::Address = NULL;
	this->addressing__EndpointReferenceType::ReferenceParameters = NULL;
	this->addressing__EndpointReferenceType::addressing__Metadata = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->addressing__EndpointReferenceType::__any);
	this->addressing__EndpointReferenceType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void addressing__EndpointReferenceType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToaddressing__AttributedURIType(soap, &this->addressing__EndpointReferenceType::Address);
	soap_serialize_PointerToaddressing__ReferenceParametersType(soap, &this->addressing__EndpointReferenceType::ReferenceParameters);
	soap_serialize_PointerToaddressing__MetadataType(soap, &this->addressing__EndpointReferenceType::addressing__Metadata);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->addressing__EndpointReferenceType::__any);
	/* transient soap skipped */
}

int addressing__EndpointReferenceType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_addressing__EndpointReferenceType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int addressing__EndpointReferenceType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_addressing__EndpointReferenceType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_addressing__EndpointReferenceType(struct soap *soap, const char *tag, int id, const addressing__EndpointReferenceType *a, const char *type)
{
	if (((addressing__EndpointReferenceType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((addressing__EndpointReferenceType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_addressing__EndpointReferenceType), type))
		return soap->error;
	if (soap_out_PointerToaddressing__AttributedURIType(soap, "addressing:Address", -1, &(a->addressing__EndpointReferenceType::Address), ""))
		return soap->error;
	if (soap_out_PointerToaddressing__ReferenceParametersType(soap, "addressing:ReferenceParameters", -1, &(a->addressing__EndpointReferenceType::ReferenceParameters), ""))
		return soap->error;
	if (soap_out_PointerToaddressing__MetadataType(soap, "addressing:Metadata", -1, &(a->addressing__EndpointReferenceType::addressing__Metadata), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->addressing__EndpointReferenceType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *addressing__EndpointReferenceType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_addressing__EndpointReferenceType(soap, this, tag, type);
}

SOAP_FMAC3 addressing__EndpointReferenceType * SOAP_FMAC4 soap_get_addressing__EndpointReferenceType(struct soap *soap, addressing__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_addressing__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *addressing__EndpointReferenceType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_addressing__EndpointReferenceType(soap, tag, this, type);
}

SOAP_FMAC3 addressing__EndpointReferenceType * SOAP_FMAC4 soap_in_addressing__EndpointReferenceType(struct soap *soap, const char *tag, addressing__EndpointReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (addressing__EndpointReferenceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_addressing__EndpointReferenceType, sizeof(addressing__EndpointReferenceType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_addressing__EndpointReferenceType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (addressing__EndpointReferenceType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((addressing__EndpointReferenceType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_ReferenceParameters1 = 1;
	size_t soap_flag_addressing__Metadata1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__AttributedURIType(soap, "addressing:Address", &(a->addressing__EndpointReferenceType::Address), "addressing:AttributedURIType"))
				{	soap_flag_Address1--;
					continue;
				}
			if (soap_flag_ReferenceParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__ReferenceParametersType(soap, "addressing:ReferenceParameters", &(a->addressing__EndpointReferenceType::ReferenceParameters), "addressing:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters1--;
					continue;
				}
			if (soap_flag_addressing__Metadata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__MetadataType(soap, "addressing:Metadata", &(a->addressing__EndpointReferenceType::addressing__Metadata), "addressing:MetadataType"))
				{	soap_flag_addressing__Metadata1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->addressing__EndpointReferenceType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (addressing__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_addressing__EndpointReferenceType, 0, sizeof(addressing__EndpointReferenceType), 0, soap_copy_addressing__EndpointReferenceType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 addressing__EndpointReferenceType * SOAP_FMAC6 soap_new_addressing__EndpointReferenceType(struct soap *soap, int n)
{	return soap_instantiate_addressing__EndpointReferenceType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_addressing__EndpointReferenceType(struct soap *soap, addressing__EndpointReferenceType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 addressing__EndpointReferenceType * SOAP_FMAC4 soap_instantiate_addressing__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_addressing__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_addressing__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new addressing__EndpointReferenceType;
		if (size)
			*size = sizeof(addressing__EndpointReferenceType);
		((addressing__EndpointReferenceType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new addressing__EndpointReferenceType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(addressing__EndpointReferenceType);
		for (int i = 0; i < n; i++)
			((addressing__EndpointReferenceType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (addressing__EndpointReferenceType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_addressing__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying addressing__EndpointReferenceType %p -> %p\n", q, p));
	*(addressing__EndpointReferenceType*)p = *(addressing__EndpointReferenceType*)q;
}

void _bes__GetActivityJSDLDocumentsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(soap, &this->_bes__GetActivityJSDLDocumentsResponse::activity_jsdl_document);
	/* transient soap skipped */
}

void _bes__GetActivityJSDLDocumentsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(soap, &this->_bes__GetActivityJSDLDocumentsResponse::activity_jsdl_document);
	/* transient soap skipped */
}

int _bes__GetActivityJSDLDocumentsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__GetActivityJSDLDocumentsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__GetActivityJSDLDocumentsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityJSDLDocumentsResponse(struct soap *soap, const char *tag, int id, const _bes__GetActivityJSDLDocumentsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse), type))
		return soap->error;
	soap_element_result(soap, "bes:activity-jsdl-document");
	if (soap_out_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(soap, "bes:activity-jsdl-document", -1, &(a->_bes__GetActivityJSDLDocumentsResponse::activity_jsdl_document), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__GetActivityJSDLDocumentsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__GetActivityJSDLDocumentsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocumentsResponse * SOAP_FMAC4 soap_get__bes__GetActivityJSDLDocumentsResponse(struct soap *soap, _bes__GetActivityJSDLDocumentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityJSDLDocumentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__GetActivityJSDLDocumentsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__GetActivityJSDLDocumentsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocumentsResponse * SOAP_FMAC4 soap_in__bes__GetActivityJSDLDocumentsResponse(struct soap *soap, const char *tag, _bes__GetActivityJSDLDocumentsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__GetActivityJSDLDocumentsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse, sizeof(_bes__GetActivityJSDLDocumentsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__GetActivityJSDLDocumentsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(soap, "bes:activity-jsdl-document", &(a->_bes__GetActivityJSDLDocumentsResponse::activity_jsdl_document), "bes:activity-jsdl-document-type"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "bes:activity-jsdl-document");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__GetActivityJSDLDocumentsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse, 0, sizeof(_bes__GetActivityJSDLDocumentsResponse), 0, soap_copy__bes__GetActivityJSDLDocumentsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__GetActivityJSDLDocumentsResponse * SOAP_FMAC6 soap_new__bes__GetActivityJSDLDocumentsResponse(struct soap *soap, int n)
{	return soap_instantiate__bes__GetActivityJSDLDocumentsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__GetActivityJSDLDocumentsResponse(struct soap *soap, _bes__GetActivityJSDLDocumentsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocumentsResponse * SOAP_FMAC4 soap_instantiate__bes__GetActivityJSDLDocumentsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__GetActivityJSDLDocumentsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__GetActivityJSDLDocumentsResponse;
		if (size)
			*size = sizeof(_bes__GetActivityJSDLDocumentsResponse);
		((_bes__GetActivityJSDLDocumentsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__GetActivityJSDLDocumentsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__GetActivityJSDLDocumentsResponse);
		for (int i = 0; i < n; i++)
			((_bes__GetActivityJSDLDocumentsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__GetActivityJSDLDocumentsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__GetActivityJSDLDocumentsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__GetActivityJSDLDocumentsResponse %p -> %p\n", q, p));
	*(_bes__GetActivityJSDLDocumentsResponse*)p = *(_bes__GetActivityJSDLDocumentsResponse*)q;
}

void _bes__GetActivityJSDLDocuments::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, &this->_bes__GetActivityJSDLDocuments::activity_identifier);
	/* transient soap skipped */
}

void _bes__GetActivityJSDLDocuments::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, &this->_bes__GetActivityJSDLDocuments::activity_identifier);
	/* transient soap skipped */
}

int _bes__GetActivityJSDLDocuments::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__GetActivityJSDLDocuments::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__GetActivityJSDLDocuments(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityJSDLDocuments(struct soap *soap, const char *tag, int id, const _bes__GetActivityJSDLDocuments *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", -1, &(a->_bes__GetActivityJSDLDocuments::activity_identifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__GetActivityJSDLDocuments::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__GetActivityJSDLDocuments(soap, this, tag, type);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocuments * SOAP_FMAC4 soap_get__bes__GetActivityJSDLDocuments(struct soap *soap, _bes__GetActivityJSDLDocuments *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityJSDLDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__GetActivityJSDLDocuments::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__GetActivityJSDLDocuments(soap, tag, this, type);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocuments * SOAP_FMAC4 soap_in__bes__GetActivityJSDLDocuments(struct soap *soap, const char *tag, _bes__GetActivityJSDLDocuments *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__GetActivityJSDLDocuments *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments, sizeof(_bes__GetActivityJSDLDocuments), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__GetActivityJSDLDocuments)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__GetActivityJSDLDocuments *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", &(a->_bes__GetActivityJSDLDocuments::activity_identifier), "addressing:EndpointReferenceType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__GetActivityJSDLDocuments *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments, 0, sizeof(_bes__GetActivityJSDLDocuments), 0, soap_copy__bes__GetActivityJSDLDocuments);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__GetActivityJSDLDocuments * SOAP_FMAC6 soap_new__bes__GetActivityJSDLDocuments(struct soap *soap, int n)
{	return soap_instantiate__bes__GetActivityJSDLDocuments(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__GetActivityJSDLDocuments(struct soap *soap, _bes__GetActivityJSDLDocuments *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocuments * SOAP_FMAC4 soap_instantiate__bes__GetActivityJSDLDocuments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__GetActivityJSDLDocuments(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__GetActivityJSDLDocuments;
		if (size)
			*size = sizeof(_bes__GetActivityJSDLDocuments);
		((_bes__GetActivityJSDLDocuments*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__GetActivityJSDLDocuments[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__GetActivityJSDLDocuments);
		for (int i = 0; i < n; i++)
			((_bes__GetActivityJSDLDocuments*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__GetActivityJSDLDocuments*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__GetActivityJSDLDocuments(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__GetActivityJSDLDocuments %p -> %p\n", q, p));
	*(_bes__GetActivityJSDLDocuments*)p = *(_bes__GetActivityJSDLDocuments*)q;
}

void _bes__IsAcceptingNewActivitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_bes__IsAcceptingNewActivitiesResponse::response);
	/* transient soap skipped */
}

void _bes__IsAcceptingNewActivitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_bes__IsAcceptingNewActivitiesResponse::response, SOAP_TYPE_bes_bool);
	/* transient soap skipped */
}

int _bes__IsAcceptingNewActivitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__IsAcceptingNewActivitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__IsAcceptingNewActivitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__IsAcceptingNewActivitiesResponse(struct soap *soap, const char *tag, int id, const _bes__IsAcceptingNewActivitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse), type))
		return soap->error;
	soap_element_result(soap, "bes:response");
	if (soap_out_bool(soap, "bes:response", -1, &(a->_bes__IsAcceptingNewActivitiesResponse::response), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__IsAcceptingNewActivitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__IsAcceptingNewActivitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _bes__IsAcceptingNewActivitiesResponse * SOAP_FMAC4 soap_get__bes__IsAcceptingNewActivitiesResponse(struct soap *soap, _bes__IsAcceptingNewActivitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__IsAcceptingNewActivitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__IsAcceptingNewActivitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__IsAcceptingNewActivitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _bes__IsAcceptingNewActivitiesResponse * SOAP_FMAC4 soap_in__bes__IsAcceptingNewActivitiesResponse(struct soap *soap, const char *tag, _bes__IsAcceptingNewActivitiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__IsAcceptingNewActivitiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse, sizeof(_bes__IsAcceptingNewActivitiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__IsAcceptingNewActivitiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_response1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_response1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bes:response", &(a->_bes__IsAcceptingNewActivitiesResponse::response), "xsd:boolean"))
				{	soap_flag_response1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "bes:response");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__IsAcceptingNewActivitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse, 0, sizeof(_bes__IsAcceptingNewActivitiesResponse), 0, soap_copy__bes__IsAcceptingNewActivitiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_response1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__IsAcceptingNewActivitiesResponse * SOAP_FMAC6 soap_new__bes__IsAcceptingNewActivitiesResponse(struct soap *soap, int n)
{	return soap_instantiate__bes__IsAcceptingNewActivitiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__IsAcceptingNewActivitiesResponse(struct soap *soap, _bes__IsAcceptingNewActivitiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__IsAcceptingNewActivitiesResponse * SOAP_FMAC4 soap_instantiate__bes__IsAcceptingNewActivitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__IsAcceptingNewActivitiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__IsAcceptingNewActivitiesResponse;
		if (size)
			*size = sizeof(_bes__IsAcceptingNewActivitiesResponse);
		((_bes__IsAcceptingNewActivitiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__IsAcceptingNewActivitiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__IsAcceptingNewActivitiesResponse);
		for (int i = 0; i < n; i++)
			((_bes__IsAcceptingNewActivitiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__IsAcceptingNewActivitiesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__IsAcceptingNewActivitiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__IsAcceptingNewActivitiesResponse %p -> %p\n", q, p));
	*(_bes__IsAcceptingNewActivitiesResponse*)p = *(_bes__IsAcceptingNewActivitiesResponse*)q;
}

void _bes__RequestActivityStateChangesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobes__state_change_response_type(soap, &this->_bes__RequestActivityStateChangesResponse::state_change_response);
	/* transient soap skipped */
}

void _bes__RequestActivityStateChangesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobes__state_change_response_type(soap, &this->_bes__RequestActivityStateChangesResponse::state_change_response);
	/* transient soap skipped */
}

int _bes__RequestActivityStateChangesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__RequestActivityStateChangesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__RequestActivityStateChangesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__RequestActivityStateChangesResponse(struct soap *soap, const char *tag, int id, const _bes__RequestActivityStateChangesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse), type))
		return soap->error;
	soap_element_result(soap, "bes:state-change-response");
	if (soap_out_std__vectorTemplateOfPointerTobes__state_change_response_type(soap, "bes:state-change-response", -1, &(a->_bes__RequestActivityStateChangesResponse::state_change_response), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__RequestActivityStateChangesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__RequestActivityStateChangesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _bes__RequestActivityStateChangesResponse * SOAP_FMAC4 soap_get__bes__RequestActivityStateChangesResponse(struct soap *soap, _bes__RequestActivityStateChangesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__RequestActivityStateChangesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__RequestActivityStateChangesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__RequestActivityStateChangesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _bes__RequestActivityStateChangesResponse * SOAP_FMAC4 soap_in__bes__RequestActivityStateChangesResponse(struct soap *soap, const char *tag, _bes__RequestActivityStateChangesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__RequestActivityStateChangesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse, sizeof(_bes__RequestActivityStateChangesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__RequestActivityStateChangesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobes__state_change_response_type(soap, "bes:state-change-response", &(a->_bes__RequestActivityStateChangesResponse::state_change_response), "bes:state-change-response-type"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "bes:state-change-response");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__RequestActivityStateChangesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse, 0, sizeof(_bes__RequestActivityStateChangesResponse), 0, soap_copy__bes__RequestActivityStateChangesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__RequestActivityStateChangesResponse * SOAP_FMAC6 soap_new__bes__RequestActivityStateChangesResponse(struct soap *soap, int n)
{	return soap_instantiate__bes__RequestActivityStateChangesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__RequestActivityStateChangesResponse(struct soap *soap, _bes__RequestActivityStateChangesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__RequestActivityStateChangesResponse * SOAP_FMAC4 soap_instantiate__bes__RequestActivityStateChangesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__RequestActivityStateChangesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__RequestActivityStateChangesResponse;
		if (size)
			*size = sizeof(_bes__RequestActivityStateChangesResponse);
		((_bes__RequestActivityStateChangesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__RequestActivityStateChangesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__RequestActivityStateChangesResponse);
		for (int i = 0; i < n; i++)
			((_bes__RequestActivityStateChangesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__RequestActivityStateChangesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__RequestActivityStateChangesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__RequestActivityStateChangesResponse %p -> %p\n", q, p));
	*(_bes__RequestActivityStateChangesResponse*)p = *(_bes__RequestActivityStateChangesResponse*)q;
}

void _bes__RequestActivityStateChanges::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobes__state_change_request_type(soap, &this->_bes__RequestActivityStateChanges::state_change_request);
	/* transient soap skipped */
}

void _bes__RequestActivityStateChanges::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobes__state_change_request_type(soap, &this->_bes__RequestActivityStateChanges::state_change_request);
	/* transient soap skipped */
}

int _bes__RequestActivityStateChanges::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__RequestActivityStateChanges);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__RequestActivityStateChanges::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__RequestActivityStateChanges(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__RequestActivityStateChanges(struct soap *soap, const char *tag, int id, const _bes__RequestActivityStateChanges *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__RequestActivityStateChanges), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTobes__state_change_request_type(soap, "bes:state-change-request", -1, &(a->_bes__RequestActivityStateChanges::state_change_request), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__RequestActivityStateChanges::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__RequestActivityStateChanges(soap, this, tag, type);
}

SOAP_FMAC3 _bes__RequestActivityStateChanges * SOAP_FMAC4 soap_get__bes__RequestActivityStateChanges(struct soap *soap, _bes__RequestActivityStateChanges *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__RequestActivityStateChanges(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__RequestActivityStateChanges::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__RequestActivityStateChanges(soap, tag, this, type);
}

SOAP_FMAC3 _bes__RequestActivityStateChanges * SOAP_FMAC4 soap_in__bes__RequestActivityStateChanges(struct soap *soap, const char *tag, _bes__RequestActivityStateChanges *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__RequestActivityStateChanges *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__RequestActivityStateChanges, sizeof(_bes__RequestActivityStateChanges), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__RequestActivityStateChanges)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__RequestActivityStateChanges *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobes__state_change_request_type(soap, "bes:state-change-request", &(a->_bes__RequestActivityStateChanges::state_change_request), "bes:state-change-request-type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__RequestActivityStateChanges *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__RequestActivityStateChanges, 0, sizeof(_bes__RequestActivityStateChanges), 0, soap_copy__bes__RequestActivityStateChanges);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__RequestActivityStateChanges * SOAP_FMAC6 soap_new__bes__RequestActivityStateChanges(struct soap *soap, int n)
{	return soap_instantiate__bes__RequestActivityStateChanges(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__RequestActivityStateChanges(struct soap *soap, _bes__RequestActivityStateChanges *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__RequestActivityStateChanges * SOAP_FMAC4 soap_instantiate__bes__RequestActivityStateChanges(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__RequestActivityStateChanges(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__RequestActivityStateChanges, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__RequestActivityStateChanges;
		if (size)
			*size = sizeof(_bes__RequestActivityStateChanges);
		((_bes__RequestActivityStateChanges*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__RequestActivityStateChanges[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__RequestActivityStateChanges);
		for (int i = 0; i < n; i++)
			((_bes__RequestActivityStateChanges*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__RequestActivityStateChanges*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__RequestActivityStateChanges(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__RequestActivityStateChanges %p -> %p\n", q, p));
	*(_bes__RequestActivityStateChanges*)p = *(_bes__RequestActivityStateChanges*)q;
}

void _bes__GetActivityStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTobes__activity_status_type(soap, &this->_bes__GetActivityStatusResponse::activity_status);
	/* transient soap skipped */
}

void _bes__GetActivityStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTobes__activity_status_type(soap, &this->_bes__GetActivityStatusResponse::activity_status);
	/* transient soap skipped */
}

int _bes__GetActivityStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__GetActivityStatusResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__GetActivityStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__GetActivityStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityStatusResponse(struct soap *soap, const char *tag, int id, const _bes__GetActivityStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__GetActivityStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "bes:activity-status");
	if (soap_out_std__vectorTemplateOfPointerTobes__activity_status_type(soap, "bes:activity-status", -1, &(a->_bes__GetActivityStatusResponse::activity_status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__GetActivityStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__GetActivityStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _bes__GetActivityStatusResponse * SOAP_FMAC4 soap_get__bes__GetActivityStatusResponse(struct soap *soap, _bes__GetActivityStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__GetActivityStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__GetActivityStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _bes__GetActivityStatusResponse * SOAP_FMAC4 soap_in__bes__GetActivityStatusResponse(struct soap *soap, const char *tag, _bes__GetActivityStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__GetActivityStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__GetActivityStatusResponse, sizeof(_bes__GetActivityStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__GetActivityStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__GetActivityStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobes__activity_status_type(soap, "bes:activity-status", &(a->_bes__GetActivityStatusResponse::activity_status), "bes:activity-status-type"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "bes:activity-status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__GetActivityStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__GetActivityStatusResponse, 0, sizeof(_bes__GetActivityStatusResponse), 0, soap_copy__bes__GetActivityStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__GetActivityStatusResponse * SOAP_FMAC6 soap_new__bes__GetActivityStatusResponse(struct soap *soap, int n)
{	return soap_instantiate__bes__GetActivityStatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__GetActivityStatusResponse(struct soap *soap, _bes__GetActivityStatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__GetActivityStatusResponse * SOAP_FMAC4 soap_instantiate__bes__GetActivityStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__GetActivityStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__GetActivityStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__GetActivityStatusResponse;
		if (size)
			*size = sizeof(_bes__GetActivityStatusResponse);
		((_bes__GetActivityStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__GetActivityStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__GetActivityStatusResponse);
		for (int i = 0; i < n; i++)
			((_bes__GetActivityStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__GetActivityStatusResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__GetActivityStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__GetActivityStatusResponse %p -> %p\n", q, p));
	*(_bes__GetActivityStatusResponse*)p = *(_bes__GetActivityStatusResponse*)q;
}

void _bes__GetActivityStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, &this->_bes__GetActivityStatus::activity_identifier);
	/* transient soap skipped */
}

void _bes__GetActivityStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, &this->_bes__GetActivityStatus::activity_identifier);
	/* transient soap skipped */
}

int _bes__GetActivityStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__GetActivityStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__GetActivityStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__GetActivityStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__GetActivityStatus(struct soap *soap, const char *tag, int id, const _bes__GetActivityStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__GetActivityStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", -1, &(a->_bes__GetActivityStatus::activity_identifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__GetActivityStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__GetActivityStatus(soap, this, tag, type);
}

SOAP_FMAC3 _bes__GetActivityStatus * SOAP_FMAC4 soap_get__bes__GetActivityStatus(struct soap *soap, _bes__GetActivityStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__GetActivityStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__GetActivityStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__GetActivityStatus(soap, tag, this, type);
}

SOAP_FMAC3 _bes__GetActivityStatus * SOAP_FMAC4 soap_in__bes__GetActivityStatus(struct soap *soap, const char *tag, _bes__GetActivityStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__GetActivityStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__GetActivityStatus, sizeof(_bes__GetActivityStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__GetActivityStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__GetActivityStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", &(a->_bes__GetActivityStatus::activity_identifier), "addressing:EndpointReferenceType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__GetActivityStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__GetActivityStatus, 0, sizeof(_bes__GetActivityStatus), 0, soap_copy__bes__GetActivityStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__GetActivityStatus * SOAP_FMAC6 soap_new__bes__GetActivityStatus(struct soap *soap, int n)
{	return soap_instantiate__bes__GetActivityStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__GetActivityStatus(struct soap *soap, _bes__GetActivityStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__GetActivityStatus * SOAP_FMAC4 soap_instantiate__bes__GetActivityStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__GetActivityStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__GetActivityStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__GetActivityStatus;
		if (size)
			*size = sizeof(_bes__GetActivityStatus);
		((_bes__GetActivityStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__GetActivityStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__GetActivityStatus);
		for (int i = 0; i < n; i++)
			((_bes__GetActivityStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__GetActivityStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__GetActivityStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__GetActivityStatus %p -> %p\n", q, p));
	*(_bes__GetActivityStatus*)p = *(_bes__GetActivityStatus*)q;
}

void _bes__CreateActivityFromJSDLResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_bes__CreateActivityFromJSDLResponse::activity_identifier = NULL;
	/* transient soap skipped */
}

void _bes__CreateActivityFromJSDLResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToaddressing__EndpointReferenceType(soap, &this->_bes__CreateActivityFromJSDLResponse::activity_identifier);
	/* transient soap skipped */
}

int _bes__CreateActivityFromJSDLResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__CreateActivityFromJSDLResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__CreateActivityFromJSDLResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__CreateActivityFromJSDLResponse(struct soap *soap, const char *tag, int id, const _bes__CreateActivityFromJSDLResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse), type))
		return soap->error;
	if (a->activity_identifier)
		soap_element_result(soap, "bes:activity-identifier");
	if (soap_out_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", -1, &(a->_bes__CreateActivityFromJSDLResponse::activity_identifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__CreateActivityFromJSDLResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__CreateActivityFromJSDLResponse(soap, this, tag, type);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDLResponse * SOAP_FMAC4 soap_get__bes__CreateActivityFromJSDLResponse(struct soap *soap, _bes__CreateActivityFromJSDLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CreateActivityFromJSDLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__CreateActivityFromJSDLResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__CreateActivityFromJSDLResponse(soap, tag, this, type);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDLResponse * SOAP_FMAC4 soap_in__bes__CreateActivityFromJSDLResponse(struct soap *soap, const char *tag, _bes__CreateActivityFromJSDLResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__CreateActivityFromJSDLResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse, sizeof(_bes__CreateActivityFromJSDLResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__CreateActivityFromJSDLResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_activity_identifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_activity_identifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", &(a->_bes__CreateActivityFromJSDLResponse::activity_identifier), "addressing:EndpointReferenceType"))
				{	soap_flag_activity_identifier1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "bes:activity-identifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__CreateActivityFromJSDLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse, 0, sizeof(_bes__CreateActivityFromJSDLResponse), 0, soap_copy__bes__CreateActivityFromJSDLResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activity_identifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__CreateActivityFromJSDLResponse * SOAP_FMAC6 soap_new__bes__CreateActivityFromJSDLResponse(struct soap *soap, int n)
{	return soap_instantiate__bes__CreateActivityFromJSDLResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__CreateActivityFromJSDLResponse(struct soap *soap, _bes__CreateActivityFromJSDLResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDLResponse * SOAP_FMAC4 soap_instantiate__bes__CreateActivityFromJSDLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__CreateActivityFromJSDLResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__CreateActivityFromJSDLResponse;
		if (size)
			*size = sizeof(_bes__CreateActivityFromJSDLResponse);
		((_bes__CreateActivityFromJSDLResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__CreateActivityFromJSDLResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__CreateActivityFromJSDLResponse);
		for (int i = 0; i < n; i++)
			((_bes__CreateActivityFromJSDLResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__CreateActivityFromJSDLResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__CreateActivityFromJSDLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__CreateActivityFromJSDLResponse %p -> %p\n", q, p));
	*(_bes__CreateActivityFromJSDLResponse*)p = *(_bes__CreateActivityFromJSDLResponse*)q;
}

void _bes__CreateActivityFromJSDL::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_bes__CreateActivityFromJSDL::jsdl__JobDefinition = NULL;
	soap_default_bool(soap, &this->_bes__CreateActivityFromJSDL::create_suspended);
	/* transient soap skipped */
}

void _bes__CreateActivityFromJSDL::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &this->_bes__CreateActivityFromJSDL::jsdl__JobDefinition);
	soap_embedded(soap, &this->_bes__CreateActivityFromJSDL::create_suspended, SOAP_TYPE_bes_bool);
	/* transient soap skipped */
}

int _bes__CreateActivityFromJSDL::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes__bes__CreateActivityFromJSDL);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _bes__CreateActivityFromJSDL::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__bes__CreateActivityFromJSDL(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__bes__CreateActivityFromJSDL(struct soap *soap, const char *tag, int id, const _bes__CreateActivityFromJSDL *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes__bes__CreateActivityFromJSDL), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", -1, &(a->_bes__CreateActivityFromJSDL::jsdl__JobDefinition), ""))
		return soap->error;
	if (soap_out_bool(soap, "bes:create-suspended", -1, &(a->_bes__CreateActivityFromJSDL::create_suspended), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_bes__CreateActivityFromJSDL::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__bes__CreateActivityFromJSDL(soap, this, tag, type);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDL * SOAP_FMAC4 soap_get__bes__CreateActivityFromJSDL(struct soap *soap, _bes__CreateActivityFromJSDL *p, const char *tag, const char *type)
{
	if ((p = soap_in__bes__CreateActivityFromJSDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_bes__CreateActivityFromJSDL::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__bes__CreateActivityFromJSDL(soap, tag, this, type);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDL * SOAP_FMAC4 soap_in__bes__CreateActivityFromJSDL(struct soap *soap, const char *tag, _bes__CreateActivityFromJSDL *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_bes__CreateActivityFromJSDL *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes__bes__CreateActivityFromJSDL, sizeof(_bes__CreateActivityFromJSDL), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes__bes__CreateActivityFromJSDL)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_bes__CreateActivityFromJSDL *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jsdl__JobDefinition1 = 1;
	size_t soap_flag_create_suspended1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDefinition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", &(a->_bes__CreateActivityFromJSDL::jsdl__JobDefinition), "jsdl:JobDefinition_Type"))
				{	soap_flag_jsdl__JobDefinition1--;
					continue;
				}
			if (soap_flag_create_suspended1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bes:create-suspended", &(a->_bes__CreateActivityFromJSDL::create_suspended), "xsd:boolean"))
				{	soap_flag_create_suspended1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_bes__CreateActivityFromJSDL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes__bes__CreateActivityFromJSDL, 0, sizeof(_bes__CreateActivityFromJSDL), 0, soap_copy__bes__CreateActivityFromJSDL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDefinition1 > 0 || soap_flag_create_suspended1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _bes__CreateActivityFromJSDL * SOAP_FMAC6 soap_new__bes__CreateActivityFromJSDL(struct soap *soap, int n)
{	return soap_instantiate__bes__CreateActivityFromJSDL(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__bes__CreateActivityFromJSDL(struct soap *soap, _bes__CreateActivityFromJSDL *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDL * SOAP_FMAC4 soap_instantiate__bes__CreateActivityFromJSDL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__bes__CreateActivityFromJSDL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes__bes__CreateActivityFromJSDL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _bes__CreateActivityFromJSDL;
		if (size)
			*size = sizeof(_bes__CreateActivityFromJSDL);
		((_bes__CreateActivityFromJSDL*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _bes__CreateActivityFromJSDL[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_bes__CreateActivityFromJSDL);
		for (int i = 0; i < n; i++)
			((_bes__CreateActivityFromJSDL*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_bes__CreateActivityFromJSDL*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__bes__CreateActivityFromJSDL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _bes__CreateActivityFromJSDL %p -> %p\n", q, p));
	*(_bes__CreateActivityFromJSDL*)p = *(_bes__CreateActivityFromJSDL*)q;
}

void bes__BackendFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void bes__BackendFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__BackendFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__BackendFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__BackendFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__BackendFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__BackendFaultType(struct soap *soap, const char *tag, int id, const bes__BackendFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__BackendFaultType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__BackendFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__BackendFaultType(soap, this, tag, type);
}

SOAP_FMAC3 bes__BackendFaultType * SOAP_FMAC4 soap_get_bes__BackendFaultType(struct soap *soap, bes__BackendFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__BackendFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__BackendFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__BackendFaultType(soap, tag, this, type);
}

SOAP_FMAC3 bes__BackendFaultType * SOAP_FMAC4 soap_in_bes__BackendFaultType(struct soap *soap, const char *tag, bes__BackendFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__BackendFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__BackendFaultType, sizeof(bes__BackendFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__BackendFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__BackendFaultType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__BackendFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__BackendFaultType, 0, sizeof(bes__BackendFaultType), 0, soap_copy_bes__BackendFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__BackendFaultType * SOAP_FMAC6 soap_new_bes__BackendFaultType(struct soap *soap, int n)
{	return soap_instantiate_bes__BackendFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__BackendFaultType(struct soap *soap, bes__BackendFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__BackendFaultType * SOAP_FMAC4 soap_instantiate_bes__BackendFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__BackendFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__BackendFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__BackendFaultType;
		if (size)
			*size = sizeof(bes__BackendFaultType);
		((bes__BackendFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__BackendFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__BackendFaultType);
		for (int i = 0; i < n; i++)
			((bes__BackendFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__BackendFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__BackendFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__BackendFaultType %p -> %p\n", q, p));
	*(bes__BackendFaultType*)p = *(bes__BackendFaultType*)q;
}

void bes__JobSpecificationFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void bes__JobSpecificationFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__JobSpecificationFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__JobSpecificationFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__JobSpecificationFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__JobSpecificationFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__JobSpecificationFaultType(struct soap *soap, const char *tag, int id, const bes__JobSpecificationFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__JobSpecificationFaultType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__JobSpecificationFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__JobSpecificationFaultType(soap, this, tag, type);
}

SOAP_FMAC3 bes__JobSpecificationFaultType * SOAP_FMAC4 soap_get_bes__JobSpecificationFaultType(struct soap *soap, bes__JobSpecificationFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__JobSpecificationFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__JobSpecificationFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__JobSpecificationFaultType(soap, tag, this, type);
}

SOAP_FMAC3 bes__JobSpecificationFaultType * SOAP_FMAC4 soap_in_bes__JobSpecificationFaultType(struct soap *soap, const char *tag, bes__JobSpecificationFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__JobSpecificationFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__JobSpecificationFaultType, sizeof(bes__JobSpecificationFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__JobSpecificationFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__JobSpecificationFaultType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__JobSpecificationFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__JobSpecificationFaultType, 0, sizeof(bes__JobSpecificationFaultType), 0, soap_copy_bes__JobSpecificationFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__JobSpecificationFaultType * SOAP_FMAC6 soap_new_bes__JobSpecificationFaultType(struct soap *soap, int n)
{	return soap_instantiate_bes__JobSpecificationFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__JobSpecificationFaultType(struct soap *soap, bes__JobSpecificationFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__JobSpecificationFaultType * SOAP_FMAC4 soap_instantiate_bes__JobSpecificationFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__JobSpecificationFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__JobSpecificationFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__JobSpecificationFaultType;
		if (size)
			*size = sizeof(bes__JobSpecificationFaultType);
		((bes__JobSpecificationFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__JobSpecificationFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__JobSpecificationFaultType);
		for (int i = 0; i < n; i++)
			((bes__JobSpecificationFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__JobSpecificationFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__JobSpecificationFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__JobSpecificationFaultType %p -> %p\n", q, p));
	*(bes__JobSpecificationFaultType*)p = *(bes__JobSpecificationFaultType*)q;
}

void bes__UnsupportedFeatureFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void bes__UnsupportedFeatureFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__UnsupportedFeatureFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__UnsupportedFeatureFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__UnsupportedFeatureFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, int id, const bes__UnsupportedFeatureFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__UnsupportedFeatureFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__UnsupportedFeatureFaultType(soap, this, tag, type);
}

SOAP_FMAC3 bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_get_bes__UnsupportedFeatureFaultType(struct soap *soap, bes__UnsupportedFeatureFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__UnsupportedFeatureFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__UnsupportedFeatureFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__UnsupportedFeatureFaultType(soap, tag, this, type);
}

SOAP_FMAC3 bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_in_bes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, bes__UnsupportedFeatureFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__UnsupportedFeatureFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType, sizeof(bes__UnsupportedFeatureFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__UnsupportedFeatureFaultType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__UnsupportedFeatureFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType, 0, sizeof(bes__UnsupportedFeatureFaultType), 0, soap_copy_bes__UnsupportedFeatureFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__UnsupportedFeatureFaultType * SOAP_FMAC6 soap_new_bes__UnsupportedFeatureFaultType(struct soap *soap, int n)
{	return soap_instantiate_bes__UnsupportedFeatureFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__UnsupportedFeatureFaultType(struct soap *soap, bes__UnsupportedFeatureFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__UnsupportedFeatureFaultType * SOAP_FMAC4 soap_instantiate_bes__UnsupportedFeatureFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__UnsupportedFeatureFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__UnsupportedFeatureFaultType;
		if (size)
			*size = sizeof(bes__UnsupportedFeatureFaultType);
		((bes__UnsupportedFeatureFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__UnsupportedFeatureFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__UnsupportedFeatureFaultType);
		for (int i = 0; i < n; i++)
			((bes__UnsupportedFeatureFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__UnsupportedFeatureFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__UnsupportedFeatureFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__UnsupportedFeatureFaultType %p -> %p\n", q, p));
	*(bes__UnsupportedFeatureFaultType*)p = *(bes__UnsupportedFeatureFaultType*)q;
}

void bes__UnsupportedJSDLFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void bes__UnsupportedJSDLFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__UnsupportedJSDLFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__UnsupportedJSDLFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__UnsupportedJSDLFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__UnsupportedJSDLFaultType(struct soap *soap, const char *tag, int id, const bes__UnsupportedJSDLFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__UnsupportedJSDLFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__UnsupportedJSDLFaultType(soap, this, tag, type);
}

SOAP_FMAC3 bes__UnsupportedJSDLFaultType * SOAP_FMAC4 soap_get_bes__UnsupportedJSDLFaultType(struct soap *soap, bes__UnsupportedJSDLFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__UnsupportedJSDLFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__UnsupportedJSDLFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__UnsupportedJSDLFaultType(soap, tag, this, type);
}

SOAP_FMAC3 bes__UnsupportedJSDLFaultType * SOAP_FMAC4 soap_in_bes__UnsupportedJSDLFaultType(struct soap *soap, const char *tag, bes__UnsupportedJSDLFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__UnsupportedJSDLFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType, sizeof(bes__UnsupportedJSDLFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__UnsupportedJSDLFaultType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__UnsupportedJSDLFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType, 0, sizeof(bes__UnsupportedJSDLFaultType), 0, soap_copy_bes__UnsupportedJSDLFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__UnsupportedJSDLFaultType * SOAP_FMAC6 soap_new_bes__UnsupportedJSDLFaultType(struct soap *soap, int n)
{	return soap_instantiate_bes__UnsupportedJSDLFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__UnsupportedJSDLFaultType(struct soap *soap, bes__UnsupportedJSDLFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__UnsupportedJSDLFaultType * SOAP_FMAC4 soap_instantiate_bes__UnsupportedJSDLFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__UnsupportedJSDLFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__UnsupportedJSDLFaultType;
		if (size)
			*size = sizeof(bes__UnsupportedJSDLFaultType);
		((bes__UnsupportedJSDLFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__UnsupportedJSDLFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__UnsupportedJSDLFaultType);
		for (int i = 0; i < n; i++)
			((bes__UnsupportedJSDLFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__UnsupportedJSDLFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__UnsupportedJSDLFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__UnsupportedJSDLFaultType %p -> %p\n", q, p));
	*(bes__UnsupportedJSDLFaultType*)p = *(bes__UnsupportedJSDLFaultType*)q;
}

void bes__BadlyFormedJSDLDocumentFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void bes__BadlyFormedJSDLDocumentFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__BadlyFormedJSDLDocumentFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__BadlyFormedJSDLDocumentFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__BadlyFormedJSDLDocumentFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, const char *tag, int id, const bes__BadlyFormedJSDLDocumentFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__BadlyFormedJSDLDocumentFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__BadlyFormedJSDLDocumentFaultType(soap, this, tag, type);
}

SOAP_FMAC3 bes__BadlyFormedJSDLDocumentFaultType * SOAP_FMAC4 soap_get_bes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, bes__BadlyFormedJSDLDocumentFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__BadlyFormedJSDLDocumentFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__BadlyFormedJSDLDocumentFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__BadlyFormedJSDLDocumentFaultType(soap, tag, this, type);
}

SOAP_FMAC3 bes__BadlyFormedJSDLDocumentFaultType * SOAP_FMAC4 soap_in_bes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, const char *tag, bes__BadlyFormedJSDLDocumentFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__BadlyFormedJSDLDocumentFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType, sizeof(bes__BadlyFormedJSDLDocumentFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__BadlyFormedJSDLDocumentFaultType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__BadlyFormedJSDLDocumentFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType, 0, sizeof(bes__BadlyFormedJSDLDocumentFaultType), 0, soap_copy_bes__BadlyFormedJSDLDocumentFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__BadlyFormedJSDLDocumentFaultType * SOAP_FMAC6 soap_new_bes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, int n)
{	return soap_instantiate_bes__BadlyFormedJSDLDocumentFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, bes__BadlyFormedJSDLDocumentFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__BadlyFormedJSDLDocumentFaultType * SOAP_FMAC4 soap_instantiate_bes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__BadlyFormedJSDLDocumentFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__BadlyFormedJSDLDocumentFaultType;
		if (size)
			*size = sizeof(bes__BadlyFormedJSDLDocumentFaultType);
		((bes__BadlyFormedJSDLDocumentFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__BadlyFormedJSDLDocumentFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__BadlyFormedJSDLDocumentFaultType);
		for (int i = 0; i < n; i++)
			((bes__BadlyFormedJSDLDocumentFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__BadlyFormedJSDLDocumentFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__BadlyFormedJSDLDocumentFaultType %p -> %p\n", q, p));
	*(bes__BadlyFormedJSDLDocumentFaultType*)p = *(bes__BadlyFormedJSDLDocumentFaultType*)q;
}

void bes__NotAcceptingNewActivitiesFaultType::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void bes__NotAcceptingNewActivitiesFaultType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__NotAcceptingNewActivitiesFaultType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__NotAcceptingNewActivitiesFaultType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__NotAcceptingNewActivitiesFaultType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, int id, const bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__NotAcceptingNewActivitiesFaultType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__NotAcceptingNewActivitiesFaultType(soap, this, tag, type);
}

SOAP_FMAC3 bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_get_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, bes__NotAcceptingNewActivitiesFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__NotAcceptingNewActivitiesFaultType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__NotAcceptingNewActivitiesFaultType(soap, tag, this, type);
}

SOAP_FMAC3 bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_in_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, bes__NotAcceptingNewActivitiesFaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__NotAcceptingNewActivitiesFaultType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType, sizeof(bes__NotAcceptingNewActivitiesFaultType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__NotAcceptingNewActivitiesFaultType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__NotAcceptingNewActivitiesFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType, 0, sizeof(bes__NotAcceptingNewActivitiesFaultType), 0, soap_copy_bes__NotAcceptingNewActivitiesFaultType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC6 soap_new_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, int n)
{	return soap_instantiate_bes__NotAcceptingNewActivitiesFaultType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, bes__NotAcceptingNewActivitiesFaultType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__NotAcceptingNewActivitiesFaultType * SOAP_FMAC4 soap_instantiate_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__NotAcceptingNewActivitiesFaultType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__NotAcceptingNewActivitiesFaultType;
		if (size)
			*size = sizeof(bes__NotAcceptingNewActivitiesFaultType);
		((bes__NotAcceptingNewActivitiesFaultType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__NotAcceptingNewActivitiesFaultType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__NotAcceptingNewActivitiesFaultType);
		for (int i = 0; i < n; i++)
			((bes__NotAcceptingNewActivitiesFaultType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__NotAcceptingNewActivitiesFaultType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__NotAcceptingNewActivitiesFaultType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__NotAcceptingNewActivitiesFaultType %p -> %p\n", q, p));
	*(bes__NotAcceptingNewActivitiesFaultType*)p = *(bes__NotAcceptingNewActivitiesFaultType*)q;
}

void bes__activity_jsdl_document_type::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->bes__activity_jsdl_document_type::activity_identifier = NULL;
	this->bes__activity_jsdl_document_type::jsdl__JobDefinition = NULL;
	/* transient soap skipped */
}

void bes__activity_jsdl_document_type::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToaddressing__EndpointReferenceType(soap, &this->bes__activity_jsdl_document_type::activity_identifier);
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &this->bes__activity_jsdl_document_type::jsdl__JobDefinition);
	/* transient soap skipped */
}

int bes__activity_jsdl_document_type::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__activity_jsdl_document_type);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__activity_jsdl_document_type::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__activity_jsdl_document_type(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__activity_jsdl_document_type(struct soap *soap, const char *tag, int id, const bes__activity_jsdl_document_type *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__activity_jsdl_document_type), type))
		return soap->error;
	if (soap_out_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", -1, &(a->bes__activity_jsdl_document_type::activity_identifier), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", -1, &(a->bes__activity_jsdl_document_type::jsdl__JobDefinition), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__activity_jsdl_document_type::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__activity_jsdl_document_type(soap, this, tag, type);
}

SOAP_FMAC3 bes__activity_jsdl_document_type * SOAP_FMAC4 soap_get_bes__activity_jsdl_document_type(struct soap *soap, bes__activity_jsdl_document_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__activity_jsdl_document_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__activity_jsdl_document_type::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__activity_jsdl_document_type(soap, tag, this, type);
}

SOAP_FMAC3 bes__activity_jsdl_document_type * SOAP_FMAC4 soap_in_bes__activity_jsdl_document_type(struct soap *soap, const char *tag, bes__activity_jsdl_document_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__activity_jsdl_document_type *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__activity_jsdl_document_type, sizeof(bes__activity_jsdl_document_type), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__activity_jsdl_document_type)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__activity_jsdl_document_type *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_activity_identifier1 = 1;
	size_t soap_flag_jsdl__JobDefinition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_activity_identifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", &(a->bes__activity_jsdl_document_type::activity_identifier), "addressing:EndpointReferenceType"))
				{	soap_flag_activity_identifier1--;
					continue;
				}
			if (soap_flag_jsdl__JobDefinition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", &(a->bes__activity_jsdl_document_type::jsdl__JobDefinition), "jsdl:JobDefinition_Type"))
				{	soap_flag_jsdl__JobDefinition1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__activity_jsdl_document_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__activity_jsdl_document_type, 0, sizeof(bes__activity_jsdl_document_type), 0, soap_copy_bes__activity_jsdl_document_type);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activity_identifier1 > 0 || soap_flag_jsdl__JobDefinition1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__activity_jsdl_document_type * SOAP_FMAC6 soap_new_bes__activity_jsdl_document_type(struct soap *soap, int n)
{	return soap_instantiate_bes__activity_jsdl_document_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__activity_jsdl_document_type(struct soap *soap, bes__activity_jsdl_document_type *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__activity_jsdl_document_type * SOAP_FMAC4 soap_instantiate_bes__activity_jsdl_document_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__activity_jsdl_document_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__activity_jsdl_document_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__activity_jsdl_document_type;
		if (size)
			*size = sizeof(bes__activity_jsdl_document_type);
		((bes__activity_jsdl_document_type*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__activity_jsdl_document_type[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__activity_jsdl_document_type);
		for (int i = 0; i < n; i++)
			((bes__activity_jsdl_document_type*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__activity_jsdl_document_type*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__activity_jsdl_document_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__activity_jsdl_document_type %p -> %p\n", q, p));
	*(bes__activity_jsdl_document_type*)p = *(bes__activity_jsdl_document_type*)q;
}

void bes__state_change_response_type::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->bes__state_change_response_type::activity_identifier = NULL;
	this->bes__state_change_response_type::description = NULL;
	soap_default_bes__state_change_response_enumeration(soap, &this->bes__state_change_response_type::response);
	/* transient soap skipped */
}

void bes__state_change_response_type::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToaddressing__EndpointReferenceType(soap, &this->bes__state_change_response_type::activity_identifier);
	soap_serialize_PointerTostd__string(soap, &this->bes__state_change_response_type::description);
	/* transient soap skipped */
}

int bes__state_change_response_type::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__state_change_response_type);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__state_change_response_type::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__state_change_response_type(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__state_change_response_type(struct soap *soap, const char *tag, int id, const bes__state_change_response_type *a, const char *type)
{
	soap_set_attr(soap, "response", soap_bes__state_change_response_enumeration2s(soap, ((bes__state_change_response_type*)a)->response));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__state_change_response_type), type))
		return soap->error;
	if (soap_out_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", -1, &(a->bes__state_change_response_type::activity_identifier), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "bes:description", -1, &(a->bes__state_change_response_type::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__state_change_response_type::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__state_change_response_type(soap, this, tag, type);
}

SOAP_FMAC3 bes__state_change_response_type * SOAP_FMAC4 soap_get_bes__state_change_response_type(struct soap *soap, bes__state_change_response_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__state_change_response_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__state_change_response_type::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__state_change_response_type(soap, tag, this, type);
}

SOAP_FMAC3 bes__state_change_response_type * SOAP_FMAC4 soap_in_bes__state_change_response_type(struct soap *soap, const char *tag, bes__state_change_response_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__state_change_response_type *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__state_change_response_type, sizeof(bes__state_change_response_type), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__state_change_response_type)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__state_change_response_type *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bes__state_change_response_enumeration(soap, soap_attr_value(soap, "response", 1), &((bes__state_change_response_type*)a)->response))
		return NULL;
	size_t soap_flag_activity_identifier1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_activity_identifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", &(a->bes__state_change_response_type::activity_identifier), "addressing:EndpointReferenceType"))
				{	soap_flag_activity_identifier1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "bes:description", &(a->bes__state_change_response_type::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__state_change_response_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__state_change_response_type, 0, sizeof(bes__state_change_response_type), 0, soap_copy_bes__state_change_response_type);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activity_identifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__state_change_response_type * SOAP_FMAC6 soap_new_bes__state_change_response_type(struct soap *soap, int n)
{	return soap_instantiate_bes__state_change_response_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__state_change_response_type(struct soap *soap, bes__state_change_response_type *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__state_change_response_type * SOAP_FMAC4 soap_instantiate_bes__state_change_response_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__state_change_response_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__state_change_response_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__state_change_response_type;
		if (size)
			*size = sizeof(bes__state_change_response_type);
		((bes__state_change_response_type*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__state_change_response_type[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__state_change_response_type);
		for (int i = 0; i < n; i++)
			((bes__state_change_response_type*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__state_change_response_type*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__state_change_response_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__state_change_response_type %p -> %p\n", q, p));
	*(bes__state_change_response_type*)p = *(bes__state_change_response_type*)q;
}

void bes__state_change_request_type::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->bes__state_change_request_type::activity_identifier = NULL;
	this->bes__state_change_request_type::requested_state_change = NULL;
	/* transient soap skipped */
}

void bes__state_change_request_type::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToaddressing__EndpointReferenceType(soap, &this->bes__state_change_request_type::activity_identifier);
	soap_serialize_PointerTobes__requested_state_change_type(soap, &this->bes__state_change_request_type::requested_state_change);
	/* transient soap skipped */
}

int bes__state_change_request_type::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__state_change_request_type);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__state_change_request_type::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__state_change_request_type(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__state_change_request_type(struct soap *soap, const char *tag, int id, const bes__state_change_request_type *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__state_change_request_type), type))
		return soap->error;
	if (soap_out_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", -1, &(a->bes__state_change_request_type::activity_identifier), ""))
		return soap->error;
	if (soap_out_PointerTobes__requested_state_change_type(soap, "bes:requested-state-change", -1, &(a->bes__state_change_request_type::requested_state_change), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__state_change_request_type::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__state_change_request_type(soap, this, tag, type);
}

SOAP_FMAC3 bes__state_change_request_type * SOAP_FMAC4 soap_get_bes__state_change_request_type(struct soap *soap, bes__state_change_request_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__state_change_request_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__state_change_request_type::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__state_change_request_type(soap, tag, this, type);
}

SOAP_FMAC3 bes__state_change_request_type * SOAP_FMAC4 soap_in_bes__state_change_request_type(struct soap *soap, const char *tag, bes__state_change_request_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__state_change_request_type *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__state_change_request_type, sizeof(bes__state_change_request_type), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__state_change_request_type)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__state_change_request_type *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_activity_identifier1 = 1;
	size_t soap_flag_requested_state_change1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_activity_identifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", &(a->bes__state_change_request_type::activity_identifier), "addressing:EndpointReferenceType"))
				{	soap_flag_activity_identifier1--;
					continue;
				}
			if (soap_flag_requested_state_change1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__requested_state_change_type(soap, "bes:requested-state-change", &(a->bes__state_change_request_type::requested_state_change), "bes:requested-state-change-type"))
				{	soap_flag_requested_state_change1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__state_change_request_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__state_change_request_type, 0, sizeof(bes__state_change_request_type), 0, soap_copy_bes__state_change_request_type);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activity_identifier1 > 0 || soap_flag_requested_state_change1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__state_change_request_type * SOAP_FMAC6 soap_new_bes__state_change_request_type(struct soap *soap, int n)
{	return soap_instantiate_bes__state_change_request_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__state_change_request_type(struct soap *soap, bes__state_change_request_type *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__state_change_request_type * SOAP_FMAC4 soap_instantiate_bes__state_change_request_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__state_change_request_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__state_change_request_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__state_change_request_type;
		if (size)
			*size = sizeof(bes__state_change_request_type);
		((bes__state_change_request_type*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__state_change_request_type[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__state_change_request_type);
		for (int i = 0; i < n; i++)
			((bes__state_change_request_type*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__state_change_request_type*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__state_change_request_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__state_change_request_type %p -> %p\n", q, p));
	*(bes__state_change_request_type*)p = *(bes__state_change_request_type*)q;
}

void bes__requested_state_change_type::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->bes__requested_state_change_type::from = NULL;
	soap_default_bes__overall_state_enumeration(soap, &this->bes__requested_state_change_type::to);
	/* transient soap skipped */
}

void bes__requested_state_change_type::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__requested_state_change_type::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__requested_state_change_type);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__requested_state_change_type::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__requested_state_change_type(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__requested_state_change_type(struct soap *soap, const char *tag, int id, const bes__requested_state_change_type *a, const char *type)
{
	if (((bes__requested_state_change_type*)a)->from)
		soap_set_attr(soap, "from", soap_bes__overall_state_enumeration2s(soap, *((bes__requested_state_change_type*)a)->from));
	soap_set_attr(soap, "to", soap_bes__overall_state_enumeration2s(soap, ((bes__requested_state_change_type*)a)->to));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__requested_state_change_type), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__requested_state_change_type::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__requested_state_change_type(soap, this, tag, type);
}

SOAP_FMAC3 bes__requested_state_change_type * SOAP_FMAC4 soap_get_bes__requested_state_change_type(struct soap *soap, bes__requested_state_change_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__requested_state_change_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__requested_state_change_type::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__requested_state_change_type(soap, tag, this, type);
}

SOAP_FMAC3 bes__requested_state_change_type * SOAP_FMAC4 soap_in_bes__requested_state_change_type(struct soap *soap, const char *tag, bes__requested_state_change_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__requested_state_change_type *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__requested_state_change_type, sizeof(bes__requested_state_change_type), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__requested_state_change_type)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__requested_state_change_type *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "from", 0);
		if (t)
		{
			if (!(((bes__requested_state_change_type*)a)->from = (enum bes__overall_state_enumeration *)soap_malloc(soap, sizeof(enum bes__overall_state_enumeration))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bes__overall_state_enumeration(soap, t, ((bes__requested_state_change_type*)a)->from))
			return NULL;
		}
	}
	if (soap_s2bes__overall_state_enumeration(soap, soap_attr_value(soap, "to", 1), &((bes__requested_state_change_type*)a)->to))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__requested_state_change_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__requested_state_change_type, 0, sizeof(bes__requested_state_change_type), 0, soap_copy_bes__requested_state_change_type);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__requested_state_change_type * SOAP_FMAC6 soap_new_bes__requested_state_change_type(struct soap *soap, int n)
{	return soap_instantiate_bes__requested_state_change_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__requested_state_change_type(struct soap *soap, bes__requested_state_change_type *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__requested_state_change_type * SOAP_FMAC4 soap_instantiate_bes__requested_state_change_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__requested_state_change_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__requested_state_change_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__requested_state_change_type;
		if (size)
			*size = sizeof(bes__requested_state_change_type);
		((bes__requested_state_change_type*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__requested_state_change_type[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__requested_state_change_type);
		for (int i = 0; i < n; i++)
			((bes__requested_state_change_type*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__requested_state_change_type*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__requested_state_change_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__requested_state_change_type %p -> %p\n", q, p));
	*(bes__requested_state_change_type*)p = *(bes__requested_state_change_type*)q;
}

void bes__activity_status_type::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->bes__activity_status_type::activity_identifier = NULL;
	this->bes__activity_status_type::overall_status = NULL;
	soap_default_std__vectorTemplateOfPointerTobes__data_stage_status_type(soap, &this->bes__activity_status_type::data_stage_status);
	/* transient soap skipped */
}

void bes__activity_status_type::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToaddressing__EndpointReferenceType(soap, &this->bes__activity_status_type::activity_identifier);
	soap_serialize_PointerTobes__overall_status_type(soap, &this->bes__activity_status_type::overall_status);
	soap_serialize_std__vectorTemplateOfPointerTobes__data_stage_status_type(soap, &this->bes__activity_status_type::data_stage_status);
	/* transient soap skipped */
}

int bes__activity_status_type::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__activity_status_type);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__activity_status_type::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__activity_status_type(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__activity_status_type(struct soap *soap, const char *tag, int id, const bes__activity_status_type *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__activity_status_type), type))
		return soap->error;
	if (soap_out_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", -1, &(a->bes__activity_status_type::activity_identifier), ""))
		return soap->error;
	if (soap_out_PointerTobes__overall_status_type(soap, "bes:overall-status", -1, &(a->bes__activity_status_type::overall_status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTobes__data_stage_status_type(soap, "bes:data-stage-status", -1, &(a->bes__activity_status_type::data_stage_status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__activity_status_type::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__activity_status_type(soap, this, tag, type);
}

SOAP_FMAC3 bes__activity_status_type * SOAP_FMAC4 soap_get_bes__activity_status_type(struct soap *soap, bes__activity_status_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__activity_status_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__activity_status_type::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__activity_status_type(soap, tag, this, type);
}

SOAP_FMAC3 bes__activity_status_type * SOAP_FMAC4 soap_in_bes__activity_status_type(struct soap *soap, const char *tag, bes__activity_status_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__activity_status_type *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__activity_status_type, sizeof(bes__activity_status_type), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__activity_status_type)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__activity_status_type *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_activity_identifier1 = 1;
	size_t soap_flag_overall_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_activity_identifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToaddressing__EndpointReferenceType(soap, "bes:activity-identifier", &(a->bes__activity_status_type::activity_identifier), "addressing:EndpointReferenceType"))
				{	soap_flag_activity_identifier1--;
					continue;
				}
			if (soap_flag_overall_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__overall_status_type(soap, "bes:overall-status", &(a->bes__activity_status_type::overall_status), "bes:overall-status-type"))
				{	soap_flag_overall_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTobes__data_stage_status_type(soap, "bes:data-stage-status", &(a->bes__activity_status_type::data_stage_status), "bes:data-stage-status-type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__activity_status_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__activity_status_type, 0, sizeof(bes__activity_status_type), 0, soap_copy_bes__activity_status_type);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_activity_identifier1 > 0 || soap_flag_overall_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__activity_status_type * SOAP_FMAC6 soap_new_bes__activity_status_type(struct soap *soap, int n)
{	return soap_instantiate_bes__activity_status_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__activity_status_type(struct soap *soap, bes__activity_status_type *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__activity_status_type * SOAP_FMAC4 soap_instantiate_bes__activity_status_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__activity_status_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__activity_status_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__activity_status_type;
		if (size)
			*size = sizeof(bes__activity_status_type);
		((bes__activity_status_type*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__activity_status_type[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__activity_status_type);
		for (int i = 0; i < n; i++)
			((bes__activity_status_type*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__activity_status_type*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__activity_status_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__activity_status_type %p -> %p\n", q, p));
	*(bes__activity_status_type*)p = *(bes__activity_status_type*)q;
}

void bes__data_stage_status_type::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->bes__data_stage_status_type::id);
	soap_default_bes__data_staging_state_enumeration(soap, &this->bes__data_stage_status_type::state);
	this->bes__data_stage_status_type::last_state = NULL;
	/* transient soap skipped */
}

void bes__data_stage_status_type::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__data_stage_status_type::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__data_stage_status_type);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__data_stage_status_type::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__data_stage_status_type(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__data_stage_status_type(struct soap *soap, const char *tag, int id, const bes__data_stage_status_type *a, const char *type)
{
	if (!((bes__data_stage_status_type*)a)->id.empty())
		soap_set_attr(soap, "id", ((bes__data_stage_status_type*)a)->id.c_str());
	soap_set_attr(soap, "state", soap_bes__data_staging_state_enumeration2s(soap, ((bes__data_stage_status_type*)a)->state));
	if (((bes__data_stage_status_type*)a)->last_state)
		soap_set_attr(soap, "last-state", soap_bes__data_staging_state_enumeration2s(soap, *((bes__data_stage_status_type*)a)->last_state));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__data_stage_status_type), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__data_stage_status_type::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__data_stage_status_type(soap, this, tag, type);
}

SOAP_FMAC3 bes__data_stage_status_type * SOAP_FMAC4 soap_get_bes__data_stage_status_type(struct soap *soap, bes__data_stage_status_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__data_stage_status_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__data_stage_status_type::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__data_stage_status_type(soap, tag, this, type);
}

SOAP_FMAC3 bes__data_stage_status_type * SOAP_FMAC4 soap_in_bes__data_stage_status_type(struct soap *soap, const char *tag, bes__data_stage_status_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__data_stage_status_type *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__data_stage_status_type, sizeof(bes__data_stage_status_type), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__data_stage_status_type)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__data_stage_status_type *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((bes__data_stage_status_type*)a)->id.assign(s);
		}
	}
	if (soap_s2bes__data_staging_state_enumeration(soap, soap_attr_value(soap, "state", 1), &((bes__data_stage_status_type*)a)->state))
		return NULL;
	{	const char *t = soap_attr_value(soap, "last-state", 0);
		if (t)
		{
			if (!(((bes__data_stage_status_type*)a)->last_state = (enum bes__data_staging_state_enumeration *)soap_malloc(soap, sizeof(enum bes__data_staging_state_enumeration))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bes__data_staging_state_enumeration(soap, t, ((bes__data_stage_status_type*)a)->last_state))
			return NULL;
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__data_stage_status_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__data_stage_status_type, 0, sizeof(bes__data_stage_status_type), 0, soap_copy_bes__data_stage_status_type);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__data_stage_status_type * SOAP_FMAC6 soap_new_bes__data_stage_status_type(struct soap *soap, int n)
{	return soap_instantiate_bes__data_stage_status_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__data_stage_status_type(struct soap *soap, bes__data_stage_status_type *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__data_stage_status_type * SOAP_FMAC4 soap_instantiate_bes__data_stage_status_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__data_stage_status_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__data_stage_status_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__data_stage_status_type;
		if (size)
			*size = sizeof(bes__data_stage_status_type);
		((bes__data_stage_status_type*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__data_stage_status_type[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__data_stage_status_type);
		for (int i = 0; i < n; i++)
			((bes__data_stage_status_type*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__data_stage_status_type*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__data_stage_status_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__data_stage_status_type %p -> %p\n", q, p));
	*(bes__data_stage_status_type*)p = *(bes__data_stage_status_type*)q;
}

void bes__overall_status_type::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bes__overall_state_enumeration(soap, &this->bes__overall_status_type::state);
	this->bes__overall_status_type::last_state = NULL;
	this->bes__overall_status_type::other = NULL;
	/* transient soap skipped */
}

void bes__overall_status_type::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int bes__overall_status_type::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_bes_bes__overall_status_type);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int bes__overall_status_type::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_bes__overall_status_type(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bes__overall_status_type(struct soap *soap, const char *tag, int id, const bes__overall_status_type *a, const char *type)
{
	soap_set_attr(soap, "state", soap_bes__overall_state_enumeration2s(soap, ((bes__overall_status_type*)a)->state));
	if (((bes__overall_status_type*)a)->last_state)
		soap_set_attr(soap, "last-state", soap_bes__overall_state_enumeration2s(soap, *((bes__overall_status_type*)a)->last_state));
	if (((bes__overall_status_type*)a)->other)
		soap_set_attr(soap, "other", ((bes__overall_status_type*)a)->other->c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_bes__overall_status_type), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *bes__overall_status_type::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_bes__overall_status_type(soap, this, tag, type);
}

SOAP_FMAC3 bes__overall_status_type * SOAP_FMAC4 soap_get_bes__overall_status_type(struct soap *soap, bes__overall_status_type *p, const char *tag, const char *type)
{
	if ((p = soap_in_bes__overall_status_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *bes__overall_status_type::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_bes__overall_status_type(soap, tag, this, type);
}

SOAP_FMAC3 bes__overall_status_type * SOAP_FMAC4 soap_in_bes__overall_status_type(struct soap *soap, const char *tag, bes__overall_status_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (bes__overall_status_type *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_bes_bes__overall_status_type, sizeof(bes__overall_status_type), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_bes_bes__overall_status_type)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (bes__overall_status_type *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bes__overall_state_enumeration(soap, soap_attr_value(soap, "state", 1), &((bes__overall_status_type*)a)->state))
		return NULL;
	{	const char *t = soap_attr_value(soap, "last-state", 0);
		if (t)
		{
			if (!(((bes__overall_status_type*)a)->last_state = (enum bes__overall_state_enumeration *)soap_malloc(soap, sizeof(enum bes__overall_state_enumeration))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bes__overall_state_enumeration(soap, t, ((bes__overall_status_type*)a)->last_state))
			return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "other", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((bes__overall_status_type*)a)->other = soap_new_std__string(soap, -1);
				((bes__overall_status_type*)a)->other->assign(s);
			}
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bes__overall_status_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_bes__overall_status_type, 0, sizeof(bes__overall_status_type), 0, soap_copy_bes__overall_status_type);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 bes__overall_status_type * SOAP_FMAC6 soap_new_bes__overall_status_type(struct soap *soap, int n)
{	return soap_instantiate_bes__overall_status_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_bes__overall_status_type(struct soap *soap, bes__overall_status_type *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 bes__overall_status_type * SOAP_FMAC4 soap_instantiate_bes__overall_status_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_bes__overall_status_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_bes__overall_status_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new bes__overall_status_type;
		if (size)
			*size = sizeof(bes__overall_status_type);
		((bes__overall_status_type*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new bes__overall_status_type[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(bes__overall_status_type);
		for (int i = 0; i < n; i++)
			((bes__overall_status_type*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (bes__overall_status_type*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_bes__overall_status_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying bes__overall_status_type %p -> %p\n", q, p));
	*(bes__overall_status_type*)p = *(bes__overall_status_type*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__nonNegativeInteger(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__nonNegativeInteger(struct soap *soap, int n)
{	return soap_instantiate_xsd__nonNegativeInteger(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__nonNegativeInteger(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__nonNegativeInteger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonNegativeInteger(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_xsd__nonNegativeInteger, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__nonNegativeInteger(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__anyURI(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyURI(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_xsd__anyURI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_xsd__QName);
	if (soap_out_xsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__QName(struct soap *soap, int n)
{	return soap_instantiate_xsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NCName(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_xsd__NCName, 0, sizeof(std::string), 0, soap_copy_xsd__NCName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__NCName(struct soap *soap, int n)
{	return soap_instantiate_xsd__NCName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__NCName(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__NCName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NCName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_xsd__NCName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__NCName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__ID(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_xsd__ID);
	if (soap_out_xsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__ID(struct soap *soap, int n)
{	return soap_instantiate_xsd__ID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__ID(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_xsd__ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_bes_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_bes_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_bes_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__GetActivityJSDLDocuments(struct soap *soap, struct __bes__GetActivityJSDLDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__GetActivityJSDLDocuments = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__GetActivityJSDLDocuments(struct soap *soap, const struct __bes__GetActivityJSDLDocuments *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_bes__GetActivityJSDLDocuments(soap, &a->bes__GetActivityJSDLDocuments);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__GetActivityJSDLDocuments(struct soap *soap, const struct __bes__GetActivityJSDLDocuments *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetActivityJSDLDocuments(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__GetActivityJSDLDocuments(struct soap *soap, const char *tag, int id, const struct __bes__GetActivityJSDLDocuments *a, const char *type)
{
	if (soap_out_PointerTo_bes__GetActivityJSDLDocuments(soap, "bes:GetActivityJSDLDocuments", -1, &a->bes__GetActivityJSDLDocuments, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetActivityJSDLDocuments * SOAP_FMAC4 soap_get___bes__GetActivityJSDLDocuments(struct soap *soap, struct __bes__GetActivityJSDLDocuments *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetActivityJSDLDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetActivityJSDLDocuments * SOAP_FMAC4 soap_in___bes__GetActivityJSDLDocuments(struct soap *soap, const char *tag, struct __bes__GetActivityJSDLDocuments *a, const char *type)
{
	size_t soap_flag_bes__GetActivityJSDLDocuments = 1;
	short soap_flag;
	a = (struct __bes__GetActivityJSDLDocuments *)soap_id_enter(soap, "", a, SOAP_TYPE_bes___bes__GetActivityJSDLDocuments, sizeof(struct __bes__GetActivityJSDLDocuments), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetActivityJSDLDocuments(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__GetActivityJSDLDocuments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_bes__GetActivityJSDLDocuments(soap, "bes:GetActivityJSDLDocuments", &a->bes__GetActivityJSDLDocuments, ""))
				{	soap_flag_bes__GetActivityJSDLDocuments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __bes__GetActivityJSDLDocuments * SOAP_FMAC6 soap_new___bes__GetActivityJSDLDocuments(struct soap *soap, int n)
{	return soap_instantiate___bes__GetActivityJSDLDocuments(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___bes__GetActivityJSDLDocuments(struct soap *soap, struct __bes__GetActivityJSDLDocuments *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __bes__GetActivityJSDLDocuments * SOAP_FMAC4 soap_instantiate___bes__GetActivityJSDLDocuments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___bes__GetActivityJSDLDocuments(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes___bes__GetActivityJSDLDocuments, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __bes__GetActivityJSDLDocuments;
		if (size)
			*size = sizeof(struct __bes__GetActivityJSDLDocuments);
	}
	else
	{	cp->ptr = (void*)new struct __bes__GetActivityJSDLDocuments[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __bes__GetActivityJSDLDocuments);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __bes__GetActivityJSDLDocuments*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___bes__GetActivityJSDLDocuments(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __bes__GetActivityJSDLDocuments %p -> %p\n", q, p));
	*(struct __bes__GetActivityJSDLDocuments*)p = *(struct __bes__GetActivityJSDLDocuments*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__IsAcceptingNewActivities(struct soap *soap, struct __bes__IsAcceptingNewActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__IsAcceptingNewActivities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__IsAcceptingNewActivities(struct soap *soap, const struct __bes__IsAcceptingNewActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__IsAcceptingNewActivities(struct soap *soap, const struct __bes__IsAcceptingNewActivities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__IsAcceptingNewActivities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__IsAcceptingNewActivities(struct soap *soap, const char *tag, int id, const struct __bes__IsAcceptingNewActivities *a, const char *type)
{
	soap_outliteral(soap, "bes:IsAcceptingNewActivities", &a->bes__IsAcceptingNewActivities, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__IsAcceptingNewActivities * SOAP_FMAC4 soap_get___bes__IsAcceptingNewActivities(struct soap *soap, struct __bes__IsAcceptingNewActivities *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__IsAcceptingNewActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__IsAcceptingNewActivities * SOAP_FMAC4 soap_in___bes__IsAcceptingNewActivities(struct soap *soap, const char *tag, struct __bes__IsAcceptingNewActivities *a, const char *type)
{
	size_t soap_flag_bes__IsAcceptingNewActivities = 1;
	short soap_flag;
	a = (struct __bes__IsAcceptingNewActivities *)soap_id_enter(soap, "", a, SOAP_TYPE_bes___bes__IsAcceptingNewActivities, sizeof(struct __bes__IsAcceptingNewActivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__IsAcceptingNewActivities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__IsAcceptingNewActivities && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "bes:IsAcceptingNewActivities", &a->bes__IsAcceptingNewActivities))
				{	soap_flag_bes__IsAcceptingNewActivities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __bes__IsAcceptingNewActivities * SOAP_FMAC6 soap_new___bes__IsAcceptingNewActivities(struct soap *soap, int n)
{	return soap_instantiate___bes__IsAcceptingNewActivities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___bes__IsAcceptingNewActivities(struct soap *soap, struct __bes__IsAcceptingNewActivities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __bes__IsAcceptingNewActivities * SOAP_FMAC4 soap_instantiate___bes__IsAcceptingNewActivities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___bes__IsAcceptingNewActivities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes___bes__IsAcceptingNewActivities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __bes__IsAcceptingNewActivities;
		if (size)
			*size = sizeof(struct __bes__IsAcceptingNewActivities);
	}
	else
	{	cp->ptr = (void*)new struct __bes__IsAcceptingNewActivities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __bes__IsAcceptingNewActivities);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __bes__IsAcceptingNewActivities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___bes__IsAcceptingNewActivities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __bes__IsAcceptingNewActivities %p -> %p\n", q, p));
	*(struct __bes__IsAcceptingNewActivities*)p = *(struct __bes__IsAcceptingNewActivities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__StartAcceptingNewActivities(struct soap *soap, struct __bes__StartAcceptingNewActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__StartAcceptingNewActivities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__StartAcceptingNewActivities(struct soap *soap, const struct __bes__StartAcceptingNewActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__StartAcceptingNewActivities(struct soap *soap, const struct __bes__StartAcceptingNewActivities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__StartAcceptingNewActivities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__StartAcceptingNewActivities(struct soap *soap, const char *tag, int id, const struct __bes__StartAcceptingNewActivities *a, const char *type)
{
	soap_outliteral(soap, "bes:StartAcceptingNewActivities", &a->bes__StartAcceptingNewActivities, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__StartAcceptingNewActivities * SOAP_FMAC4 soap_get___bes__StartAcceptingNewActivities(struct soap *soap, struct __bes__StartAcceptingNewActivities *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__StartAcceptingNewActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__StartAcceptingNewActivities * SOAP_FMAC4 soap_in___bes__StartAcceptingNewActivities(struct soap *soap, const char *tag, struct __bes__StartAcceptingNewActivities *a, const char *type)
{
	size_t soap_flag_bes__StartAcceptingNewActivities = 1;
	short soap_flag;
	a = (struct __bes__StartAcceptingNewActivities *)soap_id_enter(soap, "", a, SOAP_TYPE_bes___bes__StartAcceptingNewActivities, sizeof(struct __bes__StartAcceptingNewActivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__StartAcceptingNewActivities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__StartAcceptingNewActivities && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "bes:StartAcceptingNewActivities", &a->bes__StartAcceptingNewActivities))
				{	soap_flag_bes__StartAcceptingNewActivities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __bes__StartAcceptingNewActivities * SOAP_FMAC6 soap_new___bes__StartAcceptingNewActivities(struct soap *soap, int n)
{	return soap_instantiate___bes__StartAcceptingNewActivities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___bes__StartAcceptingNewActivities(struct soap *soap, struct __bes__StartAcceptingNewActivities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __bes__StartAcceptingNewActivities * SOAP_FMAC4 soap_instantiate___bes__StartAcceptingNewActivities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___bes__StartAcceptingNewActivities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes___bes__StartAcceptingNewActivities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __bes__StartAcceptingNewActivities;
		if (size)
			*size = sizeof(struct __bes__StartAcceptingNewActivities);
	}
	else
	{	cp->ptr = (void*)new struct __bes__StartAcceptingNewActivities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __bes__StartAcceptingNewActivities);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __bes__StartAcceptingNewActivities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___bes__StartAcceptingNewActivities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __bes__StartAcceptingNewActivities %p -> %p\n", q, p));
	*(struct __bes__StartAcceptingNewActivities*)p = *(struct __bes__StartAcceptingNewActivities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__StopAcceptingNewActivities(struct soap *soap, struct __bes__StopAcceptingNewActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__StopAcceptingNewActivities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__StopAcceptingNewActivities(struct soap *soap, const struct __bes__StopAcceptingNewActivities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__StopAcceptingNewActivities(struct soap *soap, const struct __bes__StopAcceptingNewActivities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__StopAcceptingNewActivities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__StopAcceptingNewActivities(struct soap *soap, const char *tag, int id, const struct __bes__StopAcceptingNewActivities *a, const char *type)
{
	soap_outliteral(soap, "bes:StopAcceptingNewActivities", &a->bes__StopAcceptingNewActivities, NULL);
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__StopAcceptingNewActivities * SOAP_FMAC4 soap_get___bes__StopAcceptingNewActivities(struct soap *soap, struct __bes__StopAcceptingNewActivities *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__StopAcceptingNewActivities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__StopAcceptingNewActivities * SOAP_FMAC4 soap_in___bes__StopAcceptingNewActivities(struct soap *soap, const char *tag, struct __bes__StopAcceptingNewActivities *a, const char *type)
{
	size_t soap_flag_bes__StopAcceptingNewActivities = 1;
	short soap_flag;
	a = (struct __bes__StopAcceptingNewActivities *)soap_id_enter(soap, "", a, SOAP_TYPE_bes___bes__StopAcceptingNewActivities, sizeof(struct __bes__StopAcceptingNewActivities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__StopAcceptingNewActivities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__StopAcceptingNewActivities && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "bes:StopAcceptingNewActivities", &a->bes__StopAcceptingNewActivities))
				{	soap_flag_bes__StopAcceptingNewActivities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __bes__StopAcceptingNewActivities * SOAP_FMAC6 soap_new___bes__StopAcceptingNewActivities(struct soap *soap, int n)
{	return soap_instantiate___bes__StopAcceptingNewActivities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___bes__StopAcceptingNewActivities(struct soap *soap, struct __bes__StopAcceptingNewActivities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __bes__StopAcceptingNewActivities * SOAP_FMAC4 soap_instantiate___bes__StopAcceptingNewActivities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___bes__StopAcceptingNewActivities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes___bes__StopAcceptingNewActivities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __bes__StopAcceptingNewActivities;
		if (size)
			*size = sizeof(struct __bes__StopAcceptingNewActivities);
	}
	else
	{	cp->ptr = (void*)new struct __bes__StopAcceptingNewActivities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __bes__StopAcceptingNewActivities);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __bes__StopAcceptingNewActivities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___bes__StopAcceptingNewActivities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __bes__StopAcceptingNewActivities %p -> %p\n", q, p));
	*(struct __bes__StopAcceptingNewActivities*)p = *(struct __bes__StopAcceptingNewActivities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__RequestActivityStateChanges(struct soap *soap, struct __bes__RequestActivityStateChanges *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__RequestActivityStateChanges = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__RequestActivityStateChanges(struct soap *soap, const struct __bes__RequestActivityStateChanges *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_bes__RequestActivityStateChanges(soap, &a->bes__RequestActivityStateChanges);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__RequestActivityStateChanges(struct soap *soap, const struct __bes__RequestActivityStateChanges *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__RequestActivityStateChanges(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__RequestActivityStateChanges(struct soap *soap, const char *tag, int id, const struct __bes__RequestActivityStateChanges *a, const char *type)
{
	if (soap_out_PointerTo_bes__RequestActivityStateChanges(soap, "bes:RequestActivityStateChanges", -1, &a->bes__RequestActivityStateChanges, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__RequestActivityStateChanges * SOAP_FMAC4 soap_get___bes__RequestActivityStateChanges(struct soap *soap, struct __bes__RequestActivityStateChanges *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__RequestActivityStateChanges(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__RequestActivityStateChanges * SOAP_FMAC4 soap_in___bes__RequestActivityStateChanges(struct soap *soap, const char *tag, struct __bes__RequestActivityStateChanges *a, const char *type)
{
	size_t soap_flag_bes__RequestActivityStateChanges = 1;
	short soap_flag;
	a = (struct __bes__RequestActivityStateChanges *)soap_id_enter(soap, "", a, SOAP_TYPE_bes___bes__RequestActivityStateChanges, sizeof(struct __bes__RequestActivityStateChanges), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__RequestActivityStateChanges(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__RequestActivityStateChanges && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_bes__RequestActivityStateChanges(soap, "bes:RequestActivityStateChanges", &a->bes__RequestActivityStateChanges, ""))
				{	soap_flag_bes__RequestActivityStateChanges--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __bes__RequestActivityStateChanges * SOAP_FMAC6 soap_new___bes__RequestActivityStateChanges(struct soap *soap, int n)
{	return soap_instantiate___bes__RequestActivityStateChanges(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___bes__RequestActivityStateChanges(struct soap *soap, struct __bes__RequestActivityStateChanges *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __bes__RequestActivityStateChanges * SOAP_FMAC4 soap_instantiate___bes__RequestActivityStateChanges(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___bes__RequestActivityStateChanges(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes___bes__RequestActivityStateChanges, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __bes__RequestActivityStateChanges;
		if (size)
			*size = sizeof(struct __bes__RequestActivityStateChanges);
	}
	else
	{	cp->ptr = (void*)new struct __bes__RequestActivityStateChanges[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __bes__RequestActivityStateChanges);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __bes__RequestActivityStateChanges*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___bes__RequestActivityStateChanges(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __bes__RequestActivityStateChanges %p -> %p\n", q, p));
	*(struct __bes__RequestActivityStateChanges*)p = *(struct __bes__RequestActivityStateChanges*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__GetActivityStatus(struct soap *soap, struct __bes__GetActivityStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__GetActivityStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__GetActivityStatus(struct soap *soap, const struct __bes__GetActivityStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_bes__GetActivityStatus(soap, &a->bes__GetActivityStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__GetActivityStatus(struct soap *soap, const struct __bes__GetActivityStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__GetActivityStatus(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__GetActivityStatus(struct soap *soap, const char *tag, int id, const struct __bes__GetActivityStatus *a, const char *type)
{
	if (soap_out_PointerTo_bes__GetActivityStatus(soap, "bes:GetActivityStatus", -1, &a->bes__GetActivityStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__GetActivityStatus * SOAP_FMAC4 soap_get___bes__GetActivityStatus(struct soap *soap, struct __bes__GetActivityStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__GetActivityStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__GetActivityStatus * SOAP_FMAC4 soap_in___bes__GetActivityStatus(struct soap *soap, const char *tag, struct __bes__GetActivityStatus *a, const char *type)
{
	size_t soap_flag_bes__GetActivityStatus = 1;
	short soap_flag;
	a = (struct __bes__GetActivityStatus *)soap_id_enter(soap, "", a, SOAP_TYPE_bes___bes__GetActivityStatus, sizeof(struct __bes__GetActivityStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__GetActivityStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__GetActivityStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_bes__GetActivityStatus(soap, "bes:GetActivityStatus", &a->bes__GetActivityStatus, ""))
				{	soap_flag_bes__GetActivityStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __bes__GetActivityStatus * SOAP_FMAC6 soap_new___bes__GetActivityStatus(struct soap *soap, int n)
{	return soap_instantiate___bes__GetActivityStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___bes__GetActivityStatus(struct soap *soap, struct __bes__GetActivityStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __bes__GetActivityStatus * SOAP_FMAC4 soap_instantiate___bes__GetActivityStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___bes__GetActivityStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes___bes__GetActivityStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __bes__GetActivityStatus;
		if (size)
			*size = sizeof(struct __bes__GetActivityStatus);
	}
	else
	{	cp->ptr = (void*)new struct __bes__GetActivityStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __bes__GetActivityStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __bes__GetActivityStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___bes__GetActivityStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __bes__GetActivityStatus %p -> %p\n", q, p));
	*(struct __bes__GetActivityStatus*)p = *(struct __bes__GetActivityStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___bes__CreateActivityFromJSDL(struct soap *soap, struct __bes__CreateActivityFromJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__CreateActivityFromJSDL = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___bes__CreateActivityFromJSDL(struct soap *soap, const struct __bes__CreateActivityFromJSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_bes__CreateActivityFromJSDL(soap, &a->bes__CreateActivityFromJSDL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___bes__CreateActivityFromJSDL(struct soap *soap, const struct __bes__CreateActivityFromJSDL *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___bes__CreateActivityFromJSDL(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___bes__CreateActivityFromJSDL(struct soap *soap, const char *tag, int id, const struct __bes__CreateActivityFromJSDL *a, const char *type)
{
	if (soap_out_PointerTo_bes__CreateActivityFromJSDL(soap, "bes:CreateActivityFromJSDL", -1, &a->bes__CreateActivityFromJSDL, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __bes__CreateActivityFromJSDL * SOAP_FMAC4 soap_get___bes__CreateActivityFromJSDL(struct soap *soap, struct __bes__CreateActivityFromJSDL *p, const char *tag, const char *type)
{
	if ((p = soap_in___bes__CreateActivityFromJSDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __bes__CreateActivityFromJSDL * SOAP_FMAC4 soap_in___bes__CreateActivityFromJSDL(struct soap *soap, const char *tag, struct __bes__CreateActivityFromJSDL *a, const char *type)
{
	size_t soap_flag_bes__CreateActivityFromJSDL = 1;
	short soap_flag;
	a = (struct __bes__CreateActivityFromJSDL *)soap_id_enter(soap, "", a, SOAP_TYPE_bes___bes__CreateActivityFromJSDL, sizeof(struct __bes__CreateActivityFromJSDL), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___bes__CreateActivityFromJSDL(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__CreateActivityFromJSDL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_bes__CreateActivityFromJSDL(soap, "bes:CreateActivityFromJSDL", &a->bes__CreateActivityFromJSDL, ""))
				{	soap_flag_bes__CreateActivityFromJSDL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __bes__CreateActivityFromJSDL * SOAP_FMAC6 soap_new___bes__CreateActivityFromJSDL(struct soap *soap, int n)
{	return soap_instantiate___bes__CreateActivityFromJSDL(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___bes__CreateActivityFromJSDL(struct soap *soap, struct __bes__CreateActivityFromJSDL *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __bes__CreateActivityFromJSDL * SOAP_FMAC4 soap_instantiate___bes__CreateActivityFromJSDL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___bes__CreateActivityFromJSDL(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes___bes__CreateActivityFromJSDL, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __bes__CreateActivityFromJSDL;
		if (size)
			*size = sizeof(struct __bes__CreateActivityFromJSDL);
	}
	else
	{	cp->ptr = (void*)new struct __bes__CreateActivityFromJSDL[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __bes__CreateActivityFromJSDL);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __bes__CreateActivityFromJSDL*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___bes__CreateActivityFromJSDL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __bes__CreateActivityFromJSDL %p -> %p\n", q, p));
	*(struct __bes__CreateActivityFromJSDL*)p = *(struct __bes__CreateActivityFromJSDL*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->bes__BackendFault = NULL;
	a->bes__BadlyFormedJSDLDocumentFault = NULL;
	a->bes__JobSpecificationFault = NULL;
	a->bes__NotAcceptingNewActivitiesFault = NULL;
	a->bes__UnsupportedFeatureFault = NULL;
	a->bes__UnsupportedJSDLFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobes__BackendFaultType(soap, &a->bes__BackendFault);
	soap_serialize_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, &a->bes__BadlyFormedJSDLDocumentFault);
	soap_serialize_PointerTobes__JobSpecificationFaultType(soap, &a->bes__JobSpecificationFault);
	soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, &a->bes__NotAcceptingNewActivitiesFault);
	soap_serialize_PointerTobes__UnsupportedFeatureFaultType(soap, &a->bes__UnsupportedFeatureFault);
	soap_serialize_PointerTobes__UnsupportedJSDLFaultType(soap, &a->bes__UnsupportedJSDLFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bes_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTobes__BackendFaultType(soap, "bes:BackendFault", -1, &a->bes__BackendFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, "bes:BadlyFormedJSDLDocumentFault", -1, &a->bes__BadlyFormedJSDLDocumentFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__JobSpecificationFaultType(soap, "bes:JobSpecificationFault", -1, &a->bes__JobSpecificationFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, "bes:NotAcceptingNewActivitiesFault", -1, &a->bes__NotAcceptingNewActivitiesFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, "bes:UnsupportedFeatureFault", -1, &a->bes__UnsupportedFeatureFault, ""))
		return soap->error;
	if (soap_out_PointerTobes__UnsupportedJSDLFaultType(soap, "bes:UnsupportedJSDLFault", -1, &a->bes__UnsupportedJSDLFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_bes__BackendFault = 1;
	size_t soap_flag_bes__BadlyFormedJSDLDocumentFault = 1;
	size_t soap_flag_bes__JobSpecificationFault = 1;
	size_t soap_flag_bes__NotAcceptingNewActivitiesFault = 1;
	size_t soap_flag_bes__UnsupportedFeatureFault = 1;
	size_t soap_flag_bes__UnsupportedJSDLFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bes_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bes__BackendFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__BackendFaultType(soap, "bes:BackendFault", &a->bes__BackendFault, "bes:BackendFaultType"))
				{	soap_flag_bes__BackendFault--;
					continue;
				}
			if (soap_flag_bes__BadlyFormedJSDLDocumentFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, "bes:BadlyFormedJSDLDocumentFault", &a->bes__BadlyFormedJSDLDocumentFault, "bes:BadlyFormedJSDLDocumentFaultType"))
				{	soap_flag_bes__BadlyFormedJSDLDocumentFault--;
					continue;
				}
			if (soap_flag_bes__JobSpecificationFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__JobSpecificationFaultType(soap, "bes:JobSpecificationFault", &a->bes__JobSpecificationFault, "bes:JobSpecificationFaultType"))
				{	soap_flag_bes__JobSpecificationFault--;
					continue;
				}
			if (soap_flag_bes__NotAcceptingNewActivitiesFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, "bes:NotAcceptingNewActivitiesFault", &a->bes__NotAcceptingNewActivitiesFault, "bes:NotAcceptingNewActivitiesFaultType"))
				{	soap_flag_bes__NotAcceptingNewActivitiesFault--;
					continue;
				}
			if (soap_flag_bes__UnsupportedFeatureFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, "bes:UnsupportedFeatureFault", &a->bes__UnsupportedFeatureFault, "bes:UnsupportedFeatureFaultType"))
				{	soap_flag_bes__UnsupportedFeatureFault--;
					continue;
				}
			if (soap_flag_bes__UnsupportedJSDLFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobes__UnsupportedJSDLFaultType(soap, "bes:UnsupportedJSDLFault", &a->bes__UnsupportedJSDLFault, "bes:UnsupportedJSDLFaultType"))
				{	soap_flag_bes__UnsupportedJSDLFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bes_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__GetActivityJSDLDocumentsResponse(struct soap *soap, _bes__GetActivityJSDLDocumentsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__GetActivityJSDLDocumentsResponse(struct soap *soap, _bes__GetActivityJSDLDocumentsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocumentsResponse);
	if (soap_out_PointerTo_bes__GetActivityJSDLDocumentsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__GetActivityJSDLDocumentsResponse(struct soap *soap, const char *tag, int id, _bes__GetActivityJSDLDocumentsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocumentsResponse ** SOAP_FMAC4 soap_get_PointerTo_bes__GetActivityJSDLDocumentsResponse(struct soap *soap, _bes__GetActivityJSDLDocumentsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__GetActivityJSDLDocumentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__GetActivityJSDLDocumentsResponse ** SOAP_FMAC4 soap_in_PointerTo_bes__GetActivityJSDLDocumentsResponse(struct soap *soap, const char *tag, _bes__GetActivityJSDLDocumentsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__GetActivityJSDLDocumentsResponse **)soap_malloc(soap, sizeof(_bes__GetActivityJSDLDocumentsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__GetActivityJSDLDocumentsResponse *)soap_instantiate__bes__GetActivityJSDLDocumentsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__GetActivityJSDLDocumentsResponse ** p = (_bes__GetActivityJSDLDocumentsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse, sizeof(_bes__GetActivityJSDLDocumentsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__GetActivityJSDLDocuments(struct soap *soap, _bes__GetActivityJSDLDocuments *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__GetActivityJSDLDocuments(struct soap *soap, _bes__GetActivityJSDLDocuments *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__GetActivityJSDLDocuments);
	if (soap_out_PointerTo_bes__GetActivityJSDLDocuments(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__GetActivityJSDLDocuments(struct soap *soap, const char *tag, int id, _bes__GetActivityJSDLDocuments *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__GetActivityJSDLDocuments ** SOAP_FMAC4 soap_get_PointerTo_bes__GetActivityJSDLDocuments(struct soap *soap, _bes__GetActivityJSDLDocuments **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__GetActivityJSDLDocuments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__GetActivityJSDLDocuments ** SOAP_FMAC4 soap_in_PointerTo_bes__GetActivityJSDLDocuments(struct soap *soap, const char *tag, _bes__GetActivityJSDLDocuments **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__GetActivityJSDLDocuments **)soap_malloc(soap, sizeof(_bes__GetActivityJSDLDocuments *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__GetActivityJSDLDocuments *)soap_instantiate__bes__GetActivityJSDLDocuments(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__GetActivityJSDLDocuments ** p = (_bes__GetActivityJSDLDocuments **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__GetActivityJSDLDocuments, sizeof(_bes__GetActivityJSDLDocuments), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__IsAcceptingNewActivitiesResponse(struct soap *soap, _bes__IsAcceptingNewActivitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__IsAcceptingNewActivitiesResponse(struct soap *soap, _bes__IsAcceptingNewActivitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__IsAcceptingNewActivitiesResponse);
	if (soap_out_PointerTo_bes__IsAcceptingNewActivitiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__IsAcceptingNewActivitiesResponse(struct soap *soap, const char *tag, int id, _bes__IsAcceptingNewActivitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__IsAcceptingNewActivitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_bes__IsAcceptingNewActivitiesResponse(struct soap *soap, _bes__IsAcceptingNewActivitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__IsAcceptingNewActivitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__IsAcceptingNewActivitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_bes__IsAcceptingNewActivitiesResponse(struct soap *soap, const char *tag, _bes__IsAcceptingNewActivitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__IsAcceptingNewActivitiesResponse **)soap_malloc(soap, sizeof(_bes__IsAcceptingNewActivitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__IsAcceptingNewActivitiesResponse *)soap_instantiate__bes__IsAcceptingNewActivitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__IsAcceptingNewActivitiesResponse ** p = (_bes__IsAcceptingNewActivitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse, sizeof(_bes__IsAcceptingNewActivitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__RequestActivityStateChangesResponse(struct soap *soap, _bes__RequestActivityStateChangesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__RequestActivityStateChangesResponse(struct soap *soap, _bes__RequestActivityStateChangesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChangesResponse);
	if (soap_out_PointerTo_bes__RequestActivityStateChangesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__RequestActivityStateChangesResponse(struct soap *soap, const char *tag, int id, _bes__RequestActivityStateChangesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__RequestActivityStateChangesResponse ** SOAP_FMAC4 soap_get_PointerTo_bes__RequestActivityStateChangesResponse(struct soap *soap, _bes__RequestActivityStateChangesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__RequestActivityStateChangesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__RequestActivityStateChangesResponse ** SOAP_FMAC4 soap_in_PointerTo_bes__RequestActivityStateChangesResponse(struct soap *soap, const char *tag, _bes__RequestActivityStateChangesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__RequestActivityStateChangesResponse **)soap_malloc(soap, sizeof(_bes__RequestActivityStateChangesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__RequestActivityStateChangesResponse *)soap_instantiate__bes__RequestActivityStateChangesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__RequestActivityStateChangesResponse ** p = (_bes__RequestActivityStateChangesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse, sizeof(_bes__RequestActivityStateChangesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__RequestActivityStateChanges(struct soap *soap, _bes__RequestActivityStateChanges *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__RequestActivityStateChanges))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__RequestActivityStateChanges(struct soap *soap, _bes__RequestActivityStateChanges *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__RequestActivityStateChanges);
	if (soap_out_PointerTo_bes__RequestActivityStateChanges(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__RequestActivityStateChanges(struct soap *soap, const char *tag, int id, _bes__RequestActivityStateChanges *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__RequestActivityStateChanges);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__RequestActivityStateChanges ** SOAP_FMAC4 soap_get_PointerTo_bes__RequestActivityStateChanges(struct soap *soap, _bes__RequestActivityStateChanges **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__RequestActivityStateChanges(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__RequestActivityStateChanges ** SOAP_FMAC4 soap_in_PointerTo_bes__RequestActivityStateChanges(struct soap *soap, const char *tag, _bes__RequestActivityStateChanges **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__RequestActivityStateChanges **)soap_malloc(soap, sizeof(_bes__RequestActivityStateChanges *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__RequestActivityStateChanges *)soap_instantiate__bes__RequestActivityStateChanges(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__RequestActivityStateChanges ** p = (_bes__RequestActivityStateChanges **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__RequestActivityStateChanges, sizeof(_bes__RequestActivityStateChanges), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__GetActivityStatusResponse(struct soap *soap, _bes__GetActivityStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__GetActivityStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__GetActivityStatusResponse(struct soap *soap, _bes__GetActivityStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__GetActivityStatusResponse);
	if (soap_out_PointerTo_bes__GetActivityStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__GetActivityStatusResponse(struct soap *soap, const char *tag, int id, _bes__GetActivityStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__GetActivityStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__GetActivityStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_bes__GetActivityStatusResponse(struct soap *soap, _bes__GetActivityStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__GetActivityStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__GetActivityStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_bes__GetActivityStatusResponse(struct soap *soap, const char *tag, _bes__GetActivityStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__GetActivityStatusResponse **)soap_malloc(soap, sizeof(_bes__GetActivityStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__GetActivityStatusResponse *)soap_instantiate__bes__GetActivityStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__GetActivityStatusResponse ** p = (_bes__GetActivityStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__GetActivityStatusResponse, sizeof(_bes__GetActivityStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__GetActivityStatus(struct soap *soap, _bes__GetActivityStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__GetActivityStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__GetActivityStatus(struct soap *soap, _bes__GetActivityStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__GetActivityStatus);
	if (soap_out_PointerTo_bes__GetActivityStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__GetActivityStatus(struct soap *soap, const char *tag, int id, _bes__GetActivityStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__GetActivityStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__GetActivityStatus ** SOAP_FMAC4 soap_get_PointerTo_bes__GetActivityStatus(struct soap *soap, _bes__GetActivityStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__GetActivityStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__GetActivityStatus ** SOAP_FMAC4 soap_in_PointerTo_bes__GetActivityStatus(struct soap *soap, const char *tag, _bes__GetActivityStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__GetActivityStatus **)soap_malloc(soap, sizeof(_bes__GetActivityStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__GetActivityStatus *)soap_instantiate__bes__GetActivityStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__GetActivityStatus ** p = (_bes__GetActivityStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__GetActivityStatus, sizeof(_bes__GetActivityStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__CreateActivityFromJSDLResponse(struct soap *soap, _bes__CreateActivityFromJSDLResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__CreateActivityFromJSDLResponse(struct soap *soap, _bes__CreateActivityFromJSDLResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDLResponse);
	if (soap_out_PointerTo_bes__CreateActivityFromJSDLResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__CreateActivityFromJSDLResponse(struct soap *soap, const char *tag, int id, _bes__CreateActivityFromJSDLResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDLResponse ** SOAP_FMAC4 soap_get_PointerTo_bes__CreateActivityFromJSDLResponse(struct soap *soap, _bes__CreateActivityFromJSDLResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__CreateActivityFromJSDLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__CreateActivityFromJSDLResponse ** SOAP_FMAC4 soap_in_PointerTo_bes__CreateActivityFromJSDLResponse(struct soap *soap, const char *tag, _bes__CreateActivityFromJSDLResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__CreateActivityFromJSDLResponse **)soap_malloc(soap, sizeof(_bes__CreateActivityFromJSDLResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__CreateActivityFromJSDLResponse *)soap_instantiate__bes__CreateActivityFromJSDLResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__CreateActivityFromJSDLResponse ** p = (_bes__CreateActivityFromJSDLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse, sizeof(_bes__CreateActivityFromJSDLResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_bes__CreateActivityFromJSDL(struct soap *soap, _bes__CreateActivityFromJSDL *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes__bes__CreateActivityFromJSDL))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_bes__CreateActivityFromJSDL(struct soap *soap, _bes__CreateActivityFromJSDL *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTo_bes__CreateActivityFromJSDL);
	if (soap_out_PointerTo_bes__CreateActivityFromJSDL(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_bes__CreateActivityFromJSDL(struct soap *soap, const char *tag, int id, _bes__CreateActivityFromJSDL *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes__bes__CreateActivityFromJSDL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _bes__CreateActivityFromJSDL ** SOAP_FMAC4 soap_get_PointerTo_bes__CreateActivityFromJSDL(struct soap *soap, _bes__CreateActivityFromJSDL **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_bes__CreateActivityFromJSDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _bes__CreateActivityFromJSDL ** SOAP_FMAC4 soap_in_PointerTo_bes__CreateActivityFromJSDL(struct soap *soap, const char *tag, _bes__CreateActivityFromJSDL **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_bes__CreateActivityFromJSDL **)soap_malloc(soap, sizeof(_bes__CreateActivityFromJSDL *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_bes__CreateActivityFromJSDL *)soap_instantiate__bes__CreateActivityFromJSDL(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_bes__CreateActivityFromJSDL ** p = (_bes__CreateActivityFromJSDL **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes__bes__CreateActivityFromJSDL, sizeof(_bes__CreateActivityFromJSDL), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__UnsupportedJSDLFaultType(struct soap *soap, bes__UnsupportedJSDLFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__UnsupportedJSDLFaultType(struct soap *soap, bes__UnsupportedJSDLFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__UnsupportedJSDLFaultType);
	if (soap_out_PointerTobes__UnsupportedJSDLFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__UnsupportedJSDLFaultType(struct soap *soap, const char *tag, int id, bes__UnsupportedJSDLFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__UnsupportedJSDLFaultType ** SOAP_FMAC4 soap_get_PointerTobes__UnsupportedJSDLFaultType(struct soap *soap, bes__UnsupportedJSDLFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__UnsupportedJSDLFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__UnsupportedJSDLFaultType ** SOAP_FMAC4 soap_in_PointerTobes__UnsupportedJSDLFaultType(struct soap *soap, const char *tag, bes__UnsupportedJSDLFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__UnsupportedJSDLFaultType **)soap_malloc(soap, sizeof(bes__UnsupportedJSDLFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__UnsupportedJSDLFaultType *)soap_instantiate_bes__UnsupportedJSDLFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__UnsupportedJSDLFaultType ** p = (bes__UnsupportedJSDLFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType, sizeof(bes__UnsupportedJSDLFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, bes__UnsupportedFeatureFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, bes__UnsupportedFeatureFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__UnsupportedFeatureFaultType);
	if (soap_out_PointerTobes__UnsupportedFeatureFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, int id, bes__UnsupportedFeatureFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__UnsupportedFeatureFaultType ** SOAP_FMAC4 soap_get_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, bes__UnsupportedFeatureFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__UnsupportedFeatureFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__UnsupportedFeatureFaultType ** SOAP_FMAC4 soap_in_PointerTobes__UnsupportedFeatureFaultType(struct soap *soap, const char *tag, bes__UnsupportedFeatureFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__UnsupportedFeatureFaultType **)soap_malloc(soap, sizeof(bes__UnsupportedFeatureFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__UnsupportedFeatureFaultType *)soap_instantiate_bes__UnsupportedFeatureFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__UnsupportedFeatureFaultType ** p = (bes__UnsupportedFeatureFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType, sizeof(bes__UnsupportedFeatureFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, bes__NotAcceptingNewActivitiesFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, bes__NotAcceptingNewActivitiesFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__NotAcceptingNewActivitiesFaultType);
	if (soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, int id, bes__NotAcceptingNewActivitiesFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__NotAcceptingNewActivitiesFaultType ** SOAP_FMAC4 soap_get_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, bes__NotAcceptingNewActivitiesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__NotAcceptingNewActivitiesFaultType ** SOAP_FMAC4 soap_in_PointerTobes__NotAcceptingNewActivitiesFaultType(struct soap *soap, const char *tag, bes__NotAcceptingNewActivitiesFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__NotAcceptingNewActivitiesFaultType **)soap_malloc(soap, sizeof(bes__NotAcceptingNewActivitiesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__NotAcceptingNewActivitiesFaultType *)soap_instantiate_bes__NotAcceptingNewActivitiesFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__NotAcceptingNewActivitiesFaultType ** p = (bes__NotAcceptingNewActivitiesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType, sizeof(bes__NotAcceptingNewActivitiesFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__JobSpecificationFaultType(struct soap *soap, bes__JobSpecificationFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__JobSpecificationFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__JobSpecificationFaultType(struct soap *soap, bes__JobSpecificationFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__JobSpecificationFaultType);
	if (soap_out_PointerTobes__JobSpecificationFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__JobSpecificationFaultType(struct soap *soap, const char *tag, int id, bes__JobSpecificationFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__JobSpecificationFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__JobSpecificationFaultType ** SOAP_FMAC4 soap_get_PointerTobes__JobSpecificationFaultType(struct soap *soap, bes__JobSpecificationFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__JobSpecificationFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__JobSpecificationFaultType ** SOAP_FMAC4 soap_in_PointerTobes__JobSpecificationFaultType(struct soap *soap, const char *tag, bes__JobSpecificationFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__JobSpecificationFaultType **)soap_malloc(soap, sizeof(bes__JobSpecificationFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__JobSpecificationFaultType *)soap_instantiate_bes__JobSpecificationFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__JobSpecificationFaultType ** p = (bes__JobSpecificationFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__JobSpecificationFaultType, sizeof(bes__JobSpecificationFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, bes__BadlyFormedJSDLDocumentFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, bes__BadlyFormedJSDLDocumentFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__BadlyFormedJSDLDocumentFaultType);
	if (soap_out_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, const char *tag, int id, bes__BadlyFormedJSDLDocumentFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__BadlyFormedJSDLDocumentFaultType ** SOAP_FMAC4 soap_get_PointerTobes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, bes__BadlyFormedJSDLDocumentFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__BadlyFormedJSDLDocumentFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__BadlyFormedJSDLDocumentFaultType ** SOAP_FMAC4 soap_in_PointerTobes__BadlyFormedJSDLDocumentFaultType(struct soap *soap, const char *tag, bes__BadlyFormedJSDLDocumentFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__BadlyFormedJSDLDocumentFaultType **)soap_malloc(soap, sizeof(bes__BadlyFormedJSDLDocumentFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__BadlyFormedJSDLDocumentFaultType *)soap_instantiate_bes__BadlyFormedJSDLDocumentFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__BadlyFormedJSDLDocumentFaultType ** p = (bes__BadlyFormedJSDLDocumentFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType, sizeof(bes__BadlyFormedJSDLDocumentFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__BackendFaultType(struct soap *soap, bes__BackendFaultType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__BackendFaultType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__BackendFaultType(struct soap *soap, bes__BackendFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__BackendFaultType);
	if (soap_out_PointerTobes__BackendFaultType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__BackendFaultType(struct soap *soap, const char *tag, int id, bes__BackendFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__BackendFaultType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__BackendFaultType ** SOAP_FMAC4 soap_get_PointerTobes__BackendFaultType(struct soap *soap, bes__BackendFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__BackendFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__BackendFaultType ** SOAP_FMAC4 soap_in_PointerTobes__BackendFaultType(struct soap *soap, const char *tag, bes__BackendFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__BackendFaultType **)soap_malloc(soap, sizeof(bes__BackendFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__BackendFaultType *)soap_instantiate_bes__BackendFaultType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__BackendFaultType ** p = (bes__BackendFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__BackendFaultType, sizeof(bes__BackendFaultType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bes_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__SourceTarget_USCOREType);
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, jsdl__SourceTarget_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__SourceTarget_USCOREType **)soap_malloc(soap, sizeof(jsdl__SourceTarget_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__SourceTarget_USCOREType *)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__SourceTarget_USCOREType ** p = (jsdl__SourceTarget_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToxsd__NCName);
	if (soap_out_PointerToxsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_xsd__NCName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_xsd__NCName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__OperatingSystemType_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystemType_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystemType_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystemType_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystemType_USCOREType *)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystemType_USCOREType ** p = (jsdl__OperatingSystemType_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__FileSystemTypeEnumeration);
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, enum jsdl__FileSystemTypeEnumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum jsdl__FileSystemTypeEnumeration **)soap_malloc(soap, sizeof(enum jsdl__FileSystemTypeEnumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__RangeValue_USCOREType);
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, jsdl__RangeValue_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__RangeValue_USCOREType **)soap_malloc(soap, sizeof(jsdl__RangeValue_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__RangeValue_USCOREType *)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__RangeValue_USCOREType ** p = (jsdl__RangeValue_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__CPUArchitecture_USCOREType);
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CPUArchitecture_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CPUArchitecture_USCOREType **)soap_malloc(soap, sizeof(jsdl__CPUArchitecture_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CPUArchitecture_USCOREType *)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CPUArchitecture_USCOREType ** p = (jsdl__CPUArchitecture_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__OperatingSystem_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystem_USCOREType *)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystem_USCOREType ** p = (jsdl__OperatingSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bes_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__FileSystem_USCOREType);
	if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__FileSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__FileSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__FileSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__FileSystem_USCOREType *)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__FileSystem_USCOREType ** p = (jsdl__FileSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__CandidateHosts_USCOREType);
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CandidateHosts_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CandidateHosts_USCOREType **)soap_malloc(soap, sizeof(jsdl__CandidateHosts_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CandidateHosts_USCOREType *)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CandidateHosts_USCOREType ** p = (jsdl__CandidateHosts_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__Description_USCOREType))
		soap_serialize_jsdl__Description_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__Description_USCOREType);
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__Description_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Description_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Description_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__Description_USCOREType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__DataStaging_USCOREType);
	if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, jsdl__DataStaging_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__DataStaging_USCOREType **)soap_malloc(soap, sizeof(jsdl__DataStaging_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__DataStaging_USCOREType *)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__DataStaging_USCOREType ** p = (jsdl__DataStaging_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__Resources_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__Resources_USCOREType);
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Resources_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__Resources_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Resources_USCOREType **)soap_malloc(soap, sizeof(jsdl__Resources_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Resources_USCOREType *)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Resources_USCOREType ** p = (jsdl__Resources_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__Application_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__Application_USCOREType);
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Application_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__Application_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Application_USCOREType **)soap_malloc(soap, sizeof(jsdl__Application_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Application_USCOREType *)soap_instantiate_jsdl__Application_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Application_USCOREType ** p = (jsdl__Application_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__JobIdentification_USCOREType);
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobIdentification_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobIdentification_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobIdentification_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobIdentification_USCOREType *)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobIdentification_USCOREType ** p = (jsdl__JobIdentification_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_xsd__ID))
		soap_serialize_xsd__ID(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToxsd__ID);
	if (soap_out_PointerToxsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_xsd__ID);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__ID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_xsd__ID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__JobDescription_USCOREType);
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDescription_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDescription_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDescription_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDescription_USCOREType *)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDescription_USCOREType ** p = (jsdl__JobDescription_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__Range_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__Range_USCOREType);
	if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Range_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__Range_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Range_USCOREType **)soap_malloc(soap, sizeof(jsdl__Range_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Range_USCOREType *)soap_instantiate_jsdl__Range_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Range_USCOREType ** p = (jsdl__Range_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__Exact_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__Exact_USCOREType);
	if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Exact_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__Exact_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Exact_USCOREType **)soap_malloc(soap, sizeof(jsdl__Exact_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Exact_USCOREType *)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Exact_USCOREType ** p = (jsdl__Exact_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__Boundary_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__Boundary_USCOREType);
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Boundary_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__Boundary_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Boundary_USCOREType **)soap_malloc(soap, sizeof(jsdl__Boundary_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Boundary_USCOREType *)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Boundary_USCOREType ** p = (jsdl__Boundary_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaddressing__MetadataType(struct soap *soap, addressing__MetadataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_addressing__MetadataType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaddressing__MetadataType(struct soap *soap, addressing__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToaddressing__MetadataType);
	if (soap_out_PointerToaddressing__MetadataType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaddressing__MetadataType(struct soap *soap, const char *tag, int id, addressing__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_addressing__MetadataType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 addressing__MetadataType ** SOAP_FMAC4 soap_get_PointerToaddressing__MetadataType(struct soap *soap, addressing__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaddressing__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 addressing__MetadataType ** SOAP_FMAC4 soap_in_PointerToaddressing__MetadataType(struct soap *soap, const char *tag, addressing__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (addressing__MetadataType **)soap_malloc(soap, sizeof(addressing__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (addressing__MetadataType *)soap_instantiate_addressing__MetadataType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	addressing__MetadataType ** p = (addressing__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_addressing__MetadataType, sizeof(addressing__MetadataType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaddressing__ReferenceParametersType(struct soap *soap, addressing__ReferenceParametersType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_addressing__ReferenceParametersType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaddressing__ReferenceParametersType(struct soap *soap, addressing__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToaddressing__ReferenceParametersType);
	if (soap_out_PointerToaddressing__ReferenceParametersType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaddressing__ReferenceParametersType(struct soap *soap, const char *tag, int id, addressing__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_addressing__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 addressing__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerToaddressing__ReferenceParametersType(struct soap *soap, addressing__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaddressing__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 addressing__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerToaddressing__ReferenceParametersType(struct soap *soap, const char *tag, addressing__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (addressing__ReferenceParametersType **)soap_malloc(soap, sizeof(addressing__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (addressing__ReferenceParametersType *)soap_instantiate_addressing__ReferenceParametersType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	addressing__ReferenceParametersType ** p = (addressing__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_addressing__ReferenceParametersType, sizeof(addressing__ReferenceParametersType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaddressing__AttributedURIType(struct soap *soap, addressing__AttributedURIType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_addressing__AttributedURIType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaddressing__AttributedURIType(struct soap *soap, addressing__AttributedURIType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToaddressing__AttributedURIType);
	if (soap_out_PointerToaddressing__AttributedURIType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaddressing__AttributedURIType(struct soap *soap, const char *tag, int id, addressing__AttributedURIType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_addressing__AttributedURIType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 addressing__AttributedURIType ** SOAP_FMAC4 soap_get_PointerToaddressing__AttributedURIType(struct soap *soap, addressing__AttributedURIType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaddressing__AttributedURIType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 addressing__AttributedURIType ** SOAP_FMAC4 soap_in_PointerToaddressing__AttributedURIType(struct soap *soap, const char *tag, addressing__AttributedURIType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (addressing__AttributedURIType **)soap_malloc(soap, sizeof(addressing__AttributedURIType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (addressing__AttributedURIType *)soap_instantiate_addressing__AttributedURIType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	addressing__AttributedURIType ** p = (addressing__AttributedURIType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_addressing__AttributedURIType, sizeof(addressing__AttributedURIType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__activity_jsdl_document_type(struct soap *soap, bes__activity_jsdl_document_type *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__activity_jsdl_document_type))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__activity_jsdl_document_type(struct soap *soap, bes__activity_jsdl_document_type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__activity_jsdl_document_type);
	if (soap_out_PointerTobes__activity_jsdl_document_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__activity_jsdl_document_type(struct soap *soap, const char *tag, int id, bes__activity_jsdl_document_type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__activity_jsdl_document_type);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__activity_jsdl_document_type ** SOAP_FMAC4 soap_get_PointerTobes__activity_jsdl_document_type(struct soap *soap, bes__activity_jsdl_document_type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__activity_jsdl_document_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__activity_jsdl_document_type ** SOAP_FMAC4 soap_in_PointerTobes__activity_jsdl_document_type(struct soap *soap, const char *tag, bes__activity_jsdl_document_type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__activity_jsdl_document_type **)soap_malloc(soap, sizeof(bes__activity_jsdl_document_type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__activity_jsdl_document_type *)soap_instantiate_bes__activity_jsdl_document_type(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__activity_jsdl_document_type ** p = (bes__activity_jsdl_document_type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__activity_jsdl_document_type, sizeof(bes__activity_jsdl_document_type), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__state_change_response_type(struct soap *soap, bes__state_change_response_type *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__state_change_response_type))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__state_change_response_type(struct soap *soap, bes__state_change_response_type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__state_change_response_type);
	if (soap_out_PointerTobes__state_change_response_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__state_change_response_type(struct soap *soap, const char *tag, int id, bes__state_change_response_type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__state_change_response_type);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__state_change_response_type ** SOAP_FMAC4 soap_get_PointerTobes__state_change_response_type(struct soap *soap, bes__state_change_response_type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__state_change_response_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__state_change_response_type ** SOAP_FMAC4 soap_in_PointerTobes__state_change_response_type(struct soap *soap, const char *tag, bes__state_change_response_type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__state_change_response_type **)soap_malloc(soap, sizeof(bes__state_change_response_type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__state_change_response_type *)soap_instantiate_bes__state_change_response_type(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__state_change_response_type ** p = (bes__state_change_response_type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__state_change_response_type, sizeof(bes__state_change_response_type), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__state_change_request_type(struct soap *soap, bes__state_change_request_type *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__state_change_request_type))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__state_change_request_type(struct soap *soap, bes__state_change_request_type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__state_change_request_type);
	if (soap_out_PointerTobes__state_change_request_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__state_change_request_type(struct soap *soap, const char *tag, int id, bes__state_change_request_type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__state_change_request_type);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__state_change_request_type ** SOAP_FMAC4 soap_get_PointerTobes__state_change_request_type(struct soap *soap, bes__state_change_request_type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__state_change_request_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__state_change_request_type ** SOAP_FMAC4 soap_in_PointerTobes__state_change_request_type(struct soap *soap, const char *tag, bes__state_change_request_type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__state_change_request_type **)soap_malloc(soap, sizeof(bes__state_change_request_type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__state_change_request_type *)soap_instantiate_bes__state_change_request_type(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__state_change_request_type ** p = (bes__state_change_request_type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__state_change_request_type, sizeof(bes__state_change_request_type), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__activity_status_type(struct soap *soap, bes__activity_status_type *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__activity_status_type))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__activity_status_type(struct soap *soap, bes__activity_status_type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__activity_status_type);
	if (soap_out_PointerTobes__activity_status_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__activity_status_type(struct soap *soap, const char *tag, int id, bes__activity_status_type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__activity_status_type);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__activity_status_type ** SOAP_FMAC4 soap_get_PointerTobes__activity_status_type(struct soap *soap, bes__activity_status_type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__activity_status_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__activity_status_type ** SOAP_FMAC4 soap_in_PointerTobes__activity_status_type(struct soap *soap, const char *tag, bes__activity_status_type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__activity_status_type **)soap_malloc(soap, sizeof(bes__activity_status_type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__activity_status_type *)soap_instantiate_bes__activity_status_type(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__activity_status_type ** p = (bes__activity_status_type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__activity_status_type, sizeof(bes__activity_status_type), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTojsdl__JobDefinition_USCOREType);
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDefinition_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDefinition_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDefinition_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDefinition_USCOREType *)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDefinition_USCOREType ** p = (jsdl__JobDefinition_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__requested_state_change_type(struct soap *soap, bes__requested_state_change_type *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__requested_state_change_type))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__requested_state_change_type(struct soap *soap, bes__requested_state_change_type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__requested_state_change_type);
	if (soap_out_PointerTobes__requested_state_change_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__requested_state_change_type(struct soap *soap, const char *tag, int id, bes__requested_state_change_type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__requested_state_change_type);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__requested_state_change_type ** SOAP_FMAC4 soap_get_PointerTobes__requested_state_change_type(struct soap *soap, bes__requested_state_change_type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__requested_state_change_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__requested_state_change_type ** SOAP_FMAC4 soap_in_PointerTobes__requested_state_change_type(struct soap *soap, const char *tag, bes__requested_state_change_type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__requested_state_change_type **)soap_malloc(soap, sizeof(bes__requested_state_change_type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__requested_state_change_type *)soap_instantiate_bes__requested_state_change_type(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__requested_state_change_type ** p = (bes__requested_state_change_type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__requested_state_change_type, sizeof(bes__requested_state_change_type), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__data_stage_status_type(struct soap *soap, bes__data_stage_status_type *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__data_stage_status_type))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__data_stage_status_type(struct soap *soap, bes__data_stage_status_type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__data_stage_status_type);
	if (soap_out_PointerTobes__data_stage_status_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__data_stage_status_type(struct soap *soap, const char *tag, int id, bes__data_stage_status_type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__data_stage_status_type);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__data_stage_status_type ** SOAP_FMAC4 soap_get_PointerTobes__data_stage_status_type(struct soap *soap, bes__data_stage_status_type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__data_stage_status_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__data_stage_status_type ** SOAP_FMAC4 soap_in_PointerTobes__data_stage_status_type(struct soap *soap, const char *tag, bes__data_stage_status_type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__data_stage_status_type **)soap_malloc(soap, sizeof(bes__data_stage_status_type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__data_stage_status_type *)soap_instantiate_bes__data_stage_status_type(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__data_stage_status_type ** p = (bes__data_stage_status_type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__data_stage_status_type, sizeof(bes__data_stage_status_type), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__overall_status_type(struct soap *soap, bes__overall_status_type *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_bes__overall_status_type))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__overall_status_type(struct soap *soap, bes__overall_status_type *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__overall_status_type);
	if (soap_out_PointerTobes__overall_status_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__overall_status_type(struct soap *soap, const char *tag, int id, bes__overall_status_type *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__overall_status_type);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 bes__overall_status_type ** SOAP_FMAC4 soap_get_PointerTobes__overall_status_type(struct soap *soap, bes__overall_status_type **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__overall_status_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bes__overall_status_type ** SOAP_FMAC4 soap_in_PointerTobes__overall_status_type(struct soap *soap, const char *tag, bes__overall_status_type **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bes__overall_status_type **)soap_malloc(soap, sizeof(bes__overall_status_type *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (bes__overall_status_type *)soap_instantiate_bes__overall_status_type(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	bes__overall_status_type ** p = (bes__overall_status_type **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__overall_status_type, sizeof(bes__overall_status_type), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToaddressing__EndpointReferenceType(struct soap *soap, addressing__EndpointReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_addressing__EndpointReferenceType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToaddressing__EndpointReferenceType(struct soap *soap, addressing__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerToaddressing__EndpointReferenceType);
	if (soap_out_PointerToaddressing__EndpointReferenceType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToaddressing__EndpointReferenceType(struct soap *soap, const char *tag, int id, addressing__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_addressing__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 addressing__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerToaddressing__EndpointReferenceType(struct soap *soap, addressing__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToaddressing__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 addressing__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerToaddressing__EndpointReferenceType(struct soap *soap, const char *tag, addressing__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (addressing__EndpointReferenceType **)soap_malloc(soap, sizeof(addressing__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (addressing__EndpointReferenceType *)soap_instantiate_addressing__EndpointReferenceType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	addressing__EndpointReferenceType ** p = (addressing__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_addressing__EndpointReferenceType, sizeof(addressing__EndpointReferenceType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__data_staging_state_enumeration(struct soap *soap, enum bes__data_staging_state_enumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bes_bes__data_staging_state_enumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__data_staging_state_enumeration(struct soap *soap, enum bes__data_staging_state_enumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__data_staging_state_enumeration);
	if (soap_out_PointerTobes__data_staging_state_enumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__data_staging_state_enumeration(struct soap *soap, const char *tag, int id, enum bes__data_staging_state_enumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__data_staging_state_enumeration);
	if (id < 0)
		return soap->error;
	return soap_out_bes__data_staging_state_enumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum bes__data_staging_state_enumeration ** SOAP_FMAC4 soap_get_PointerTobes__data_staging_state_enumeration(struct soap *soap, enum bes__data_staging_state_enumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__data_staging_state_enumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum bes__data_staging_state_enumeration ** SOAP_FMAC4 soap_in_PointerTobes__data_staging_state_enumeration(struct soap *soap, const char *tag, enum bes__data_staging_state_enumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum bes__data_staging_state_enumeration **)soap_malloc(soap, sizeof(enum bes__data_staging_state_enumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__data_staging_state_enumeration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum bes__data_staging_state_enumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__data_staging_state_enumeration, sizeof(enum bes__data_staging_state_enumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bes_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobes__overall_state_enumeration(struct soap *soap, enum bes__overall_state_enumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bes_bes__overall_state_enumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobes__overall_state_enumeration(struct soap *soap, enum bes__overall_state_enumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_PointerTobes__overall_state_enumeration);
	if (soap_out_PointerTobes__overall_state_enumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobes__overall_state_enumeration(struct soap *soap, const char *tag, int id, enum bes__overall_state_enumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bes_bes__overall_state_enumeration);
	if (id < 0)
		return soap->error;
	return soap_out_bes__overall_state_enumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum bes__overall_state_enumeration ** SOAP_FMAC4 soap_get_PointerTobes__overall_state_enumeration(struct soap *soap, enum bes__overall_state_enumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobes__overall_state_enumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum bes__overall_state_enumeration ** SOAP_FMAC4 soap_in_PointerTobes__overall_state_enumeration(struct soap *soap, const char *tag, enum bes__overall_state_enumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum bes__overall_state_enumeration **)soap_malloc(soap, sizeof(enum bes__overall_state_enumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bes__overall_state_enumeration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum bes__overall_state_enumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bes_bes__overall_state_enumeration, sizeof(enum bes__overall_state_enumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_bes__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_bes__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bes_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bes_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_bes_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_bes_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, std::vector<jsdl__FileSystem_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const std::vector<jsdl__FileSystem_USCOREType * >*a)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__FileSystem_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1)))
		return NULL;
	jsdl__FileSystem_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_jsdl__FileSystem_USCOREType, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, NULL, "jsdl:FileSystem_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, &n, "jsdl:FileSystem_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__FileSystem_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, std::vector<jsdl__FileSystem_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__FileSystem_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__FileSystem_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__FileSystem_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__FileSystem_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__FileSystem_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__FileSystem_USCOREType * >*)p = *(std::vector<jsdl__FileSystem_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_std__string, SOAP_TYPE_bes_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, std::vector<jsdl__DataStaging_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const std::vector<jsdl__DataStaging_USCOREType * >*a)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__DataStaging_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1)))
		return NULL;
	jsdl__DataStaging_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_jsdl__DataStaging_USCOREType, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, NULL, "jsdl:DataStaging_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, &n, "jsdl:DataStaging_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__DataStaging_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, std::vector<jsdl__DataStaging_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__DataStaging_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__DataStaging_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__DataStaging_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__DataStaging_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__DataStaging_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__DataStaging_USCOREType * >*)p = *(std::vector<jsdl__DataStaging_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, std::vector<jsdl__Range_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const std::vector<jsdl__Range_USCOREType * >*a)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Range_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1)))
		return NULL;
	jsdl__Range_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_jsdl__Range_USCOREType, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, NULL, "jsdl:Range_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, &n, "jsdl:Range_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__Range_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, std::vector<jsdl__Range_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__Range_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__Range_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__Range_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Range_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Range_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Range_USCOREType * >*)p = *(std::vector<jsdl__Range_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, std::vector<jsdl__Exact_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const std::vector<jsdl__Exact_USCOREType * >*a)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Exact_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1)))
		return NULL;
	jsdl__Exact_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_jsdl__Exact_USCOREType, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, NULL, "jsdl:Exact_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, &n, "jsdl:Exact_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__Exact_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, std::vector<jsdl__Exact_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__Exact_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__Exact_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__Exact_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Exact_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Exact_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Exact_USCOREType * >*)p = *(std::vector<jsdl__Exact_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes__XML, SOAP_TYPE_bes_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, std::vector<bes__activity_jsdl_document_type * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, const std::vector<bes__activity_jsdl_document_type * >*a)
{
	for (std::vector<bes__activity_jsdl_document_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobes__activity_jsdl_document_type(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, const char *tag, int id, const std::vector<bes__activity_jsdl_document_type * >*a, const char *type)
{
	for (std::vector<bes__activity_jsdl_document_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobes__activity_jsdl_document_type(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bes__activity_jsdl_document_type * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, const char *tag, std::vector<bes__activity_jsdl_document_type * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(soap, -1)))
		return NULL;
	bes__activity_jsdl_document_type *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_bes__activity_jsdl_document_type, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type, sizeof(bes__activity_jsdl_document_type), 1))
				break;
			if (!soap_in_PointerTobes__activity_jsdl_document_type(soap, tag, NULL, "bes:activity-jsdl-document-type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobes__activity_jsdl_document_type(soap, tag, &n, "bes:activity-jsdl-document-type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<bes__activity_jsdl_document_type * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, std::vector<bes__activity_jsdl_document_type * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bes__activity_jsdl_document_type * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<bes__activity_jsdl_document_type * >;
		if (size)
			*size = sizeof(std::vector<bes__activity_jsdl_document_type * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<bes__activity_jsdl_document_type * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<bes__activity_jsdl_document_type * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<bes__activity_jsdl_document_type * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobes__activity_jsdl_document_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<bes__activity_jsdl_document_type * > %p -> %p\n", q, p));
	*(std::vector<bes__activity_jsdl_document_type * >*)p = *(std::vector<bes__activity_jsdl_document_type * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, std::vector<bes__state_change_response_type * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, const std::vector<bes__state_change_response_type * >*a)
{
	for (std::vector<bes__state_change_response_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobes__state_change_response_type(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, const char *tag, int id, const std::vector<bes__state_change_response_type * >*a, const char *type)
{
	for (std::vector<bes__state_change_response_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobes__state_change_response_type(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bes__state_change_response_type * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, const char *tag, std::vector<bes__state_change_response_type * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobes__state_change_response_type(soap, -1)))
		return NULL;
	bes__state_change_response_type *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_bes__state_change_response_type, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_response_type, sizeof(bes__state_change_response_type), 1))
				break;
			if (!soap_in_PointerTobes__state_change_response_type(soap, tag, NULL, "bes:state-change-response-type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobes__state_change_response_type(soap, tag, &n, "bes:state-change-response-type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<bes__state_change_response_type * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_response_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, std::vector<bes__state_change_response_type * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bes__state_change_response_type * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_response_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_response_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<bes__state_change_response_type * >;
		if (size)
			*size = sizeof(std::vector<bes__state_change_response_type * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<bes__state_change_response_type * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<bes__state_change_response_type * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<bes__state_change_response_type * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobes__state_change_response_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<bes__state_change_response_type * > %p -> %p\n", q, p));
	*(std::vector<bes__state_change_response_type * >*)p = *(std::vector<bes__state_change_response_type * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, std::vector<bes__state_change_request_type * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, const std::vector<bes__state_change_request_type * >*a)
{
	for (std::vector<bes__state_change_request_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobes__state_change_request_type(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, const char *tag, int id, const std::vector<bes__state_change_request_type * >*a, const char *type)
{
	for (std::vector<bes__state_change_request_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobes__state_change_request_type(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bes__state_change_request_type * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, const char *tag, std::vector<bes__state_change_request_type * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobes__state_change_request_type(soap, -1)))
		return NULL;
	bes__state_change_request_type *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_bes__state_change_request_type, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_request_type, sizeof(bes__state_change_request_type), 1))
				break;
			if (!soap_in_PointerTobes__state_change_request_type(soap, tag, NULL, "bes:state-change-request-type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobes__state_change_request_type(soap, tag, &n, "bes:state-change-request-type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<bes__state_change_request_type * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_request_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, std::vector<bes__state_change_request_type * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bes__state_change_request_type * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobes__state_change_request_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__state_change_request_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<bes__state_change_request_type * >;
		if (size)
			*size = sizeof(std::vector<bes__state_change_request_type * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<bes__state_change_request_type * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<bes__state_change_request_type * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<bes__state_change_request_type * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobes__state_change_request_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<bes__state_change_request_type * > %p -> %p\n", q, p));
	*(std::vector<bes__state_change_request_type * >*)p = *(std::vector<bes__state_change_request_type * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, std::vector<bes__activity_status_type * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, const std::vector<bes__activity_status_type * >*a)
{
	for (std::vector<bes__activity_status_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobes__activity_status_type(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, const char *tag, int id, const std::vector<bes__activity_status_type * >*a, const char *type)
{
	for (std::vector<bes__activity_status_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobes__activity_status_type(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bes__activity_status_type * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, const char *tag, std::vector<bes__activity_status_type * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobes__activity_status_type(soap, -1)))
		return NULL;
	bes__activity_status_type *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_bes__activity_status_type, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_status_type, sizeof(bes__activity_status_type), 1))
				break;
			if (!soap_in_PointerTobes__activity_status_type(soap, tag, NULL, "bes:activity-status-type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobes__activity_status_type(soap, tag, &n, "bes:activity-status-type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<bes__activity_status_type * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobes__activity_status_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, std::vector<bes__activity_status_type * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bes__activity_status_type * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobes__activity_status_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__activity_status_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<bes__activity_status_type * >;
		if (size)
			*size = sizeof(std::vector<bes__activity_status_type * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<bes__activity_status_type * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<bes__activity_status_type * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<bes__activity_status_type * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobes__activity_status_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<bes__activity_status_type * > %p -> %p\n", q, p));
	*(std::vector<bes__activity_status_type * >*)p = *(std::vector<bes__activity_status_type * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, std::vector<addressing__EndpointReferenceType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, const std::vector<addressing__EndpointReferenceType * >*a)
{
	for (std::vector<addressing__EndpointReferenceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToaddressing__EndpointReferenceType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, const char *tag, int id, const std::vector<addressing__EndpointReferenceType * >*a, const char *type)
{
	for (std::vector<addressing__EndpointReferenceType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToaddressing__EndpointReferenceType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<addressing__EndpointReferenceType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, const char *tag, std::vector<addressing__EndpointReferenceType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, -1)))
		return NULL;
	addressing__EndpointReferenceType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_addressing__EndpointReferenceType, SOAP_TYPE_bes_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType, sizeof(addressing__EndpointReferenceType), 1))
				break;
			if (!soap_in_PointerToaddressing__EndpointReferenceType(soap, tag, NULL, "addressing:EndpointReferenceType"))
				break;
		}
		else
		{
			if (!soap_in_PointerToaddressing__EndpointReferenceType(soap, tag, &n, "addressing:EndpointReferenceType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<addressing__EndpointReferenceType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, std::vector<addressing__EndpointReferenceType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<addressing__EndpointReferenceType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<addressing__EndpointReferenceType * >;
		if (size)
			*size = sizeof(std::vector<addressing__EndpointReferenceType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<addressing__EndpointReferenceType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<addressing__EndpointReferenceType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<addressing__EndpointReferenceType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToaddressing__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<addressing__EndpointReferenceType * > %p -> %p\n", q, p));
	*(std::vector<addressing__EndpointReferenceType * >*)p = *(std::vector<addressing__EndpointReferenceType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, std::vector<bes__data_stage_status_type * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, const std::vector<bes__data_stage_status_type * >*a)
{
	for (std::vector<bes__data_stage_status_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTobes__data_stage_status_type(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, const char *tag, int id, const std::vector<bes__data_stage_status_type * >*a, const char *type)
{
	for (std::vector<bes__data_stage_status_type * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTobes__data_stage_status_type(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bes__data_stage_status_type * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, const char *tag, std::vector<bes__data_stage_status_type * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTobes__data_stage_status_type(soap, -1)))
		return NULL;
	bes__data_stage_status_type *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bes_bes__data_stage_status_type, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__data_stage_status_type, sizeof(bes__data_stage_status_type), 1))
				break;
			if (!soap_in_PointerTobes__data_stage_status_type(soap, tag, NULL, "bes:data-stage-status-type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTobes__data_stage_status_type(soap, tag, &n, "bes:data-stage-status-type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<bes__data_stage_status_type * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTobes__data_stage_status_type(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, std::vector<bes__data_stage_status_type * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bes__data_stage_status_type * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTobes__data_stage_status_type(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_bes_std__vectorTemplateOfPointerTobes__data_stage_status_type, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<bes__data_stage_status_type * >;
		if (size)
			*size = sizeof(std::vector<bes__data_stage_status_type * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<bes__data_stage_status_type * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<bes__data_stage_status_type * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<bes__data_stage_status_type * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTobes__data_stage_status_type(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<bes__data_stage_status_type * > %p -> %p\n", q, p));
	*(std::vector<bes__data_stage_status_type * >*)p = *(std::vector<bes__data_stage_status_type * >*)q;
}

} // namespace bes


/* End of besC.cpp */
