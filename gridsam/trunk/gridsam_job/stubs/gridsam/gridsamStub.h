/* gridsamStub.h
   Generated by gSOAP 2.7.11 from ./wsdl/wsdl/gridsam.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef gridsamStub_H
#define gridsamStub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_gridsam__StateType
#define SOAP_TYPE_gridsam__StateType (61)
/* gridsam:StateType */
enum gridsam__StateType {gridsam__StateType__pending = 0, gridsam__StateType__staging_in = 1, gridsam__StateType__staged_in = 2, gridsam__StateType__staging_out = 3, gridsam__StateType__staged_out = 4, gridsam__StateType__active = 5, gridsam__StateType__executed = 6, gridsam__StateType__failed = 7, gridsam__StateType__done = 8, gridsam__StateType__terminating = 9, gridsam__StateType__terminated = 10, gridsam__StateType__undefined = 11};
#endif

#ifndef SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration
#define SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration (62)
/* jsdl:ProcessorArchitectureEnumeration */
enum jsdl__ProcessorArchitectureEnumeration {jsdl__ProcessorArchitectureEnumeration__sparc = 0, jsdl__ProcessorArchitectureEnumeration__powerpc = 1, jsdl__ProcessorArchitectureEnumeration__x86 = 2, jsdl__ProcessorArchitectureEnumeration__x86_USCORE32 = 3, jsdl__ProcessorArchitectureEnumeration__x86_USCORE64 = 4, jsdl__ProcessorArchitectureEnumeration__parisc = 5, jsdl__ProcessorArchitectureEnumeration__mips = 6, jsdl__ProcessorArchitectureEnumeration__ia64 = 7, jsdl__ProcessorArchitectureEnumeration__arm = 8, jsdl__ProcessorArchitectureEnumeration__other = 9};
#endif

#ifndef SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration
#define SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration (63)
/* jsdl:OperatingSystemTypeEnumeration */
enum jsdl__OperatingSystemTypeEnumeration {jsdl__OperatingSystemTypeEnumeration__Unknown = 0, jsdl__OperatingSystemTypeEnumeration__MACOS = 1, jsdl__OperatingSystemTypeEnumeration__ATTUNIX = 2, jsdl__OperatingSystemTypeEnumeration__DGUX = 3, jsdl__OperatingSystemTypeEnumeration__DECNT = 4, jsdl__OperatingSystemTypeEnumeration__Tru64_USCOREUNIX = 5, jsdl__OperatingSystemTypeEnumeration__OpenVMS = 6, jsdl__OperatingSystemTypeEnumeration__HPUX = 7, jsdl__OperatingSystemTypeEnumeration__AIX = 8, jsdl__OperatingSystemTypeEnumeration__MVS = 9, jsdl__OperatingSystemTypeEnumeration__OS400 = 10, jsdl__OperatingSystemTypeEnumeration__OS_USCORE2 = 11, jsdl__OperatingSystemTypeEnumeration__JavaVM = 12, jsdl__OperatingSystemTypeEnumeration__MSDOS = 13, jsdl__OperatingSystemTypeEnumeration__WIN3x = 14, jsdl__OperatingSystemTypeEnumeration__WIN95 = 15, jsdl__OperatingSystemTypeEnumeration__WIN98 = 16, jsdl__OperatingSystemTypeEnumeration__WINNT = 17, jsdl__OperatingSystemTypeEnumeration__WINCE = 18, jsdl__OperatingSystemTypeEnumeration__NCR3000 = 19, jsdl__OperatingSystemTypeEnumeration__NetWare = 20, jsdl__OperatingSystemTypeEnumeration__OSF = 21, jsdl__OperatingSystemTypeEnumeration__DC_USCOREOS = 22, jsdl__OperatingSystemTypeEnumeration__Reliant_USCOREUNIX = 23, jsdl__OperatingSystemTypeEnumeration__SCO_USCOREUnixWare = 24, jsdl__OperatingSystemTypeEnumeration__SCO_USCOREOpenServer = 25, jsdl__OperatingSystemTypeEnumeration__Sequent = 26, jsdl__OperatingSystemTypeEnumeration__IRIX = 27, jsdl__OperatingSystemTypeEnumeration__Solaris = 28, jsdl__OperatingSystemTypeEnumeration__SunOS = 29, jsdl__OperatingSystemTypeEnumeration__U6000 = 30, jsdl__OperatingSystemTypeEnumeration__ASERIES = 31, jsdl__OperatingSystemTypeEnumeration__TandemNSK = 32, jsdl__OperatingSystemTypeEnumeration__TandemNT = 33, jsdl__OperatingSystemTypeEnumeration__BS2000 = 34, jsdl__OperatingSystemTypeEnumeration__LINUX = 35, jsdl__OperatingSystemTypeEnumeration__Lynx = 36, jsdl__OperatingSystemTypeEnumeration__XENIX = 37, jsdl__OperatingSystemTypeEnumeration__VM = 38, jsdl__OperatingSystemTypeEnumeration__Interactive_USCOREUNIX = 39, jsdl__OperatingSystemTypeEnumeration__BSDUNIX = 40, jsdl__OperatingSystemTypeEnumeration__FreeBSD = 41, jsdl__OperatingSystemTypeEnumeration__NetBSD = 42, jsdl__OperatingSystemTypeEnumeration__GNU_USCOREHurd = 43, jsdl__OperatingSystemTypeEnumeration__OS9 = 44, jsdl__OperatingSystemTypeEnumeration__MACH_USCOREKernel = 45, jsdl__OperatingSystemTypeEnumeration__Inferno = 46, jsdl__OperatingSystemTypeEnumeration__QNX = 47, jsdl__OperatingSystemTypeEnumeration__EPOC = 48, jsdl__OperatingSystemTypeEnumeration__IxWorks = 49, jsdl__OperatingSystemTypeEnumeration__VxWorks = 50, jsdl__OperatingSystemTypeEnumeration__MiNT = 51, jsdl__OperatingSystemTypeEnumeration__BeOS = 52, jsdl__OperatingSystemTypeEnumeration__HP_USCOREMPE = 53, jsdl__OperatingSystemTypeEnumeration__NextStep = 54, jsdl__OperatingSystemTypeEnumeration__PalmPilot = 55, jsdl__OperatingSystemTypeEnumeration__Rhapsody = 56, jsdl__OperatingSystemTypeEnumeration__Windows_USCORE2000 = 57, jsdl__OperatingSystemTypeEnumeration__Dedicated = 58, jsdl__OperatingSystemTypeEnumeration__OS_USCORE390 = 59, jsdl__OperatingSystemTypeEnumeration__VSE = 60, jsdl__OperatingSystemTypeEnumeration__TPF = 61, jsdl__OperatingSystemTypeEnumeration__Windows_USCORER_USCOREMe = 62, jsdl__OperatingSystemTypeEnumeration__Caldera_USCOREOpen_USCOREUNIX = 63, jsdl__OperatingSystemTypeEnumeration__OpenBSD = 64, jsdl__OperatingSystemTypeEnumeration__Not_USCOREApplicable = 65, jsdl__OperatingSystemTypeEnumeration__Windows_USCOREXP = 66, jsdl__OperatingSystemTypeEnumeration__z_USCOREOS = 67, jsdl__OperatingSystemTypeEnumeration__other = 68};
#endif

#ifndef SOAP_TYPE_jsdl__FileSystemTypeEnumeration
#define SOAP_TYPE_jsdl__FileSystemTypeEnumeration (64)
/* jsdl:FileSystemTypeEnumeration */
enum jsdl__FileSystemTypeEnumeration {jsdl__FileSystemTypeEnumeration__swap = 0, jsdl__FileSystemTypeEnumeration__temporary = 1, jsdl__FileSystemTypeEnumeration__spool = 2, jsdl__FileSystemTypeEnumeration__normal = 3};
#endif

#ifndef SOAP_TYPE_jsdl__CreationFlagEnumeration
#define SOAP_TYPE_jsdl__CreationFlagEnumeration (65)
/* jsdl:CreationFlagEnumeration */
enum jsdl__CreationFlagEnumeration {jsdl__CreationFlagEnumeration__overwrite = 0, jsdl__CreationFlagEnumeration__append = 1, jsdl__CreationFlagEnumeration__dontOverwrite = 2};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_gridsam__JobStatusType
#define SOAP_TYPE_gridsam__JobStatusType (15)
/* gridsam:JobStatusType */
class SOAP_CMAC gridsam__JobStatusType
{
public:
	class gridsam__JobIdentifierType *gridsam__JobIdentifier;	/* required element of type gridsam:JobIdentifierType */
	std::vector<class _gridsam__Stage * >gridsam__Stage;	/* required element of type gridsam:Stage */
	std::vector<class _gridsam__Property * >gridsam__Property;	/* optional element of type gridsam:Property */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_gridsam__JobStatusType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam__JobStatusType() : gridsam__JobIdentifier(NULL), soap(NULL) { }
	virtual ~gridsam__JobStatusType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam__JobIdentifierType
#define SOAP_TYPE_gridsam__JobIdentifierType (16)
/* gridsam:JobIdentifierType */
class SOAP_CMAC gridsam__JobIdentifierType
{
public:
	std::string ID;	/* required element of type xsd:anyURI */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_gridsam__JobIdentifierType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam__JobIdentifierType() : soap(NULL) { }
	virtual ~gridsam__JobIdentifierType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam__JobDescriptionType
#define SOAP_TYPE_gridsam__JobDescriptionType (17)
/* gridsam:JobDescriptionType */
class SOAP_CMAC gridsam__JobDescriptionType
{
public:
	class jsdl__JobDefinition_USCOREType *jsdl__JobDefinition;	/* required element of type jsdl:JobDefinition_Type */
	char *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_gridsam__JobDescriptionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam__JobDescriptionType() : jsdl__JobDefinition(NULL), __any(NULL), soap(NULL) { }
	virtual ~gridsam__JobDescriptionType() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__Property
#define SOAP_TYPE__gridsam__Property (18)
/* gridsam:Property */
class SOAP_CMAC _gridsam__Property
{
public:
	char *__any;
	std::string *name;	/* optional attribute */
	char *__mixed;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE__gridsam__Property */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__Property() : __any(NULL), name(NULL), __mixed(NULL), soap(NULL) { }
	virtual ~_gridsam__Property() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__Stage
#define SOAP_TYPE__gridsam__Stage (19)
/* gridsam:Stage */
class SOAP_CMAC _gridsam__Stage
{
public:
	enum gridsam__StateType State;	/* required element of type gridsam:StateType */
	std::string Description;	/* required element of type xsd:string */
	time_t Time;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__gridsam__Stage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__Stage() : State((enum gridsam__StateType)0), Time(0), soap(NULL) { }
	virtual ~_gridsam__Stage() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__submitJob
#define SOAP_TYPE__gridsam__submitJob (20)
/* gridsam:submitJob */
class SOAP_CMAC _gridsam__submitJob
{
public:
	std::vector<gridsam__JobDescriptionType * >gridsam__JobDescription;	/* required element of type gridsam:JobDescriptionType */
	bool startSuspended;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__gridsam__submitJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__submitJob() : startSuspended((bool)0), soap(NULL) { }
	virtual ~_gridsam__submitJob() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__submitJobResponse
#define SOAP_TYPE__gridsam__submitJobResponse (21)
/* gridsam:submitJobResponse */
class SOAP_CMAC _gridsam__submitJobResponse
{
public:
	std::vector<gridsam__JobIdentifierType * >gridsam__JobIdentifier;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type gridsam:JobIdentifierType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__gridsam__submitJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__submitJobResponse() : soap(NULL) { }
	virtual ~_gridsam__submitJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__getJobStatus
#define SOAP_TYPE__gridsam__getJobStatus (22)
/* gridsam:getJobStatus */
class SOAP_CMAC _gridsam__getJobStatus
{
public:
	std::vector<gridsam__JobIdentifierType * >gridsam__JobIdentifier;	/* required element of type gridsam:JobIdentifierType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__gridsam__getJobStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__getJobStatus() : soap(NULL) { }
	virtual ~_gridsam__getJobStatus() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__getJobStatusResponse
#define SOAP_TYPE__gridsam__getJobStatusResponse (23)
/* gridsam:getJobStatusResponse */
class SOAP_CMAC _gridsam__getJobStatusResponse
{
public:
	std::vector<gridsam__JobStatusType * >gridsam__JobStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type gridsam:JobStatusType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__gridsam__getJobStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__getJobStatusResponse() : soap(NULL) { }
	virtual ~_gridsam__getJobStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__terminateJob
#define SOAP_TYPE__gridsam__terminateJob (24)
/* gridsam:terminateJob */
class SOAP_CMAC _gridsam__terminateJob
{
public:
	std::vector<gridsam__JobIdentifierType * >gridsam__JobIdentifier;	/* required element of type gridsam:JobIdentifierType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__gridsam__terminateJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__terminateJob() : soap(NULL) { }
	virtual ~_gridsam__terminateJob() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__terminateJobResponse
#define SOAP_TYPE__gridsam__terminateJobResponse (25)
/* gridsam:terminateJobResponse */
class SOAP_CMAC _gridsam__terminateJobResponse
{
public:
	std::vector<gridsam__JobStatusType * >gridsam__JobStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type gridsam:JobStatusType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__gridsam__terminateJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__terminateJobResponse() : soap(NULL) { }
	virtual ~_gridsam__terminateJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__startJob
#define SOAP_TYPE__gridsam__startJob (26)
/* gridsam:startJob */
class SOAP_CMAC _gridsam__startJob
{
public:
	std::vector<gridsam__JobIdentifierType * >gridsam__JobIdentifier;	/* required element of type gridsam:JobIdentifierType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__gridsam__startJob */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__startJob() : soap(NULL) { }
	virtual ~_gridsam__startJob() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__startJobResponse
#define SOAP_TYPE__gridsam__startJobResponse (27)
/* gridsam:startJobResponse */
class SOAP_CMAC _gridsam__startJobResponse
{
public:
	std::vector<gridsam__JobStatusType * >gridsam__JobStatus;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type gridsam:JobStatusType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__gridsam__startJobResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__startJobResponse() : soap(NULL) { }
	virtual ~_gridsam__startJobResponse() { }
};
#endif

#ifndef SOAP_TYPE__gridsam__UnknownJobFault
#define SOAP_TYPE__gridsam__UnknownJobFault (28)
/* gridsam:UnknownJobFault */
class SOAP_CMAC _gridsam__UnknownJobFault
{
public:
	std::vector<gridsam__JobIdentifierType * >JobIdentifier;	/* required element of type gridsam:JobIdentifierType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__gridsam__UnknownJobFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _gridsam__UnknownJobFault() : soap(NULL) { }
	virtual ~_gridsam__UnknownJobFault() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Range_USCOREType
#define SOAP_TYPE_jsdl__Range_USCOREType (31)
/* jsdl:Range_Type */
class SOAP_CMAC jsdl__Range_USCOREType
{
public:
	class jsdl__Boundary_USCOREType *LowerBound;	/* required element of type jsdl:Boundary_Type */
	jsdl__Boundary_USCOREType *UpperBound;	/* required element of type jsdl:Boundary_Type */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_jsdl__Range_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Range_USCOREType() : LowerBound(NULL), UpperBound(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Range_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__RangeValue_USCOREType
#define SOAP_TYPE_jsdl__RangeValue_USCOREType (32)
/* jsdl:RangeValue_Type */
class SOAP_CMAC jsdl__RangeValue_USCOREType
{
public:
	jsdl__Boundary_USCOREType *UpperBoundedRange;	/* optional element of type jsdl:Boundary_Type */
	jsdl__Boundary_USCOREType *LowerBoundedRange;	/* optional element of type jsdl:Boundary_Type */
	std::vector<class jsdl__Exact_USCOREType * >Exact;	/* optional element of type jsdl:Exact_Type */
	std::vector<jsdl__Range_USCOREType * >Range;	/* optional element of type jsdl:Range_Type */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_jsdl__RangeValue_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__RangeValue_USCOREType() : UpperBoundedRange(NULL), LowerBoundedRange(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__RangeValue_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__JobDefinition_USCOREType
#define SOAP_TYPE_jsdl__JobDefinition_USCOREType (33)
/* jsdl:JobDefinition_Type */
class SOAP_CMAC jsdl__JobDefinition_USCOREType
{
public:
	class jsdl__JobDescription_USCOREType *jsdl__JobDescription;	/* required element of type jsdl:JobDescription_Type */
	std::vector<char * >__any;
	std::string *id;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_jsdl__JobDefinition_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobDefinition_USCOREType() : jsdl__JobDescription(NULL), id(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__JobDefinition_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__JobDescription_USCOREType
#define SOAP_TYPE_jsdl__JobDescription_USCOREType (34)
/* jsdl:JobDescription_Type */
class SOAP_CMAC jsdl__JobDescription_USCOREType
{
public:
	class jsdl__JobIdentification_USCOREType *jsdl__JobIdentification;	/* optional element of type jsdl:JobIdentification_Type */
	class jsdl__Application_USCOREType *jsdl__Application;	/* optional element of type jsdl:Application_Type */
	class jsdl__Resources_USCOREType *jsdl__Resources;	/* optional element of type jsdl:Resources_Type */
	std::vector<class jsdl__DataStaging_USCOREType * >jsdl__DataStaging;	/* optional element of type jsdl:DataStaging_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_jsdl__JobDescription_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobDescription_USCOREType() : jsdl__JobIdentification(NULL), jsdl__Application(NULL), jsdl__Resources(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__JobDescription_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__JobIdentification_USCOREType
#define SOAP_TYPE_jsdl__JobIdentification_USCOREType (35)
/* jsdl:JobIdentification_Type */
class SOAP_CMAC jsdl__JobIdentification_USCOREType
{
public:
	std::string *jsdl__JobName;	/* optional element of type xsd:string */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::vector<std::string >jsdl__JobAnnotation;	/* optional element of type xsd:string */
	std::vector<std::string >jsdl__JobProject;	/* optional element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_jsdl__JobIdentification_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobIdentification_USCOREType() : jsdl__JobName(NULL), jsdl__Description(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__JobIdentification_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Application_USCOREType
#define SOAP_TYPE_jsdl__Application_USCOREType (36)
/* jsdl:Application_Type */
class SOAP_CMAC jsdl__Application_USCOREType
{
public:
	std::string *jsdl__ApplicationName;	/* optional element of type xsd:string */
	std::string *jsdl__ApplicationVersion;	/* optional element of type xsd:string */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_jsdl__Application_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Application_USCOREType() : jsdl__ApplicationName(NULL), jsdl__ApplicationVersion(NULL), jsdl__Description(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Application_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Resources_USCOREType
#define SOAP_TYPE_jsdl__Resources_USCOREType (37)
/* jsdl:Resources_Type */
class SOAP_CMAC jsdl__Resources_USCOREType
{
public:
	class jsdl__CandidateHosts_USCOREType *jsdl__CandidateHosts;	/* optional element of type jsdl:CandidateHosts_Type */
	std::vector<class jsdl__FileSystem_USCOREType * >jsdl__FileSystem;	/* optional element of type jsdl:FileSystem_Type */
	bool *jsdl__ExclusiveExecution;	/* optional element of type xsd:boolean */
	class jsdl__OperatingSystem_USCOREType *jsdl__OperatingSystem;	/* optional element of type jsdl:OperatingSystem_Type */
	class jsdl__CPUArchitecture_USCOREType *jsdl__CPUArchitecture;	/* optional element of type jsdl:CPUArchitecture_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualCPUSpeed;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualCPUTime;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualCPUCount;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualNetworkBandwidth;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualPhysicalMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualVirtualMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualDiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalCPUTime;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalCPUCount;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalPhysicalMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalVirtualMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalDiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalResourceCount;	/* optional element of type jsdl:RangeValue_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_jsdl__Resources_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Resources_USCOREType() : jsdl__CandidateHosts(NULL), jsdl__ExclusiveExecution(NULL), jsdl__OperatingSystem(NULL), jsdl__CPUArchitecture(NULL), jsdl__IndividualCPUSpeed(NULL), jsdl__IndividualCPUTime(NULL), jsdl__IndividualCPUCount(NULL), jsdl__IndividualNetworkBandwidth(NULL), jsdl__IndividualPhysicalMemory(NULL), jsdl__IndividualVirtualMemory(NULL), jsdl__IndividualDiskSpace(NULL), jsdl__TotalCPUTime(NULL), jsdl__TotalCPUCount(NULL), jsdl__TotalPhysicalMemory(NULL), jsdl__TotalVirtualMemory(NULL), jsdl__TotalDiskSpace(NULL), jsdl__TotalResourceCount(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Resources_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__CandidateHosts_USCOREType
#define SOAP_TYPE_jsdl__CandidateHosts_USCOREType (38)
/* jsdl:CandidateHosts_Type */
class SOAP_CMAC jsdl__CandidateHosts_USCOREType
{
public:
	std::vector<std::string >jsdl__HostName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_jsdl__CandidateHosts_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__CandidateHosts_USCOREType() : soap(NULL) { }
	virtual ~jsdl__CandidateHosts_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__CPUArchitecture_USCOREType
#define SOAP_TYPE_jsdl__CPUArchitecture_USCOREType (39)
/* jsdl:CPUArchitecture_Type */
class SOAP_CMAC jsdl__CPUArchitecture_USCOREType
{
public:
	enum jsdl__ProcessorArchitectureEnumeration jsdl__CPUArchitectureName;	/* required element of type jsdl:ProcessorArchitectureEnumeration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_jsdl__CPUArchitecture_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__CPUArchitecture_USCOREType() : jsdl__CPUArchitectureName((enum jsdl__ProcessorArchitectureEnumeration)0), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__CPUArchitecture_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__FileSystem_USCOREType
#define SOAP_TYPE_jsdl__FileSystem_USCOREType (40)
/* jsdl:FileSystem_Type */
class SOAP_CMAC jsdl__FileSystem_USCOREType
{
public:
	enum jsdl__FileSystemTypeEnumeration *jsdl__FileSystemType;	/* optional element of type jsdl:FileSystemTypeEnumeration */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::string *jsdl__MountPoint;	/* optional element of type xsd:string */
	jsdl__RangeValue_USCOREType *jsdl__DiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_jsdl__FileSystem_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__FileSystem_USCOREType() : jsdl__FileSystemType(NULL), jsdl__Description(NULL), jsdl__MountPoint(NULL), jsdl__DiskSpace(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__FileSystem_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__OperatingSystem_USCOREType
#define SOAP_TYPE_jsdl__OperatingSystem_USCOREType (41)
/* jsdl:OperatingSystem_Type */
class SOAP_CMAC jsdl__OperatingSystem_USCOREType
{
public:
	class jsdl__OperatingSystemType_USCOREType *jsdl__OperatingSystemType;	/* optional element of type jsdl:OperatingSystemType_Type */
	std::string *jsdl__OperatingSystemVersion;	/* optional element of type xsd:string */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_jsdl__OperatingSystem_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__OperatingSystem_USCOREType() : jsdl__OperatingSystemType(NULL), jsdl__OperatingSystemVersion(NULL), jsdl__Description(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__OperatingSystem_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__OperatingSystemType_USCOREType
#define SOAP_TYPE_jsdl__OperatingSystemType_USCOREType (42)
/* jsdl:OperatingSystemType_Type */
class SOAP_CMAC jsdl__OperatingSystemType_USCOREType
{
public:
	enum jsdl__OperatingSystemTypeEnumeration jsdl__OperatingSystemName;	/* required element of type jsdl:OperatingSystemTypeEnumeration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_jsdl__OperatingSystemType_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__OperatingSystemType_USCOREType() : jsdl__OperatingSystemName((enum jsdl__OperatingSystemTypeEnumeration)0), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__OperatingSystemType_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__DataStaging_USCOREType
#define SOAP_TYPE_jsdl__DataStaging_USCOREType (43)
/* jsdl:DataStaging_Type */
class SOAP_CMAC jsdl__DataStaging_USCOREType
{
public:
	std::string jsdl__FileName;	/* required element of type xsd:string */
	std::string *jsdl__FilesystemName;	/* optional element of type xsd:NCName */
	enum jsdl__CreationFlagEnumeration jsdl__CreationFlag;	/* required element of type jsdl:CreationFlagEnumeration */
	bool *jsdl__DeleteOnTermination;	/* optional element of type xsd:boolean */
	class jsdl__SourceTarget_USCOREType *jsdl__Source;	/* optional element of type jsdl:SourceTarget_Type */
	jsdl__SourceTarget_USCOREType *jsdl__Target;	/* optional element of type jsdl:SourceTarget_Type */
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_jsdl__DataStaging_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__DataStaging_USCOREType() : jsdl__FilesystemName(NULL), jsdl__CreationFlag((enum jsdl__CreationFlagEnumeration)0), jsdl__DeleteOnTermination(NULL), jsdl__Source(NULL), jsdl__Target(NULL), name(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__DataStaging_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__SourceTarget_USCOREType
#define SOAP_TYPE_jsdl__SourceTarget_USCOREType (44)
/* jsdl:SourceTarget_Type */
class SOAP_CMAC jsdl__SourceTarget_USCOREType
{
public:
	std::string *jsdl__URI;	/* optional element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_jsdl__SourceTarget_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__SourceTarget_USCOREType() : jsdl__URI(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__SourceTarget_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType
#define SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType (52)
/* jsdlposix:POSIXApplication_Type */
class SOAP_CMAC jsdlposix__POSIXApplication_USCOREType
{
public:
	class jsdlposix__FileName_USCOREType *jsdlposix__Executable;	/* optional element of type jsdlposix:FileName_Type */
	std::vector<class jsdlposix__Argument_USCOREType * >jsdlposix__Argument;	/* optional element of type jsdlposix:Argument_Type */
	jsdlposix__FileName_USCOREType *jsdlposix__Input;	/* optional element of type jsdlposix:FileName_Type */
	jsdlposix__FileName_USCOREType *jsdlposix__Output;	/* optional element of type jsdlposix:FileName_Type */
	jsdlposix__FileName_USCOREType *jsdlposix__Error;	/* optional element of type jsdlposix:FileName_Type */
	class jsdlposix__DirectoryName_USCOREType *jsdlposix__WorkingDirectory;	/* optional element of type jsdlposix:DirectoryName_Type */
	std::vector<class jsdlposix__Environment_USCOREType * >jsdlposix__Environment;	/* optional element of type jsdlposix:Environment_Type */
	class jsdlposix__Limits_USCOREType *jsdlposix__WallTimeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__FileSizeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__CoreDumpLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__DataSegmentLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__LockedMemoryLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__MemoryLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__OpenDescriptorsLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__PipeSizeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__StackSizeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__CPUTimeLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__ProcessCountLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__VirtualMemoryLimit;	/* optional element of type jsdlposix:Limits_Type */
	jsdlposix__Limits_USCOREType *jsdlposix__ThreadCountLimit;	/* optional element of type jsdlposix:Limits_Type */
	class jsdlposix__UserName_USCOREType *jsdlposix__UserName;	/* optional element of type jsdlposix:UserName_Type */
	class jsdlposix__GroupName_USCOREType *jsdlposix__GroupName;	/* optional element of type jsdlposix:GroupName_Type */
	std::string *name;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__POSIXApplication_USCOREType() : jsdlposix__Executable(NULL), jsdlposix__Input(NULL), jsdlposix__Output(NULL), jsdlposix__Error(NULL), jsdlposix__WorkingDirectory(NULL), jsdlposix__WallTimeLimit(NULL), jsdlposix__FileSizeLimit(NULL), jsdlposix__CoreDumpLimit(NULL), jsdlposix__DataSegmentLimit(NULL), jsdlposix__LockedMemoryLimit(NULL), jsdlposix__MemoryLimit(NULL), jsdlposix__OpenDescriptorsLimit(NULL), jsdlposix__PipeSizeLimit(NULL), jsdlposix__StackSizeLimit(NULL), jsdlposix__CPUTimeLimit(NULL), jsdlposix__ProcessCountLimit(NULL), jsdlposix__VirtualMemoryLimit(NULL), jsdlposix__ThreadCountLimit(NULL), jsdlposix__UserName(NULL), jsdlposix__GroupName(NULL), name(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__POSIXApplication_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_myproxy__MyProxyType
#define SOAP_TYPE_myproxy__MyProxyType (53)
/* myproxy:MyProxyType */
class SOAP_CMAC myproxy__MyProxyType
{
public:
	std::string ProxyServer;	/* required element of type xsd:string */
	std::string *ProxyServerDN;	/* optional element of type xsd:string */
	int *ProxyServerPort;	/* optional element of type xsd:int */
	std::string ProxyServerUserName;	/* required element of type xsd:string */
	std::string ProxyServerPassPhrase;	/* required element of type xsd:string */
	int *ProxyServerLifetime;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_myproxy__MyProxyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         myproxy__MyProxyType() : ProxyServerDN(NULL), ProxyServerPort(NULL), ProxyServerLifetime(NULL), soap(NULL) { }
	virtual ~myproxy__MyProxyType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType
#define SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType (60)
/* gridsam2:HPCProfileApplication_Type */
class SOAP_CMAC gridsam2__HPCProfileApplication_USCOREType
{
public:
	class gridsam2__FileName_USCOREType *gridsam2__Executable;	/* required element of type gridsam2:FileName_Type */
	std::vector<class gridsam2__Argument_USCOREType * >gridsam2__Argument;	/* optional element of type gridsam2:Argument_Type */
	gridsam2__FileName_USCOREType *gridsam2__Input;	/* optional element of type gridsam2:FileName_Type */
	gridsam2__FileName_USCOREType *gridsam2__Output;	/* optional element of type gridsam2:FileName_Type */
	gridsam2__FileName_USCOREType *gridsam2__Error;	/* optional element of type gridsam2:FileName_Type */
	class gridsam2__DirectoryName_USCOREType *gridsam2__WorkingDirectory;	/* optional element of type gridsam2:DirectoryName_Type */
	std::vector<class gridsam2__Environment_USCOREType * >gridsam2__Environment;	/* optional element of type gridsam2:Environment_Type */
	class gridsam2__UserName_USCOREType *gridsam2__UserName;	/* optional element of type gridsam2:UserName_Type */
	std::string *name;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam2__HPCProfileApplication_USCOREType() : gridsam2__Executable(NULL), gridsam2__Input(NULL), gridsam2__Output(NULL), gridsam2__Error(NULL), gridsam2__WorkingDirectory(NULL), gridsam2__UserName(NULL), name(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~gridsam2__HPCProfileApplication_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Boundary_USCOREType
#define SOAP_TYPE_jsdl__Boundary_USCOREType (29)
/* Primitive jsdl:Boundary_Type schema type: */
class SOAP_CMAC jsdl__Boundary_USCOREType
{
public:
	double __item;
	bool *exclusiveBound;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_jsdl__Boundary_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Boundary_USCOREType() : __item(0), exclusiveBound(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Boundary_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdl__Exact_USCOREType
#define SOAP_TYPE_jsdl__Exact_USCOREType (30)
/* Primitive jsdl:Exact_Type schema type: */
class SOAP_CMAC jsdl__Exact_USCOREType
{
public:
	double __item;
	double *epsilon;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_jsdl__Exact_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Exact_USCOREType() : __item(0), epsilon(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Exact_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__Environment_USCOREType
#define SOAP_TYPE_jsdlposix__Environment_USCOREType (45)
/* Primitive jsdlposix:Environment_Type schema type: */
class SOAP_CMAC jsdlposix__Environment_USCOREType
{
public:
	std::string __item;
	std::string name;	/* required attribute */
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_jsdlposix__Environment_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__Environment_USCOREType() : filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__Environment_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__Argument_USCOREType
#define SOAP_TYPE_jsdlposix__Argument_USCOREType (46)
/* Primitive jsdlposix:Argument_Type schema type: */
class SOAP_CMAC jsdlposix__Argument_USCOREType
{
public:
	std::string __item;
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_jsdlposix__Argument_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__Argument_USCOREType() : filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__Argument_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__FileName_USCOREType
#define SOAP_TYPE_jsdlposix__FileName_USCOREType (47)
/* Primitive jsdlposix:FileName_Type schema type: */
class SOAP_CMAC jsdlposix__FileName_USCOREType
{
public:
	std::string __item;
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_jsdlposix__FileName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__FileName_USCOREType() : filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__FileName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__DirectoryName_USCOREType
#define SOAP_TYPE_jsdlposix__DirectoryName_USCOREType (48)
/* Primitive jsdlposix:DirectoryName_Type schema type: */
class SOAP_CMAC jsdlposix__DirectoryName_USCOREType
{
public:
	std::string __item;
	std::string *filesystemName;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_jsdlposix__DirectoryName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__DirectoryName_USCOREType() : filesystemName(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__DirectoryName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__Limits_USCOREType
#define SOAP_TYPE_jsdlposix__Limits_USCOREType (49)
/* Primitive jsdlposix:Limits_Type schema type: */
class SOAP_CMAC jsdlposix__Limits_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_jsdlposix__Limits_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__Limits_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__Limits_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__UserName_USCOREType
#define SOAP_TYPE_jsdlposix__UserName_USCOREType (50)
/* Primitive jsdlposix:UserName_Type schema type: */
class SOAP_CMAC jsdlposix__UserName_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_jsdlposix__UserName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__UserName_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__UserName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_jsdlposix__GroupName_USCOREType
#define SOAP_TYPE_jsdlposix__GroupName_USCOREType (51)
/* Primitive jsdlposix:GroupName_Type schema type: */
class SOAP_CMAC jsdlposix__GroupName_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_jsdlposix__GroupName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdlposix__GroupName_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdlposix__GroupName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_mpi__MPIApplicationType
#define SOAP_TYPE_mpi__MPIApplicationType (54)
/* mpi:MPIApplicationType */
class SOAP_CMAC mpi__MPIApplicationType : public jsdlposix__POSIXApplication_USCOREType
{
public:
	std::string mpi__ProcessorCount;	/* required element of type xsd:positiveInteger */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_mpi__MPIApplicationType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         mpi__MPIApplicationType()  { }
	virtual ~mpi__MPIApplicationType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam2__Environment_USCOREType
#define SOAP_TYPE_gridsam2__Environment_USCOREType (55)
/* Primitive gridsam2:Environment_Type schema type: */
class SOAP_CMAC gridsam2__Environment_USCOREType
{
public:
	std::string __item;
	std::string name;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_gridsam2__Environment_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam2__Environment_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~gridsam2__Environment_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam2__Argument_USCOREType
#define SOAP_TYPE_gridsam2__Argument_USCOREType (56)
/* Primitive gridsam2:Argument_Type schema type: */
class SOAP_CMAC gridsam2__Argument_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_gridsam2__Argument_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam2__Argument_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~gridsam2__Argument_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam2__FileName_USCOREType
#define SOAP_TYPE_gridsam2__FileName_USCOREType (57)
/* Primitive gridsam2:FileName_Type schema type: */
class SOAP_CMAC gridsam2__FileName_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_gridsam2__FileName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam2__FileName_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~gridsam2__FileName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam2__DirectoryName_USCOREType
#define SOAP_TYPE_gridsam2__DirectoryName_USCOREType (58)
/* Primitive gridsam2:DirectoryName_Type schema type: */
class SOAP_CMAC gridsam2__DirectoryName_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_gridsam2__DirectoryName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam2__DirectoryName_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~gridsam2__DirectoryName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_gridsam2__UserName_USCOREType
#define SOAP_TYPE_gridsam2__UserName_USCOREType (59)
/* Primitive gridsam2:UserName_Type schema type: */
class SOAP_CMAC gridsam2__UserName_USCOREType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_gridsam2__UserName_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         gridsam2__UserName_USCOREType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~gridsam2__UserName_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (128)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	std::string *gridsam__AuthorisationFault;	/* optional element of type xsd:string */
	std::string *gridsam__JobStartFault;	/* optional element of type xsd:string */
	std::string *gridsam__JobTerminationFault;	/* optional element of type xsd:string */
	_gridsam__UnknownJobFault *gridsam__UnknownJobFault;	/* optional element of type gridsam:UnknownJobFault */
	std::string *gridsam__JobMonitoringFault;	/* optional element of type xsd:string */
	std::string *gridsam__JobSubmissionFault;	/* optional element of type xsd:string */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___jobcontrol__terminateJob
#define SOAP_TYPE___jobcontrol__terminateJob (135)
/* Operation wrapper: */
struct __jobcontrol__terminateJob
{
public:
	_gridsam__terminateJob *gridsam__terminateJob;	/* optional element of type gridsam:terminateJob */
};
#endif

#ifndef SOAP_TYPE___jobcontrol__startJob
#define SOAP_TYPE___jobcontrol__startJob (139)
/* Operation wrapper: */
struct __jobcontrol__startJob
{
public:
	_gridsam__startJob *gridsam__startJob;	/* optional element of type gridsam:startJob */
};
#endif

#ifndef SOAP_TYPE___jobmonitoring__getJobStatus
#define SOAP_TYPE___jobmonitoring__getJobStatus (143)
/* Operation wrapper: */
struct __jobmonitoring__getJobStatus
{
public:
	_gridsam__getJobStatus *gridsam__getJobStatus;	/* optional element of type gridsam:getJobStatus */
};
#endif

#ifndef SOAP_TYPE___jobsubmission__submitJob
#define SOAP_TYPE___jobsubmission__submitJob (147)
/* Operation wrapper: */
struct __jobsubmission__submitJob
{
public:
	_gridsam__submitJob *gridsam__submitJob;	/* optional element of type gridsam:submitJob */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (148)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (149)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (151)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (152)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (9)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (10)
typedef std::string xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (11)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (12)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__normalizedString
#define SOAP_TYPE_xsd__normalizedString (13)
typedef std::string xsd__normalizedString;
#endif

#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (14)
typedef std::string xsd__positiveInteger;
#endif

#ifndef SOAP_TYPE_jsdl__Description_USCOREType
#define SOAP_TYPE_jsdl__Description_USCOREType (66)
typedef std::string jsdl__Description_USCOREType;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of gridsamStub.h */
