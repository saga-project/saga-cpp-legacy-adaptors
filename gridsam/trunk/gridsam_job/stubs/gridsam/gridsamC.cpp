/* gridsamC.cpp
   Generated by gSOAP 2.7.11 from ./wsdl/wsdl/gridsam.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "gridsamH.h"

SOAP_SOURCE_STAMP("@(#) gridsamC.cpp ver 2.7.11 2008-09-23 14:41:30 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_jsdl__CreationFlagEnumeration:
		return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
		return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
		return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
		return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_gridsam__StateType:
		return soap_in_gridsam__StateType(soap, NULL, NULL, "gridsam:StateType");
	case SOAP_TYPE_jsdl__Description_USCOREType:
		return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType:
		return soap_in_gridsam2__HPCProfileApplication_USCOREType(soap, NULL, NULL, "gridsam2:HPCProfileApplication_Type");
	case SOAP_TYPE_gridsam2__UserName_USCOREType:
		return soap_in_gridsam2__UserName_USCOREType(soap, NULL, NULL, "gridsam2:UserName_Type");
	case SOAP_TYPE_gridsam2__DirectoryName_USCOREType:
		return soap_in_gridsam2__DirectoryName_USCOREType(soap, NULL, NULL, "gridsam2:DirectoryName_Type");
	case SOAP_TYPE_gridsam2__FileName_USCOREType:
		return soap_in_gridsam2__FileName_USCOREType(soap, NULL, NULL, "gridsam2:FileName_Type");
	case SOAP_TYPE_gridsam2__Argument_USCOREType:
		return soap_in_gridsam2__Argument_USCOREType(soap, NULL, NULL, "gridsam2:Argument_Type");
	case SOAP_TYPE_gridsam2__Environment_USCOREType:
		return soap_in_gridsam2__Environment_USCOREType(soap, NULL, NULL, "gridsam2:Environment_Type");
	case SOAP_TYPE_mpi__MPIApplicationType:
		return soap_in_mpi__MPIApplicationType(soap, NULL, NULL, "mpi:MPIApplicationType");
	case SOAP_TYPE_myproxy__MyProxyType:
		return soap_in_myproxy__MyProxyType(soap, NULL, NULL, "myproxy:MyProxyType");
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		return soap_in_jsdlposix__POSIXApplication_USCOREType(soap, NULL, NULL, "jsdlposix:POSIXApplication_Type");
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		return soap_in_jsdlposix__GroupName_USCOREType(soap, NULL, NULL, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		return soap_in_jsdlposix__UserName_USCOREType(soap, NULL, NULL, "jsdlposix:UserName_Type");
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		return soap_in_jsdlposix__Limits_USCOREType(soap, NULL, NULL, "jsdlposix:Limits_Type");
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		return soap_in_jsdlposix__DirectoryName_USCOREType(soap, NULL, NULL, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		return soap_in_jsdlposix__FileName_USCOREType(soap, NULL, NULL, "jsdlposix:FileName_Type");
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		return soap_in_jsdlposix__Argument_USCOREType(soap, NULL, NULL, "jsdlposix:Argument_Type");
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		return soap_in_jsdlposix__Environment_USCOREType(soap, NULL, NULL, "jsdlposix:Environment_Type");
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_gridsam__JobDescriptionType:
		return soap_in_gridsam__JobDescriptionType(soap, NULL, NULL, "gridsam:JobDescriptionType");
	case SOAP_TYPE_gridsam__JobIdentifierType:
		return soap_in_gridsam__JobIdentifierType(soap, NULL, NULL, "gridsam:JobIdentifierType");
	case SOAP_TYPE_gridsam__JobStatusType:
		return soap_in_gridsam__JobStatusType(soap, NULL, NULL, "gridsam:JobStatusType");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_in_xsd__positiveInteger(soap, NULL, NULL, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__normalizedString:
		return soap_in_xsd__normalizedString(soap, NULL, NULL, "xsd:normalizedString");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__ID:
		return soap_in_xsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_gridsam__submitJobResponse:
		return soap_in_PointerTo_gridsam__submitJobResponse(soap, NULL, NULL, "gridsam:submitJobResponse");
	case SOAP_TYPE_PointerTo_gridsam__submitJob:
		return soap_in_PointerTo_gridsam__submitJob(soap, NULL, NULL, "gridsam:submitJob");
	case SOAP_TYPE_PointerTo_gridsam__getJobStatusResponse:
		return soap_in_PointerTo_gridsam__getJobStatusResponse(soap, NULL, NULL, "gridsam:getJobStatusResponse");
	case SOAP_TYPE_PointerTo_gridsam__getJobStatus:
		return soap_in_PointerTo_gridsam__getJobStatus(soap, NULL, NULL, "gridsam:getJobStatus");
	case SOAP_TYPE_PointerTo_gridsam__startJobResponse:
		return soap_in_PointerTo_gridsam__startJobResponse(soap, NULL, NULL, "gridsam:startJobResponse");
	case SOAP_TYPE_PointerTo_gridsam__startJob:
		return soap_in_PointerTo_gridsam__startJob(soap, NULL, NULL, "gridsam:startJob");
	case SOAP_TYPE_PointerTo_gridsam__terminateJobResponse:
		return soap_in_PointerTo_gridsam__terminateJobResponse(soap, NULL, NULL, "gridsam:terminateJobResponse");
	case SOAP_TYPE_PointerTo_gridsam__terminateJob:
		return soap_in_PointerTo_gridsam__terminateJob(soap, NULL, NULL, "gridsam:terminateJob");
	case SOAP_TYPE_PointerTo_gridsam__UnknownJobFault:
		return soap_in_PointerTo_gridsam__UnknownJobFault(soap, NULL, NULL, "gridsam:UnknownJobFault");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTogridsam2__UserName_USCOREType:
		return soap_in_PointerTogridsam2__UserName_USCOREType(soap, NULL, NULL, "gridsam2:UserName_Type");
	case SOAP_TYPE_PointerTogridsam2__Environment_USCOREType:
		return soap_in_PointerTogridsam2__Environment_USCOREType(soap, NULL, NULL, "gridsam2:Environment_Type");
	case SOAP_TYPE_PointerTogridsam2__DirectoryName_USCOREType:
		return soap_in_PointerTogridsam2__DirectoryName_USCOREType(soap, NULL, NULL, "gridsam2:DirectoryName_Type");
	case SOAP_TYPE_PointerTogridsam2__Argument_USCOREType:
		return soap_in_PointerTogridsam2__Argument_USCOREType(soap, NULL, NULL, "gridsam2:Argument_Type");
	case SOAP_TYPE_PointerTogridsam2__FileName_USCOREType:
		return soap_in_PointerTogridsam2__FileName_USCOREType(soap, NULL, NULL, "gridsam2:FileName_Type");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType:
		return soap_in_PointerTojsdlposix__GroupName_USCOREType(soap, NULL, NULL, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType:
		return soap_in_PointerTojsdlposix__UserName_USCOREType(soap, NULL, NULL, "jsdlposix:UserName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType:
		return soap_in_PointerTojsdlposix__Limits_USCOREType(soap, NULL, NULL, "jsdlposix:Limits_Type");
	case SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType:
		return soap_in_PointerTojsdlposix__Environment_USCOREType(soap, NULL, NULL, "jsdlposix:Environment_Type");
	case SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType:
		return soap_in_PointerTojsdlposix__DirectoryName_USCOREType(soap, NULL, NULL, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType:
		return soap_in_PointerTojsdlposix__Argument_USCOREType(soap, NULL, NULL, "jsdlposix:Argument_Type");
	case SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType:
		return soap_in_PointerTojsdlposix__FileName_USCOREType(soap, NULL, NULL, "jsdlposix:FileName_Type");
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		return soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, NULL, NULL, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_in_PointerToxsd__NCName(soap, NULL, NULL, "xsd:NCName");
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, NULL, NULL, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		return soap_in_PointerTojsdl__RangeValue_USCOREType(soap, NULL, NULL, "jsdl:RangeValue_Type");
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, NULL, NULL, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		return soap_in_PointerTojsdl__FileSystem_USCOREType(soap, NULL, NULL, "jsdl:FileSystem_Type");
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, NULL, NULL, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_PointerTojsdl__Description_USCOREType:
		return soap_in_PointerTojsdl__Description_USCOREType(soap, NULL, NULL, "jsdl:Description_Type");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		return soap_in_PointerTojsdl__DataStaging_USCOREType(soap, NULL, NULL, "jsdl:DataStaging_Type");
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		return soap_in_PointerTojsdl__Resources_USCOREType(soap, NULL, NULL, "jsdl:Resources_Type");
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		return soap_in_PointerTojsdl__Application_USCOREType(soap, NULL, NULL, "jsdl:Application_Type");
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		return soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, NULL, NULL, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_in_PointerToxsd__ID(soap, NULL, NULL, "xsd:ID");
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		return soap_in_PointerTojsdl__JobDescription_USCOREType(soap, NULL, NULL, "jsdl:JobDescription_Type");
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		return soap_in_PointerTojsdl__Range_USCOREType(soap, NULL, NULL, "jsdl:Range_Type");
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		return soap_in_PointerTojsdl__Exact_USCOREType(soap, NULL, NULL, "jsdl:Exact_Type");
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		return soap_in_PointerTojsdl__Boundary_USCOREType(soap, NULL, NULL, "jsdl:Boundary_Type");
	case SOAP_TYPE_PointerTogridsam__JobStatusType:
		return soap_in_PointerTogridsam__JobStatusType(soap, NULL, NULL, "gridsam:JobStatusType");
	case SOAP_TYPE_PointerTogridsam__JobDescriptionType:
		return soap_in_PointerTogridsam__JobDescriptionType(soap, NULL, NULL, "gridsam:JobDescriptionType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		return soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, NULL, NULL, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_PointerTo_gridsam__Property:
		return soap_in_PointerTo_gridsam__Property(soap, NULL, NULL, "gridsam:Property");
	case SOAP_TYPE_PointerTo_gridsam__Stage:
		return soap_in_PointerTo_gridsam__Stage(soap, NULL, NULL, "gridsam:Stage");
	case SOAP_TYPE_PointerTogridsam__JobIdentifierType:
		return soap_in_PointerTogridsam__JobIdentifierType(soap, NULL, NULL, "gridsam:JobIdentifierType");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "jsdl:Description_Type"))
		{	*type = SOAP_TYPE_jsdl__Description_USCOREType;
			return soap_in_jsdl__Description_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam2:HPCProfileApplication_Type"))
		{	*type = SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType;
			return soap_in_gridsam2__HPCProfileApplication_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam2:UserName_Type"))
		{	*type = SOAP_TYPE_gridsam2__UserName_USCOREType;
			return soap_in_gridsam2__UserName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam2:DirectoryName_Type"))
		{	*type = SOAP_TYPE_gridsam2__DirectoryName_USCOREType;
			return soap_in_gridsam2__DirectoryName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam2:FileName_Type"))
		{	*type = SOAP_TYPE_gridsam2__FileName_USCOREType;
			return soap_in_gridsam2__FileName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam2:Argument_Type"))
		{	*type = SOAP_TYPE_gridsam2__Argument_USCOREType;
			return soap_in_gridsam2__Argument_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam2:Environment_Type"))
		{	*type = SOAP_TYPE_gridsam2__Environment_USCOREType;
			return soap_in_gridsam2__Environment_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "mpi:MPIApplicationType"))
		{	*type = SOAP_TYPE_mpi__MPIApplicationType;
			return soap_in_mpi__MPIApplicationType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "myproxy:MyProxyType"))
		{	*type = SOAP_TYPE_myproxy__MyProxyType;
			return soap_in_myproxy__MyProxyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:POSIXApplication_Type"))
		{	*type = SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType;
			return soap_in_jsdlposix__POSIXApplication_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:GroupName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__GroupName_USCOREType;
			return soap_in_jsdlposix__GroupName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:UserName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__UserName_USCOREType;
			return soap_in_jsdlposix__UserName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:Limits_Type"))
		{	*type = SOAP_TYPE_jsdlposix__Limits_USCOREType;
			return soap_in_jsdlposix__Limits_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:DirectoryName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__DirectoryName_USCOREType;
			return soap_in_jsdlposix__DirectoryName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:FileName_Type"))
		{	*type = SOAP_TYPE_jsdlposix__FileName_USCOREType;
			return soap_in_jsdlposix__FileName_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:Argument_Type"))
		{	*type = SOAP_TYPE_jsdlposix__Argument_USCOREType;
			return soap_in_jsdlposix__Argument_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdlposix:Environment_Type"))
		{	*type = SOAP_TYPE_jsdlposix__Environment_USCOREType;
			return soap_in_jsdlposix__Environment_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:SourceTarget_Type"))
		{	*type = SOAP_TYPE_jsdl__SourceTarget_USCOREType;
			return soap_in_jsdl__SourceTarget_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:DataStaging_Type"))
		{	*type = SOAP_TYPE_jsdl__DataStaging_USCOREType;
			return soap_in_jsdl__DataStaging_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemType_Type"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystemType_USCOREType;
			return soap_in_jsdl__OperatingSystemType_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystem_Type"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystem_USCOREType;
			return soap_in_jsdl__OperatingSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystem_Type"))
		{	*type = SOAP_TYPE_jsdl__FileSystem_USCOREType;
			return soap_in_jsdl__FileSystem_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CPUArchitecture_Type"))
		{	*type = SOAP_TYPE_jsdl__CPUArchitecture_USCOREType;
			return soap_in_jsdl__CPUArchitecture_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CandidateHosts_Type"))
		{	*type = SOAP_TYPE_jsdl__CandidateHosts_USCOREType;
			return soap_in_jsdl__CandidateHosts_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Resources_Type"))
		{	*type = SOAP_TYPE_jsdl__Resources_USCOREType;
			return soap_in_jsdl__Resources_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Application_Type"))
		{	*type = SOAP_TYPE_jsdl__Application_USCOREType;
			return soap_in_jsdl__Application_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobIdentification_Type"))
		{	*type = SOAP_TYPE_jsdl__JobIdentification_USCOREType;
			return soap_in_jsdl__JobIdentification_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDescription_Type"))
		{	*type = SOAP_TYPE_jsdl__JobDescription_USCOREType;
			return soap_in_jsdl__JobDescription_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:JobDefinition_Type"))
		{	*type = SOAP_TYPE_jsdl__JobDefinition_USCOREType;
			return soap_in_jsdl__JobDefinition_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:RangeValue_Type"))
		{	*type = SOAP_TYPE_jsdl__RangeValue_USCOREType;
			return soap_in_jsdl__RangeValue_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Range_Type"))
		{	*type = SOAP_TYPE_jsdl__Range_USCOREType;
			return soap_in_jsdl__Range_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Exact_Type"))
		{	*type = SOAP_TYPE_jsdl__Exact_USCOREType;
			return soap_in_jsdl__Exact_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:Boundary_Type"))
		{	*type = SOAP_TYPE_jsdl__Boundary_USCOREType;
			return soap_in_jsdl__Boundary_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:JobDescriptionType"))
		{	*type = SOAP_TYPE_gridsam__JobDescriptionType;
			return soap_in_gridsam__JobDescriptionType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:JobIdentifierType"))
		{	*type = SOAP_TYPE_gridsam__JobIdentifierType;
			return soap_in_gridsam__JobIdentifierType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:JobStatusType"))
		{	*type = SOAP_TYPE_gridsam__JobStatusType;
			return soap_in_gridsam__JobStatusType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:positiveInteger"))
		{	*type = SOAP_TYPE_xsd__positiveInteger;
			return soap_in_xsd__positiveInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:normalizedString"))
		{	*type = SOAP_TYPE_xsd__normalizedString;
			return soap_in_xsd__normalizedString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:ID"))
		{	*type = SOAP_TYPE_xsd__ID;
			return soap_in_xsd__ID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:CreationFlagEnumeration"))
		{	*type = SOAP_TYPE_jsdl__CreationFlagEnumeration;
			return soap_in_jsdl__CreationFlagEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:FileSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_jsdl__FileSystemTypeEnumeration;
			return soap_in_jsdl__FileSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:OperatingSystemTypeEnumeration"))
		{	*type = SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration;
			return soap_in_jsdl__OperatingSystemTypeEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "jsdl:ProcessorArchitectureEnumeration"))
		{	*type = SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration;
			return soap_in_jsdl__ProcessorArchitectureEnumeration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:StateType"))
		{	*type = SOAP_TYPE_gridsam__StateType;
			return soap_in_gridsam__StateType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "gridsam:UnknownJobFault"))
		{	*type = SOAP_TYPE__gridsam__UnknownJobFault;
			return soap_in__gridsam__UnknownJobFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:startJobResponse"))
		{	*type = SOAP_TYPE__gridsam__startJobResponse;
			return soap_in__gridsam__startJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:startJob"))
		{	*type = SOAP_TYPE__gridsam__startJob;
			return soap_in__gridsam__startJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:terminateJobResponse"))
		{	*type = SOAP_TYPE__gridsam__terminateJobResponse;
			return soap_in__gridsam__terminateJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:terminateJob"))
		{	*type = SOAP_TYPE__gridsam__terminateJob;
			return soap_in__gridsam__terminateJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:getJobStatusResponse"))
		{	*type = SOAP_TYPE__gridsam__getJobStatusResponse;
			return soap_in__gridsam__getJobStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:getJobStatus"))
		{	*type = SOAP_TYPE__gridsam__getJobStatus;
			return soap_in__gridsam__getJobStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:submitJobResponse"))
		{	*type = SOAP_TYPE__gridsam__submitJobResponse;
			return soap_in__gridsam__submitJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:submitJob"))
		{	*type = SOAP_TYPE__gridsam__submitJob;
			return soap_in__gridsam__submitJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:Stage"))
		{	*type = SOAP_TYPE__gridsam__Stage;
			return soap_in__gridsam__Stage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "gridsam:Property"))
		{	*type = SOAP_TYPE__gridsam__Property;
			return soap_in__gridsam__Property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_jsdl__CreationFlagEnumeration:
		return soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, (const enum jsdl__CreationFlagEnumeration *)ptr, "jsdl:CreationFlagEnumeration");
	case SOAP_TYPE_jsdl__FileSystemTypeEnumeration:
		return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, (const enum jsdl__FileSystemTypeEnumeration *)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration:
		return soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, (const enum jsdl__OperatingSystemTypeEnumeration *)ptr, "jsdl:OperatingSystemTypeEnumeration");
	case SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration:
		return soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, (const enum jsdl__ProcessorArchitectureEnumeration *)ptr, "jsdl:ProcessorArchitectureEnumeration");
	case SOAP_TYPE_gridsam__StateType:
		return soap_out_gridsam__StateType(soap, tag, id, (const enum gridsam__StateType *)ptr, "gridsam:StateType");
	case SOAP_TYPE_jsdl__Description_USCOREType:
		return soap_out_jsdl__Description_USCOREType(soap, tag, id, (const std::string *)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType:
		return ((gridsam2__HPCProfileApplication_USCOREType *)ptr)->soap_out(soap, tag, id, "gridsam2:HPCProfileApplication_Type");
	case SOAP_TYPE_gridsam2__UserName_USCOREType:
		return ((gridsam2__UserName_USCOREType *)ptr)->soap_out(soap, tag, id, "gridsam2:UserName_Type");
	case SOAP_TYPE_gridsam2__DirectoryName_USCOREType:
		return ((gridsam2__DirectoryName_USCOREType *)ptr)->soap_out(soap, tag, id, "gridsam2:DirectoryName_Type");
	case SOAP_TYPE_gridsam2__FileName_USCOREType:
		return ((gridsam2__FileName_USCOREType *)ptr)->soap_out(soap, tag, id, "gridsam2:FileName_Type");
	case SOAP_TYPE_gridsam2__Argument_USCOREType:
		return ((gridsam2__Argument_USCOREType *)ptr)->soap_out(soap, tag, id, "gridsam2:Argument_Type");
	case SOAP_TYPE_gridsam2__Environment_USCOREType:
		return ((gridsam2__Environment_USCOREType *)ptr)->soap_out(soap, tag, id, "gridsam2:Environment_Type");
	case SOAP_TYPE_mpi__MPIApplicationType:
		return ((mpi__MPIApplicationType *)ptr)->soap_out(soap, tag, id, "mpi:MPIApplicationType");
	case SOAP_TYPE_myproxy__MyProxyType:
		return ((myproxy__MyProxyType *)ptr)->soap_out(soap, tag, id, "myproxy:MyProxyType");
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		return ((jsdlposix__POSIXApplication_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:POSIXApplication_Type");
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		return ((jsdlposix__GroupName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		return ((jsdlposix__UserName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:UserName_Type");
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		return ((jsdlposix__Limits_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:Limits_Type");
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		return ((jsdlposix__DirectoryName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		return ((jsdlposix__FileName_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:FileName_Type");
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		return ((jsdlposix__Argument_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:Argument_Type");
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		return ((jsdlposix__Environment_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdlposix:Environment_Type");
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return ((jsdl__SourceTarget_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return ((jsdl__DataStaging_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:DataStaging_Type");
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return ((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return ((jsdl__OperatingSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return ((jsdl__FileSystem_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:FileSystem_Type");
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return ((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return ((jsdl__CandidateHosts_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return ((jsdl__Resources_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Resources_Type");
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return ((jsdl__Application_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Application_Type");
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return ((jsdl__JobIdentification_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return ((jsdl__JobDescription_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDescription_Type");
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return ((jsdl__JobDefinition_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return ((jsdl__RangeValue_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:RangeValue_Type");
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return ((jsdl__Range_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Range_Type");
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return ((jsdl__Exact_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Exact_Type");
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return ((jsdl__Boundary_USCOREType *)ptr)->soap_out(soap, tag, id, "jsdl:Boundary_Type");
	case SOAP_TYPE__gridsam__UnknownJobFault:
		return ((_gridsam__UnknownJobFault *)ptr)->soap_out(soap, "gridsam:UnknownJobFault", id, NULL);
	case SOAP_TYPE__gridsam__startJobResponse:
		return ((_gridsam__startJobResponse *)ptr)->soap_out(soap, "gridsam:startJobResponse", id, NULL);
	case SOAP_TYPE__gridsam__startJob:
		return ((_gridsam__startJob *)ptr)->soap_out(soap, "gridsam:startJob", id, NULL);
	case SOAP_TYPE__gridsam__terminateJobResponse:
		return ((_gridsam__terminateJobResponse *)ptr)->soap_out(soap, "gridsam:terminateJobResponse", id, NULL);
	case SOAP_TYPE__gridsam__terminateJob:
		return ((_gridsam__terminateJob *)ptr)->soap_out(soap, "gridsam:terminateJob", id, NULL);
	case SOAP_TYPE__gridsam__getJobStatusResponse:
		return ((_gridsam__getJobStatusResponse *)ptr)->soap_out(soap, "gridsam:getJobStatusResponse", id, NULL);
	case SOAP_TYPE__gridsam__getJobStatus:
		return ((_gridsam__getJobStatus *)ptr)->soap_out(soap, "gridsam:getJobStatus", id, NULL);
	case SOAP_TYPE__gridsam__submitJobResponse:
		return ((_gridsam__submitJobResponse *)ptr)->soap_out(soap, "gridsam:submitJobResponse", id, NULL);
	case SOAP_TYPE__gridsam__submitJob:
		return ((_gridsam__submitJob *)ptr)->soap_out(soap, "gridsam:submitJob", id, NULL);
	case SOAP_TYPE__gridsam__Stage:
		return ((_gridsam__Stage *)ptr)->soap_out(soap, "gridsam:Stage", id, NULL);
	case SOAP_TYPE__gridsam__Property:
		return ((_gridsam__Property *)ptr)->soap_out(soap, "gridsam:Property", id, NULL);
	case SOAP_TYPE_gridsam__JobDescriptionType:
		return ((gridsam__JobDescriptionType *)ptr)->soap_out(soap, tag, id, "gridsam:JobDescriptionType");
	case SOAP_TYPE_gridsam__JobIdentifierType:
		return ((gridsam__JobIdentifierType *)ptr)->soap_out(soap, tag, id, "gridsam:JobIdentifierType");
	case SOAP_TYPE_gridsam__JobStatusType:
		return ((gridsam__JobStatusType *)ptr)->soap_out(soap, tag, id, "gridsam:JobStatusType");
	case SOAP_TYPE_xsd__positiveInteger:
		return soap_out_xsd__positiveInteger(soap, tag, id, (const std::string *)ptr, "xsd:positiveInteger");
	case SOAP_TYPE_xsd__normalizedString:
		return soap_out_xsd__normalizedString(soap, tag, id, (const std::string *)ptr, "xsd:normalizedString");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__ID:
		return soap_out_xsd__ID(soap, tag, id, (const std::string *)ptr, "xsd:ID");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_gridsam__submitJobResponse:
		return soap_out_PointerTo_gridsam__submitJobResponse(soap, tag, id, (_gridsam__submitJobResponse *const*)ptr, "gridsam:submitJobResponse");
	case SOAP_TYPE_PointerTo_gridsam__submitJob:
		return soap_out_PointerTo_gridsam__submitJob(soap, tag, id, (_gridsam__submitJob *const*)ptr, "gridsam:submitJob");
	case SOAP_TYPE_PointerTo_gridsam__getJobStatusResponse:
		return soap_out_PointerTo_gridsam__getJobStatusResponse(soap, tag, id, (_gridsam__getJobStatusResponse *const*)ptr, "gridsam:getJobStatusResponse");
	case SOAP_TYPE_PointerTo_gridsam__getJobStatus:
		return soap_out_PointerTo_gridsam__getJobStatus(soap, tag, id, (_gridsam__getJobStatus *const*)ptr, "gridsam:getJobStatus");
	case SOAP_TYPE_PointerTo_gridsam__startJobResponse:
		return soap_out_PointerTo_gridsam__startJobResponse(soap, tag, id, (_gridsam__startJobResponse *const*)ptr, "gridsam:startJobResponse");
	case SOAP_TYPE_PointerTo_gridsam__startJob:
		return soap_out_PointerTo_gridsam__startJob(soap, tag, id, (_gridsam__startJob *const*)ptr, "gridsam:startJob");
	case SOAP_TYPE_PointerTo_gridsam__terminateJobResponse:
		return soap_out_PointerTo_gridsam__terminateJobResponse(soap, tag, id, (_gridsam__terminateJobResponse *const*)ptr, "gridsam:terminateJobResponse");
	case SOAP_TYPE_PointerTo_gridsam__terminateJob:
		return soap_out_PointerTo_gridsam__terminateJob(soap, tag, id, (_gridsam__terminateJob *const*)ptr, "gridsam:terminateJob");
	case SOAP_TYPE_PointerTo_gridsam__UnknownJobFault:
		return soap_out_PointerTo_gridsam__UnknownJobFault(soap, tag, id, (_gridsam__UnknownJobFault *const*)ptr, "gridsam:UnknownJobFault");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTogridsam2__UserName_USCOREType:
		return soap_out_PointerTogridsam2__UserName_USCOREType(soap, tag, id, (gridsam2__UserName_USCOREType *const*)ptr, "gridsam2:UserName_Type");
	case SOAP_TYPE_PointerTogridsam2__Environment_USCOREType:
		return soap_out_PointerTogridsam2__Environment_USCOREType(soap, tag, id, (gridsam2__Environment_USCOREType *const*)ptr, "gridsam2:Environment_Type");
	case SOAP_TYPE_PointerTogridsam2__DirectoryName_USCOREType:
		return soap_out_PointerTogridsam2__DirectoryName_USCOREType(soap, tag, id, (gridsam2__DirectoryName_USCOREType *const*)ptr, "gridsam2:DirectoryName_Type");
	case SOAP_TYPE_PointerTogridsam2__Argument_USCOREType:
		return soap_out_PointerTogridsam2__Argument_USCOREType(soap, tag, id, (gridsam2__Argument_USCOREType *const*)ptr, "gridsam2:Argument_Type");
	case SOAP_TYPE_PointerTogridsam2__FileName_USCOREType:
		return soap_out_PointerTogridsam2__FileName_USCOREType(soap, tag, id, (gridsam2__FileName_USCOREType *const*)ptr, "gridsam2:FileName_Type");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType:
		return soap_out_PointerTojsdlposix__GroupName_USCOREType(soap, tag, id, (jsdlposix__GroupName_USCOREType *const*)ptr, "jsdlposix:GroupName_Type");
	case SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType:
		return soap_out_PointerTojsdlposix__UserName_USCOREType(soap, tag, id, (jsdlposix__UserName_USCOREType *const*)ptr, "jsdlposix:UserName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType:
		return soap_out_PointerTojsdlposix__Limits_USCOREType(soap, tag, id, (jsdlposix__Limits_USCOREType *const*)ptr, "jsdlposix:Limits_Type");
	case SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType:
		return soap_out_PointerTojsdlposix__Environment_USCOREType(soap, tag, id, (jsdlposix__Environment_USCOREType *const*)ptr, "jsdlposix:Environment_Type");
	case SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType:
		return soap_out_PointerTojsdlposix__DirectoryName_USCOREType(soap, tag, id, (jsdlposix__DirectoryName_USCOREType *const*)ptr, "jsdlposix:DirectoryName_Type");
	case SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType:
		return soap_out_PointerTojsdlposix__Argument_USCOREType(soap, tag, id, (jsdlposix__Argument_USCOREType *const*)ptr, "jsdlposix:Argument_Type");
	case SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType:
		return soap_out_PointerTojsdlposix__FileName_USCOREType(soap, tag, id, (jsdlposix__FileName_USCOREType *const*)ptr, "jsdlposix:FileName_Type");
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		return soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, (jsdl__SourceTarget_USCOREType *const*)ptr, "jsdl:SourceTarget_Type");
	case SOAP_TYPE_PointerToxsd__NCName:
		return soap_out_PointerToxsd__NCName(soap, tag, id, (std::string *const*)ptr, "xsd:NCName");
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, (jsdl__OperatingSystemType_USCOREType *const*)ptr, "jsdl:OperatingSystemType_Type");
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		return soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, (enum jsdl__FileSystemTypeEnumeration *const*)ptr, "jsdl:FileSystemTypeEnumeration");
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		return soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, (jsdl__RangeValue_USCOREType *const*)ptr, "jsdl:RangeValue_Type");
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		return soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, (jsdl__CPUArchitecture_USCOREType *const*)ptr, "jsdl:CPUArchitecture_Type");
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		return soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, (jsdl__OperatingSystem_USCOREType *const*)ptr, "jsdl:OperatingSystem_Type");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		return soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, (jsdl__FileSystem_USCOREType *const*)ptr, "jsdl:FileSystem_Type");
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		return soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, (jsdl__CandidateHosts_USCOREType *const*)ptr, "jsdl:CandidateHosts_Type");
	case SOAP_TYPE_PointerTojsdl__Description_USCOREType:
		return soap_out_PointerTojsdl__Description_USCOREType(soap, tag, id, (std::string *const*)ptr, "jsdl:Description_Type");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		return soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, (jsdl__DataStaging_USCOREType *const*)ptr, "jsdl:DataStaging_Type");
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		return soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, (jsdl__Resources_USCOREType *const*)ptr, "jsdl:Resources_Type");
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		return soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, (jsdl__Application_USCOREType *const*)ptr, "jsdl:Application_Type");
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		return soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, (jsdl__JobIdentification_USCOREType *const*)ptr, "jsdl:JobIdentification_Type");
	case SOAP_TYPE_PointerToxsd__ID:
		return soap_out_PointerToxsd__ID(soap, tag, id, (std::string *const*)ptr, "xsd:ID");
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		return soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, (jsdl__JobDescription_USCOREType *const*)ptr, "jsdl:JobDescription_Type");
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		return soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, (jsdl__Range_USCOREType *const*)ptr, "jsdl:Range_Type");
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		return soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, (jsdl__Exact_USCOREType *const*)ptr, "jsdl:Exact_Type");
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		return soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, (jsdl__Boundary_USCOREType *const*)ptr, "jsdl:Boundary_Type");
	case SOAP_TYPE_PointerTogridsam__JobStatusType:
		return soap_out_PointerTogridsam__JobStatusType(soap, tag, id, (gridsam__JobStatusType *const*)ptr, "gridsam:JobStatusType");
	case SOAP_TYPE_PointerTogridsam__JobDescriptionType:
		return soap_out_PointerTogridsam__JobDescriptionType(soap, tag, id, (gridsam__JobDescriptionType *const*)ptr, "gridsam:JobDescriptionType");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		return soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, (jsdl__JobDefinition_USCOREType *const*)ptr, "jsdl:JobDefinition_Type");
	case SOAP_TYPE_PointerTo_gridsam__Property:
		return soap_out_PointerTo_gridsam__Property(soap, tag, id, (_gridsam__Property *const*)ptr, "gridsam:Property");
	case SOAP_TYPE_PointerTo_gridsam__Stage:
		return soap_out_PointerTo_gridsam__Stage(soap, tag, id, (_gridsam__Stage *const*)ptr, "gridsam:Stage");
	case SOAP_TYPE_PointerTogridsam__JobIdentifierType:
		return soap_out_PointerTogridsam__JobIdentifierType(soap, tag, id, (gridsam__JobIdentifierType *const*)ptr, "gridsam:JobIdentifierType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_jsdl__Description_USCOREType:
		soap_serialize_jsdl__Description_USCOREType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType:
		((gridsam2__HPCProfileApplication_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam2__UserName_USCOREType:
		((gridsam2__UserName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam2__DirectoryName_USCOREType:
		((gridsam2__DirectoryName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam2__FileName_USCOREType:
		((gridsam2__FileName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam2__Argument_USCOREType:
		((gridsam2__Argument_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam2__Environment_USCOREType:
		((gridsam2__Environment_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_mpi__MPIApplicationType:
		((mpi__MPIApplicationType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_myproxy__MyProxyType:
		((myproxy__MyProxyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		((jsdlposix__POSIXApplication_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		((jsdlposix__GroupName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		((jsdlposix__UserName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		((jsdlposix__Limits_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		((jsdlposix__DirectoryName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		((jsdlposix__FileName_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		((jsdlposix__Argument_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		((jsdlposix__Environment_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		((jsdl__SourceTarget_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		((jsdl__DataStaging_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		((jsdl__OperatingSystemType_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		((jsdl__OperatingSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		((jsdl__FileSystem_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		((jsdl__CPUArchitecture_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		((jsdl__CandidateHosts_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		((jsdl__Resources_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Application_USCOREType:
		((jsdl__Application_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		((jsdl__JobIdentification_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		((jsdl__JobDescription_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		((jsdl__JobDefinition_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		((jsdl__RangeValue_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Range_USCOREType:
		((jsdl__Range_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		((jsdl__Exact_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		((jsdl__Boundary_USCOREType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__UnknownJobFault:
		((_gridsam__UnknownJobFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__startJobResponse:
		((_gridsam__startJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__startJob:
		((_gridsam__startJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__terminateJobResponse:
		((_gridsam__terminateJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__terminateJob:
		((_gridsam__terminateJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__getJobStatusResponse:
		((_gridsam__getJobStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__getJobStatus:
		((_gridsam__getJobStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__submitJobResponse:
		((_gridsam__submitJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__submitJob:
		((_gridsam__submitJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__Stage:
		((_gridsam__Stage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__gridsam__Property:
		((_gridsam__Property *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam__JobDescriptionType:
		((gridsam__JobDescriptionType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam__JobIdentifierType:
		((gridsam__JobIdentifierType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_gridsam__JobStatusType:
		((gridsam__JobStatusType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		soap_serialize_xsd__positiveInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__normalizedString:
		soap_serialize_xsd__normalizedString(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__ID:
		soap_serialize_xsd__ID(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___jobsubmission__submitJob:
		soap_serialize___jobsubmission__submitJob(soap, (const struct __jobsubmission__submitJob *)ptr);
		break;
	case SOAP_TYPE___jobmonitoring__getJobStatus:
		soap_serialize___jobmonitoring__getJobStatus(soap, (const struct __jobmonitoring__getJobStatus *)ptr);
		break;
	case SOAP_TYPE___jobcontrol__startJob:
		soap_serialize___jobcontrol__startJob(soap, (const struct __jobcontrol__startJob *)ptr);
		break;
	case SOAP_TYPE___jobcontrol__terminateJob:
		soap_serialize___jobcontrol__terminateJob(soap, (const struct __jobcontrol__terminateJob *)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__submitJobResponse:
		soap_serialize_PointerTo_gridsam__submitJobResponse(soap, (_gridsam__submitJobResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__submitJob:
		soap_serialize_PointerTo_gridsam__submitJob(soap, (_gridsam__submitJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__getJobStatusResponse:
		soap_serialize_PointerTo_gridsam__getJobStatusResponse(soap, (_gridsam__getJobStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__getJobStatus:
		soap_serialize_PointerTo_gridsam__getJobStatus(soap, (_gridsam__getJobStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__startJobResponse:
		soap_serialize_PointerTo_gridsam__startJobResponse(soap, (_gridsam__startJobResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__startJob:
		soap_serialize_PointerTo_gridsam__startJob(soap, (_gridsam__startJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__terminateJobResponse:
		soap_serialize_PointerTo_gridsam__terminateJobResponse(soap, (_gridsam__terminateJobResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__terminateJob:
		soap_serialize_PointerTo_gridsam__terminateJob(soap, (_gridsam__terminateJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__UnknownJobFault:
		soap_serialize_PointerTo_gridsam__UnknownJobFault(soap, (_gridsam__UnknownJobFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam2__UserName_USCOREType:
		soap_serialize_PointerTogridsam2__UserName_USCOREType(soap, (gridsam2__UserName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam2__Environment_USCOREType:
		soap_serialize_PointerTogridsam2__Environment_USCOREType(soap, (gridsam2__Environment_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam2__DirectoryName_USCOREType:
		soap_serialize_PointerTogridsam2__DirectoryName_USCOREType(soap, (gridsam2__DirectoryName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam2__Argument_USCOREType:
		soap_serialize_PointerTogridsam2__Argument_USCOREType(soap, (gridsam2__Argument_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam2__FileName_USCOREType:
		soap_serialize_PointerTogridsam2__FileName_USCOREType(soap, (gridsam2__FileName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType:
		soap_serialize_PointerTojsdlposix__GroupName_USCOREType(soap, (jsdlposix__GroupName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType:
		soap_serialize_PointerTojsdlposix__UserName_USCOREType(soap, (jsdlposix__UserName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType:
		soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, (jsdlposix__Limits_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType:
		soap_serialize_PointerTojsdlposix__Environment_USCOREType(soap, (jsdlposix__Environment_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType:
		soap_serialize_PointerTojsdlposix__DirectoryName_USCOREType(soap, (jsdlposix__DirectoryName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType:
		soap_serialize_PointerTojsdlposix__Argument_USCOREType(soap, (jsdlposix__Argument_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType:
		soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, (jsdlposix__FileName_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType:
		soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, (jsdl__SourceTarget_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__NCName:
		soap_serialize_PointerToxsd__NCName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, (jsdl__OperatingSystemType_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration:
		soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, (enum jsdl__FileSystemTypeEnumeration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType:
		soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, (jsdl__RangeValue_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType:
		soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, (jsdl__CPUArchitecture_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType:
		soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, (jsdl__OperatingSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType:
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, (jsdl__FileSystem_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType:
		soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, (jsdl__CandidateHosts_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Description_USCOREType:
		soap_serialize_PointerTojsdl__Description_USCOREType(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType:
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, (jsdl__DataStaging_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Resources_USCOREType:
		soap_serialize_PointerTojsdl__Resources_USCOREType(soap, (jsdl__Resources_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Application_USCOREType:
		soap_serialize_PointerTojsdl__Application_USCOREType(soap, (jsdl__Application_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType:
		soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, (jsdl__JobIdentification_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__ID:
		soap_serialize_PointerToxsd__ID(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType:
		soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, (jsdl__JobDescription_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Range_USCOREType:
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, (jsdl__Range_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Exact_USCOREType:
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, (jsdl__Exact_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__Boundary_USCOREType:
		soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, (jsdl__Boundary_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam__JobStatusType:
		soap_serialize_PointerTogridsam__JobStatusType(soap, (gridsam__JobStatusType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam__JobDescriptionType:
		soap_serialize_PointerTogridsam__JobDescriptionType(soap, (gridsam__JobDescriptionType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType:
		soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, (jsdl__JobDefinition_USCOREType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__Property:
		soap_serialize_PointerTo_gridsam__Property(soap, (_gridsam__Property *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_gridsam__Stage:
		soap_serialize_PointerTo_gridsam__Stage(soap, (_gridsam__Stage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogridsam__JobIdentifierType:
		soap_serialize_PointerTogridsam__JobIdentifierType(soap, (gridsam__JobIdentifierType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam__JobStatusType:
		return (void*)soap_instantiate_gridsam__JobStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam__JobIdentifierType:
		return (void*)soap_instantiate_gridsam__JobIdentifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam__JobDescriptionType:
		return (void*)soap_instantiate_gridsam__JobDescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__Property:
		return (void*)soap_instantiate__gridsam__Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__Stage:
		return (void*)soap_instantiate__gridsam__Stage(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__submitJob:
		return (void*)soap_instantiate__gridsam__submitJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__submitJobResponse:
		return (void*)soap_instantiate__gridsam__submitJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__getJobStatus:
		return (void*)soap_instantiate__gridsam__getJobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__getJobStatusResponse:
		return (void*)soap_instantiate__gridsam__getJobStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__terminateJob:
		return (void*)soap_instantiate__gridsam__terminateJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__terminateJobResponse:
		return (void*)soap_instantiate__gridsam__terminateJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__startJob:
		return (void*)soap_instantiate__gridsam__startJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__startJobResponse:
		return (void*)soap_instantiate__gridsam__startJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__gridsam__UnknownJobFault:
		return (void*)soap_instantiate__gridsam__UnknownJobFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Range_USCOREType:
		return (void*)soap_instantiate_jsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		return (void*)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		return (void*)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		return (void*)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Application_USCOREType:
		return (void*)soap_instantiate_jsdl__Application_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		return (void*)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		return (void*)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		return (void*)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		return (void*)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		return (void*)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		return (void*)soap_instantiate_jsdlposix__POSIXApplication_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_myproxy__MyProxyType:
		return (void*)soap_instantiate_myproxy__MyProxyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType:
		return (void*)soap_instantiate_gridsam2__HPCProfileApplication_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		return (void*)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		return (void*)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		return (void*)soap_instantiate_jsdlposix__Environment_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		return (void*)soap_instantiate_jsdlposix__Argument_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__FileName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__DirectoryName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		return (void*)soap_instantiate_jsdlposix__Limits_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__UserName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		return (void*)soap_instantiate_jsdlposix__GroupName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_mpi__MPIApplicationType:
		return (void*)soap_instantiate_mpi__MPIApplicationType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam2__Environment_USCOREType:
		return (void*)soap_instantiate_gridsam2__Environment_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam2__Argument_USCOREType:
		return (void*)soap_instantiate_gridsam2__Argument_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam2__FileName_USCOREType:
		return (void*)soap_instantiate_gridsam2__FileName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam2__DirectoryName_USCOREType:
		return (void*)soap_instantiate_gridsam2__DirectoryName_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_gridsam2__UserName_USCOREType:
		return (void*)soap_instantiate_gridsam2__UserName_USCOREType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___jobcontrol__terminateJob:
		return (void*)soap_instantiate___jobcontrol__terminateJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___jobcontrol__startJob:
		return (void*)soap_instantiate___jobcontrol__startJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___jobmonitoring__getJobStatus:
		return (void*)soap_instantiate___jobmonitoring__getJobStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___jobsubmission__submitJob:
		return (void*)soap_instantiate___jobsubmission__submitJob(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__ID:
		return (void*)soap_instantiate_xsd__ID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__normalizedString:
		return (void*)soap_instantiate_xsd__normalizedString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__positiveInteger:
		return (void*)soap_instantiate_xsd__positiveInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_jsdl__Description_USCOREType:
		return (void*)soap_instantiate_jsdl__Description_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobStatusType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobIdentifierType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobDescriptionType:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Property:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Stage:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Stage(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_gridsam__JobStatusType:
		if (p->size < 0)
			delete (gridsam__JobStatusType*)p->ptr;
		else
			delete[] (gridsam__JobStatusType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam__JobIdentifierType:
		if (p->size < 0)
			delete (gridsam__JobIdentifierType*)p->ptr;
		else
			delete[] (gridsam__JobIdentifierType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam__JobDescriptionType:
		if (p->size < 0)
			delete (gridsam__JobDescriptionType*)p->ptr;
		else
			delete[] (gridsam__JobDescriptionType*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__Property:
		if (p->size < 0)
			delete (_gridsam__Property*)p->ptr;
		else
			delete[] (_gridsam__Property*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__Stage:
		if (p->size < 0)
			delete (_gridsam__Stage*)p->ptr;
		else
			delete[] (_gridsam__Stage*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__submitJob:
		if (p->size < 0)
			delete (_gridsam__submitJob*)p->ptr;
		else
			delete[] (_gridsam__submitJob*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__submitJobResponse:
		if (p->size < 0)
			delete (_gridsam__submitJobResponse*)p->ptr;
		else
			delete[] (_gridsam__submitJobResponse*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__getJobStatus:
		if (p->size < 0)
			delete (_gridsam__getJobStatus*)p->ptr;
		else
			delete[] (_gridsam__getJobStatus*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__getJobStatusResponse:
		if (p->size < 0)
			delete (_gridsam__getJobStatusResponse*)p->ptr;
		else
			delete[] (_gridsam__getJobStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__terminateJob:
		if (p->size < 0)
			delete (_gridsam__terminateJob*)p->ptr;
		else
			delete[] (_gridsam__terminateJob*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__terminateJobResponse:
		if (p->size < 0)
			delete (_gridsam__terminateJobResponse*)p->ptr;
		else
			delete[] (_gridsam__terminateJobResponse*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__startJob:
		if (p->size < 0)
			delete (_gridsam__startJob*)p->ptr;
		else
			delete[] (_gridsam__startJob*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__startJobResponse:
		if (p->size < 0)
			delete (_gridsam__startJobResponse*)p->ptr;
		else
			delete[] (_gridsam__startJobResponse*)p->ptr;
		break;
	case SOAP_TYPE__gridsam__UnknownJobFault:
		if (p->size < 0)
			delete (_gridsam__UnknownJobFault*)p->ptr;
		else
			delete[] (_gridsam__UnknownJobFault*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__Range_USCOREType:
		if (p->size < 0)
			delete (jsdl__Range_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Range_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__RangeValue_USCOREType:
		if (p->size < 0)
			delete (jsdl__RangeValue_USCOREType*)p->ptr;
		else
			delete[] (jsdl__RangeValue_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__JobDefinition_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobDefinition_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobDefinition_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__JobDescription_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobDescription_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobDescription_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__JobIdentification_USCOREType:
		if (p->size < 0)
			delete (jsdl__JobIdentification_USCOREType*)p->ptr;
		else
			delete[] (jsdl__JobIdentification_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__Application_USCOREType:
		if (p->size < 0)
			delete (jsdl__Application_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Application_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__Resources_USCOREType:
		if (p->size < 0)
			delete (jsdl__Resources_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Resources_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__CandidateHosts_USCOREType:
		if (p->size < 0)
			delete (jsdl__CandidateHosts_USCOREType*)p->ptr;
		else
			delete[] (jsdl__CandidateHosts_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__CPUArchitecture_USCOREType:
		if (p->size < 0)
			delete (jsdl__CPUArchitecture_USCOREType*)p->ptr;
		else
			delete[] (jsdl__CPUArchitecture_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__FileSystem_USCOREType:
		if (p->size < 0)
			delete (jsdl__FileSystem_USCOREType*)p->ptr;
		else
			delete[] (jsdl__FileSystem_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__OperatingSystem_USCOREType:
		if (p->size < 0)
			delete (jsdl__OperatingSystem_USCOREType*)p->ptr;
		else
			delete[] (jsdl__OperatingSystem_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__OperatingSystemType_USCOREType:
		if (p->size < 0)
			delete (jsdl__OperatingSystemType_USCOREType*)p->ptr;
		else
			delete[] (jsdl__OperatingSystemType_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__DataStaging_USCOREType:
		if (p->size < 0)
			delete (jsdl__DataStaging_USCOREType*)p->ptr;
		else
			delete[] (jsdl__DataStaging_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__SourceTarget_USCOREType:
		if (p->size < 0)
			delete (jsdl__SourceTarget_USCOREType*)p->ptr;
		else
			delete[] (jsdl__SourceTarget_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__POSIXApplication_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__POSIXApplication_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_myproxy__MyProxyType:
		if (p->size < 0)
			delete (myproxy__MyProxyType*)p->ptr;
		else
			delete[] (myproxy__MyProxyType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType:
		if (p->size < 0)
			delete (gridsam2__HPCProfileApplication_USCOREType*)p->ptr;
		else
			delete[] (gridsam2__HPCProfileApplication_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__Boundary_USCOREType:
		if (p->size < 0)
			delete (jsdl__Boundary_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Boundary_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__Exact_USCOREType:
		if (p->size < 0)
			delete (jsdl__Exact_USCOREType*)p->ptr;
		else
			delete[] (jsdl__Exact_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__Environment_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__Environment_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__Environment_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__Argument_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__Argument_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__Argument_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__FileName_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__FileName_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__FileName_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__DirectoryName_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__DirectoryName_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__DirectoryName_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__Limits_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__Limits_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__Limits_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__UserName_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__UserName_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__UserName_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_jsdlposix__GroupName_USCOREType:
		if (p->size < 0)
			delete (jsdlposix__GroupName_USCOREType*)p->ptr;
		else
			delete[] (jsdlposix__GroupName_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_mpi__MPIApplicationType:
		if (p->size < 0)
			delete (mpi__MPIApplicationType*)p->ptr;
		else
			delete[] (mpi__MPIApplicationType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam2__Environment_USCOREType:
		if (p->size < 0)
			delete (gridsam2__Environment_USCOREType*)p->ptr;
		else
			delete[] (gridsam2__Environment_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam2__Argument_USCOREType:
		if (p->size < 0)
			delete (gridsam2__Argument_USCOREType*)p->ptr;
		else
			delete[] (gridsam2__Argument_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam2__FileName_USCOREType:
		if (p->size < 0)
			delete (gridsam2__FileName_USCOREType*)p->ptr;
		else
			delete[] (gridsam2__FileName_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam2__DirectoryName_USCOREType:
		if (p->size < 0)
			delete (gridsam2__DirectoryName_USCOREType*)p->ptr;
		else
			delete[] (gridsam2__DirectoryName_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_gridsam2__UserName_USCOREType:
		if (p->size < 0)
			delete (gridsam2__UserName_USCOREType*)p->ptr;
		else
			delete[] (gridsam2__UserName_USCOREType*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE___jobcontrol__terminateJob:
		if (p->size < 0)
			delete (struct __jobcontrol__terminateJob*)p->ptr;
		else
			delete[] (struct __jobcontrol__terminateJob*)p->ptr;
		break;
	case SOAP_TYPE___jobcontrol__startJob:
		if (p->size < 0)
			delete (struct __jobcontrol__startJob*)p->ptr;
		else
			delete[] (struct __jobcontrol__startJob*)p->ptr;
		break;
	case SOAP_TYPE___jobmonitoring__getJobStatus:
		if (p->size < 0)
			delete (struct __jobmonitoring__getJobStatus*)p->ptr;
		else
			delete[] (struct __jobmonitoring__getJobStatus*)p->ptr;
		break;
	case SOAP_TYPE___jobsubmission__submitJob:
		if (p->size < 0)
			delete (struct __jobsubmission__submitJob*)p->ptr;
		else
			delete[] (struct __jobsubmission__submitJob*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__ID:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__normalizedString:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__positiveInteger:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_jsdl__Description_USCOREType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType:
		if (p->size < 0)
			delete (std::vector<gridsam2__Environment_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<gridsam2__Environment_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType:
		if (p->size < 0)
			delete (std::vector<gridsam2__Argument_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<gridsam2__Argument_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdlposix__Environment_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdlposix__Environment_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdlposix__Argument_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdlposix__Argument_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__FileSystem_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__DataStaging_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__Range_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__Range_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		if (p->size < 0)
			delete (std::vector<jsdl__Exact_USCOREType * >*)p->ptr;
		else
			delete[] (std::vector<jsdl__Exact_USCOREType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobStatusType:
		if (p->size < 0)
			delete (std::vector<gridsam__JobStatusType * >*)p->ptr;
		else
			delete[] (std::vector<gridsam__JobStatusType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobIdentifierType:
		if (p->size < 0)
			delete (std::vector<gridsam__JobIdentifierType * >*)p->ptr;
		else
			delete[] (std::vector<gridsam__JobIdentifierType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobDescriptionType:
		if (p->size < 0)
			delete (std::vector<gridsam__JobDescriptionType * >*)p->ptr;
		else
			delete[] (std::vector<gridsam__JobDescriptionType * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Property:
		if (p->size < 0)
			delete (std::vector<_gridsam__Property * >*)p->ptr;
		else
			delete[] (std::vector<_gridsam__Property * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Stage:
		if (p->size < 0)
			delete (std::vector<_gridsam__Stage * >*)p->ptr;
		else
			delete[] (std::vector<_gridsam__Stage * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<gridsam2__Environment_USCOREType * >*)p)[len] = *(gridsam2__Environment_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<gridsam2__Argument_USCOREType * >*)p)[len] = *(gridsam2__Argument_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdlposix__Environment_USCOREType * >*)p)[len] = *(jsdlposix__Environment_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdlposix__Argument_USCOREType * >*)p)[len] = *(jsdlposix__Argument_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__FileSystem_USCOREType * >*)p)[len] = *(jsdl__FileSystem_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__DataStaging_USCOREType * >*)p)[len] = *(jsdl__DataStaging_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Range_USCOREType * >*)p)[len] = *(jsdl__Range_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<jsdl__Exact_USCOREType * >*)p)[len] = *(jsdl__Exact_USCOREType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobStatusType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<gridsam__JobStatusType * >*)p)[len] = *(gridsam__JobStatusType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobIdentifierType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<gridsam__JobIdentifierType * >*)p)[len] = *(gridsam__JobIdentifierType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobDescriptionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<gridsam__JobDescriptionType * >*)p)[len] = *(gridsam__JobDescriptionType **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Property:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_gridsam__Property * >*)p)[len] = *(_gridsam__Property **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Stage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_gridsam__Stage * >*)p)[len] = *(_gridsam__Stage **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__CreationFlagEnumeration
	*a = SOAP_DEFAULT_jsdl__CreationFlagEnumeration;
#else
	*a = (enum jsdl__CreationFlagEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__CreationFlagEnumeration(struct soap *soap, const enum jsdl__CreationFlagEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__CreationFlagEnumeration);
	if (soap_out_jsdl__CreationFlagEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__CreationFlagEnumeration[] =
{	{ (long)jsdl__CreationFlagEnumeration__overwrite, "overwrite" },
	{ (long)jsdl__CreationFlagEnumeration__append, "append" },
	{ (long)jsdl__CreationFlagEnumeration__dontOverwrite, "dontOverwrite" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__CreationFlagEnumeration2s(struct soap *soap, enum jsdl__CreationFlagEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__CreationFlagEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__CreationFlagEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration), type) || soap_send(soap, soap_jsdl__CreationFlagEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_get_jsdl__CreationFlagEnumeration(struct soap *soap, enum jsdl__CreationFlagEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CreationFlagEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__CreationFlagEnumeration(struct soap *soap, const char *s, enum jsdl__CreationFlagEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__CreationFlagEnumeration, s);
	if (map)
		*a = (enum jsdl__CreationFlagEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__CreationFlagEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__CreationFlagEnumeration * SOAP_FMAC4 soap_in_jsdl__CreationFlagEnumeration(struct soap *soap, const char *tag, enum jsdl__CreationFlagEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__CreationFlagEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CreationFlagEnumeration, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__CreationFlagEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__CreationFlagEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CreationFlagEnumeration, 0, sizeof(enum jsdl__CreationFlagEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__FileSystemTypeEnumeration;
#else
	*a = (enum jsdl__FileSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__FileSystemTypeEnumeration(struct soap *soap, const enum jsdl__FileSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__FileSystemTypeEnumeration[] =
{	{ (long)jsdl__FileSystemTypeEnumeration__swap, "swap" },
	{ (long)jsdl__FileSystemTypeEnumeration__temporary, "temporary" },
	{ (long)jsdl__FileSystemTypeEnumeration__spool, "spool" },
	{ (long)jsdl__FileSystemTypeEnumeration__normal, "normal" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__FileSystemTypeEnumeration2s(struct soap *soap, enum jsdl__FileSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__FileSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__FileSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__FileSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__FileSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__FileSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__FileSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__FileSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, 0, sizeof(enum jsdl__FileSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration
	*a = SOAP_DEFAULT_jsdl__OperatingSystemTypeEnumeration;
#else
	*a = (enum jsdl__OperatingSystemTypeEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration);
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__OperatingSystemTypeEnumeration[] =
{	{ (long)jsdl__OperatingSystemTypeEnumeration__Unknown, "Unknown" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACOS, "MACOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ATTUNIX, "ATTUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DGUX, "DGUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DECNT, "DECNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Tru64_USCOREUNIX, "Tru64_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenVMS, "OpenVMS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HPUX, "HPUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__AIX, "AIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MVS, "MVS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS400, "OS400" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE2, "OS_2" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__JavaVM, "JavaVM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MSDOS, "MSDOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN3x, "WIN3x" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN95, "WIN95" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WIN98, "WIN98" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINNT, "WINNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__WINCE, "WINCE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NCR3000, "NCR3000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetWare, "NetWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OSF, "OSF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__DC_USCOREOS, "DC_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Reliant_USCOREUNIX, "Reliant_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREUnixWare, "SCO_UnixWare" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SCO_USCOREOpenServer, "SCO_OpenServer" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Sequent, "Sequent" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IRIX, "IRIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Solaris, "Solaris" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__SunOS, "SunOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__U6000, "U6000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__ASERIES, "ASERIES" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNSK, "TandemNSK" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TandemNT, "TandemNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BS2000, "BS2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__LINUX, "LINUX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Lynx, "Lynx" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__XENIX, "XENIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VM, "VM" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Interactive_USCOREUNIX, "Interactive_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BSDUNIX, "BSDUNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__FreeBSD, "FreeBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NetBSD, "NetBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__GNU_USCOREHurd, "GNU_Hurd" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS9, "OS9" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MACH_USCOREKernel, "MACH_Kernel" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Inferno, "Inferno" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__QNX, "QNX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__EPOC, "EPOC" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__IxWorks, "IxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VxWorks, "VxWorks" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__MiNT, "MiNT" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__BeOS, "BeOS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__HP_USCOREMPE, "HP_MPE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__NextStep, "NextStep" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__PalmPilot, "PalmPilot" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Rhapsody, "Rhapsody" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORE2000, "Windows_2000" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Dedicated, "Dedicated" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OS_USCORE390, "OS_390" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__VSE, "VSE" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__TPF, "TPF" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCORER_USCOREMe, "Windows_R_Me" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Caldera_USCOREOpen_USCOREUNIX, "Caldera_Open_UNIX" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__OpenBSD, "OpenBSD" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Not_USCOREApplicable, "Not_Applicable" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__Windows_USCOREXP, "Windows_XP" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__z_USCOREOS, "z_OS" },
	{ (long)jsdl__OperatingSystemTypeEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__OperatingSystemTypeEnumeration2s(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__OperatingSystemTypeEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration), type) || soap_send(soap, soap_jsdl__OperatingSystemTypeEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_get_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, enum jsdl__OperatingSystemTypeEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *s, enum jsdl__OperatingSystemTypeEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__OperatingSystemTypeEnumeration, s);
	if (map)
		*a = (enum jsdl__OperatingSystemTypeEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 68)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__OperatingSystemTypeEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__OperatingSystemTypeEnumeration * SOAP_FMAC4 soap_in_jsdl__OperatingSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__OperatingSystemTypeEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__OperatingSystemTypeEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__OperatingSystemTypeEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemTypeEnumeration, 0, sizeof(enum jsdl__OperatingSystemTypeEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration
	*a = SOAP_DEFAULT_jsdl__ProcessorArchitectureEnumeration;
#else
	*a = (enum jsdl__ProcessorArchitectureEnumeration)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration);
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_jsdl__ProcessorArchitectureEnumeration[] =
{	{ (long)jsdl__ProcessorArchitectureEnumeration__sparc, "sparc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__powerpc, "powerpc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86, "x86" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE32, "x86_32" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__x86_USCORE64, "x86_64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__parisc, "parisc" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__mips, "mips" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__ia64, "ia64" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__arm, "arm" },
	{ (long)jsdl__ProcessorArchitectureEnumeration__other, "other" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_jsdl__ProcessorArchitectureEnumeration2s(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration n)
{	const char *s = soap_code_str(soap_codes_jsdl__ProcessorArchitectureEnumeration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, int id, const enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration), type) || soap_send(soap, soap_jsdl__ProcessorArchitectureEnumeration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_get_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, enum jsdl__ProcessorArchitectureEnumeration *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__ProcessorArchitectureEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *s, enum jsdl__ProcessorArchitectureEnumeration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_jsdl__ProcessorArchitectureEnumeration, s);
	if (map)
		*a = (enum jsdl__ProcessorArchitectureEnumeration)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum jsdl__ProcessorArchitectureEnumeration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum jsdl__ProcessorArchitectureEnumeration * SOAP_FMAC4 soap_in_jsdl__ProcessorArchitectureEnumeration(struct soap *soap, const char *tag, enum jsdl__ProcessorArchitectureEnumeration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2jsdl__ProcessorArchitectureEnumeration(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum jsdl__ProcessorArchitectureEnumeration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__ProcessorArchitectureEnumeration, 0, sizeof(enum jsdl__ProcessorArchitectureEnumeration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_gridsam__StateType(struct soap *soap, enum gridsam__StateType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_gridsam__StateType
	*a = SOAP_DEFAULT_gridsam__StateType;
#else
	*a = (enum gridsam__StateType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_gridsam__StateType(struct soap *soap, const enum gridsam__StateType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_gridsam__StateType);
	if (soap_out_gridsam__StateType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_gridsam__StateType[] =
{	{ (long)gridsam__StateType__pending, "pending" },
	{ (long)gridsam__StateType__staging_in, "staging-in" },
	{ (long)gridsam__StateType__staged_in, "staged-in" },
	{ (long)gridsam__StateType__staging_out, "staging-out" },
	{ (long)gridsam__StateType__staged_out, "staged-out" },
	{ (long)gridsam__StateType__active, "active" },
	{ (long)gridsam__StateType__executed, "executed" },
	{ (long)gridsam__StateType__failed, "failed" },
	{ (long)gridsam__StateType__done, "done" },
	{ (long)gridsam__StateType__terminating, "terminating" },
	{ (long)gridsam__StateType__terminated, "terminated" },
	{ (long)gridsam__StateType__undefined, "undefined" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_gridsam__StateType2s(struct soap *soap, enum gridsam__StateType n)
{	const char *s = soap_code_str(soap_codes_gridsam__StateType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam__StateType(struct soap *soap, const char *tag, int id, const enum gridsam__StateType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gridsam__StateType), type) || soap_send(soap, soap_gridsam__StateType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum gridsam__StateType * SOAP_FMAC4 soap_get_gridsam__StateType(struct soap *soap, enum gridsam__StateType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam__StateType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2gridsam__StateType(struct soap *soap, const char *s, enum gridsam__StateType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_gridsam__StateType, s);
	if (map)
		*a = (enum gridsam__StateType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 11)))
			return soap->error = SOAP_TYPE;
		*a = (enum gridsam__StateType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum gridsam__StateType * SOAP_FMAC4 soap_in_gridsam__StateType(struct soap *soap, const char *tag, enum gridsam__StateType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum gridsam__StateType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam__StateType, sizeof(enum gridsam__StateType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2gridsam__StateType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum gridsam__StateType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gridsam__StateType, 0, sizeof(enum gridsam__StateType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_jsdl__Description_USCOREType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_jsdl__Description_USCOREType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_jsdl__Description_USCOREType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_jsdl__Description_USCOREType);
	if (soap_out_jsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_jsdl__Description_USCOREType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_jsdl__Description_USCOREType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_jsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_jsdl__Description_USCOREType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_jsdl__Description_USCOREType, 0, sizeof(std::string), 0, soap_copy_jsdl__Description_USCOREType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_jsdl__Description_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Description_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Description_USCOREType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_jsdl__Description_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Description_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Description_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Description_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void gridsam2__HPCProfileApplication_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Executable = NULL;
	soap_default_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Argument);
	this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Input = NULL;
	this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Output = NULL;
	this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Error = NULL;
	this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__WorkingDirectory = NULL;
	soap_default_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Environment);
	this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__UserName = NULL;
	this->gridsam2__HPCProfileApplication_USCOREType::name = NULL;
	this->gridsam2__HPCProfileApplication_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void gridsam2__HPCProfileApplication_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTogridsam2__FileName_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Executable);
	soap_serialize_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Argument);
	soap_serialize_PointerTogridsam2__FileName_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Input);
	soap_serialize_PointerTogridsam2__FileName_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Output);
	soap_serialize_PointerTogridsam2__FileName_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Error);
	soap_serialize_PointerTogridsam2__DirectoryName_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__WorkingDirectory);
	soap_serialize_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Environment);
	soap_serialize_PointerTogridsam2__UserName_USCOREType(soap, &this->gridsam2__HPCProfileApplication_USCOREType::gridsam2__UserName);
	/* transient soap skipped */
}

int gridsam2__HPCProfileApplication_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam2__HPCProfileApplication_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam2__HPCProfileApplication_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam2__HPCProfileApplication_USCOREType(struct soap *soap, const char *tag, int id, const gridsam2__HPCProfileApplication_USCOREType *a, const char *type)
{
	if (((gridsam2__HPCProfileApplication_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((gridsam2__HPCProfileApplication_USCOREType*)a)->name->c_str());
	if (((gridsam2__HPCProfileApplication_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((gridsam2__HPCProfileApplication_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Executable", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Executable), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(soap, "gridsam2:Argument", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Argument), ""))
		return soap->error;
	if (soap_out_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Input", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Input), ""))
		return soap->error;
	if (soap_out_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Output", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Output), ""))
		return soap->error;
	if (soap_out_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Error", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Error), ""))
		return soap->error;
	if (soap_out_PointerTogridsam2__DirectoryName_USCOREType(soap, "gridsam2:WorkingDirectory", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__WorkingDirectory), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(soap, "gridsam2:Environment", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Environment), ""))
		return soap->error;
	if (soap_out_PointerTogridsam2__UserName_USCOREType(soap, "gridsam2:UserName", -1, &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__UserName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *gridsam2__HPCProfileApplication_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam2__HPCProfileApplication_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam2__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_get_gridsam2__HPCProfileApplication_USCOREType(struct soap *soap, gridsam2__HPCProfileApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam2__HPCProfileApplication_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam2__HPCProfileApplication_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam2__HPCProfileApplication_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam2__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_in_gridsam2__HPCProfileApplication_USCOREType(struct soap *soap, const char *tag, gridsam2__HPCProfileApplication_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (gridsam2__HPCProfileApplication_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType, sizeof(gridsam2__HPCProfileApplication_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (gridsam2__HPCProfileApplication_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((gridsam2__HPCProfileApplication_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((gridsam2__HPCProfileApplication_USCOREType*)a)->name->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((gridsam2__HPCProfileApplication_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_gridsam2__Executable1 = 1;
	size_t soap_flag_gridsam2__Input1 = 1;
	size_t soap_flag_gridsam2__Output1 = 1;
	size_t soap_flag_gridsam2__Error1 = 1;
	size_t soap_flag_gridsam2__WorkingDirectory1 = 1;
	size_t soap_flag_gridsam2__UserName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gridsam2__Executable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Executable", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Executable), "gridsam2:FileName_Type"))
				{	soap_flag_gridsam2__Executable1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(soap, "gridsam2:Argument", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Argument), "gridsam2:Argument_Type"))
					continue;
			if (soap_flag_gridsam2__Input1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Input", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Input), "gridsam2:FileName_Type"))
				{	soap_flag_gridsam2__Input1--;
					continue;
				}
			if (soap_flag_gridsam2__Output1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Output", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Output), "gridsam2:FileName_Type"))
				{	soap_flag_gridsam2__Output1--;
					continue;
				}
			if (soap_flag_gridsam2__Error1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogridsam2__FileName_USCOREType(soap, "gridsam2:Error", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Error), "gridsam2:FileName_Type"))
				{	soap_flag_gridsam2__Error1--;
					continue;
				}
			if (soap_flag_gridsam2__WorkingDirectory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogridsam2__DirectoryName_USCOREType(soap, "gridsam2:WorkingDirectory", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__WorkingDirectory), "gridsam2:DirectoryName_Type"))
				{	soap_flag_gridsam2__WorkingDirectory1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(soap, "gridsam2:Environment", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__Environment), "gridsam2:Environment_Type"))
					continue;
			if (soap_flag_gridsam2__UserName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogridsam2__UserName_USCOREType(soap, "gridsam2:UserName", &(a->gridsam2__HPCProfileApplication_USCOREType::gridsam2__UserName), "gridsam2:UserName_Type"))
				{	soap_flag_gridsam2__UserName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (gridsam2__HPCProfileApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType, 0, sizeof(gridsam2__HPCProfileApplication_USCOREType), 0, soap_copy_gridsam2__HPCProfileApplication_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gridsam2__Executable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 gridsam2__HPCProfileApplication_USCOREType * SOAP_FMAC6 soap_new_gridsam2__HPCProfileApplication_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_gridsam2__HPCProfileApplication_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam2__HPCProfileApplication_USCOREType(struct soap *soap, gridsam2__HPCProfileApplication_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam2__HPCProfileApplication_USCOREType * SOAP_FMAC4 soap_instantiate_gridsam2__HPCProfileApplication_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam2__HPCProfileApplication_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam2__HPCProfileApplication_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam2__HPCProfileApplication_USCOREType;
		if (size)
			*size = sizeof(gridsam2__HPCProfileApplication_USCOREType);
		((gridsam2__HPCProfileApplication_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam2__HPCProfileApplication_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam2__HPCProfileApplication_USCOREType);
		for (int i = 0; i < n; i++)
			((gridsam2__HPCProfileApplication_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam2__HPCProfileApplication_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam2__HPCProfileApplication_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam2__HPCProfileApplication_USCOREType %p -> %p\n", q, p));
	*(gridsam2__HPCProfileApplication_USCOREType*)p = *(gridsam2__HPCProfileApplication_USCOREType*)q;
}

void gridsam2__UserName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->gridsam2__UserName_USCOREType::__item);
	this->gridsam2__UserName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void gridsam2__UserName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->gridsam2__UserName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->gridsam2__UserName_USCOREType::__item);
	/* transient soap skipped */
}

int gridsam2__UserName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam2__UserName_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam2__UserName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam2__UserName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam2__UserName_USCOREType(struct soap *soap, const char *tag, int id, const gridsam2__UserName_USCOREType *a, const char *type)
{
	if (((gridsam2__UserName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((gridsam2__UserName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->gridsam2__UserName_USCOREType::__item, "");
}

void *gridsam2__UserName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam2__UserName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam2__UserName_USCOREType * SOAP_FMAC4 soap_get_gridsam2__UserName_USCOREType(struct soap *soap, gridsam2__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam2__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam2__UserName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam2__UserName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam2__UserName_USCOREType * SOAP_FMAC4 soap_in_gridsam2__UserName_USCOREType(struct soap *soap, const char *tag, gridsam2__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (gridsam2__UserName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam2__UserName_USCOREType, sizeof(gridsam2__UserName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam2__UserName_USCOREType)
			return (gridsam2__UserName_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((gridsam2__UserName_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->gridsam2__UserName_USCOREType::__item), "gridsam2:UserName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 gridsam2__UserName_USCOREType * SOAP_FMAC6 soap_new_gridsam2__UserName_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_gridsam2__UserName_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam2__UserName_USCOREType(struct soap *soap, gridsam2__UserName_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam2__UserName_USCOREType * SOAP_FMAC4 soap_instantiate_gridsam2__UserName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam2__UserName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam2__UserName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam2__UserName_USCOREType;
		if (size)
			*size = sizeof(gridsam2__UserName_USCOREType);
		((gridsam2__UserName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam2__UserName_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam2__UserName_USCOREType);
		for (int i = 0; i < n; i++)
			((gridsam2__UserName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam2__UserName_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam2__UserName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam2__UserName_USCOREType %p -> %p\n", q, p));
	*(gridsam2__UserName_USCOREType*)p = *(gridsam2__UserName_USCOREType*)q;
}

void gridsam2__DirectoryName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->gridsam2__DirectoryName_USCOREType::__item);
	this->gridsam2__DirectoryName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void gridsam2__DirectoryName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->gridsam2__DirectoryName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->gridsam2__DirectoryName_USCOREType::__item);
	/* transient soap skipped */
}

int gridsam2__DirectoryName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam2__DirectoryName_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam2__DirectoryName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam2__DirectoryName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam2__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, const gridsam2__DirectoryName_USCOREType *a, const char *type)
{
	if (((gridsam2__DirectoryName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((gridsam2__DirectoryName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->gridsam2__DirectoryName_USCOREType::__item, "");
}

void *gridsam2__DirectoryName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam2__DirectoryName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam2__DirectoryName_USCOREType * SOAP_FMAC4 soap_get_gridsam2__DirectoryName_USCOREType(struct soap *soap, gridsam2__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam2__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam2__DirectoryName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam2__DirectoryName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam2__DirectoryName_USCOREType * SOAP_FMAC4 soap_in_gridsam2__DirectoryName_USCOREType(struct soap *soap, const char *tag, gridsam2__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (gridsam2__DirectoryName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam2__DirectoryName_USCOREType, sizeof(gridsam2__DirectoryName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam2__DirectoryName_USCOREType)
			return (gridsam2__DirectoryName_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((gridsam2__DirectoryName_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->gridsam2__DirectoryName_USCOREType::__item), "gridsam2:DirectoryName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 gridsam2__DirectoryName_USCOREType * SOAP_FMAC6 soap_new_gridsam2__DirectoryName_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_gridsam2__DirectoryName_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam2__DirectoryName_USCOREType(struct soap *soap, gridsam2__DirectoryName_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam2__DirectoryName_USCOREType * SOAP_FMAC4 soap_instantiate_gridsam2__DirectoryName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam2__DirectoryName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam2__DirectoryName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam2__DirectoryName_USCOREType;
		if (size)
			*size = sizeof(gridsam2__DirectoryName_USCOREType);
		((gridsam2__DirectoryName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam2__DirectoryName_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam2__DirectoryName_USCOREType);
		for (int i = 0; i < n; i++)
			((gridsam2__DirectoryName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam2__DirectoryName_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam2__DirectoryName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam2__DirectoryName_USCOREType %p -> %p\n", q, p));
	*(gridsam2__DirectoryName_USCOREType*)p = *(gridsam2__DirectoryName_USCOREType*)q;
}

void gridsam2__FileName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->gridsam2__FileName_USCOREType::__item);
	this->gridsam2__FileName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void gridsam2__FileName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->gridsam2__FileName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->gridsam2__FileName_USCOREType::__item);
	/* transient soap skipped */
}

int gridsam2__FileName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam2__FileName_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam2__FileName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam2__FileName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam2__FileName_USCOREType(struct soap *soap, const char *tag, int id, const gridsam2__FileName_USCOREType *a, const char *type)
{
	if (((gridsam2__FileName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((gridsam2__FileName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->gridsam2__FileName_USCOREType::__item, "");
}

void *gridsam2__FileName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam2__FileName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam2__FileName_USCOREType * SOAP_FMAC4 soap_get_gridsam2__FileName_USCOREType(struct soap *soap, gridsam2__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam2__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam2__FileName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam2__FileName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam2__FileName_USCOREType * SOAP_FMAC4 soap_in_gridsam2__FileName_USCOREType(struct soap *soap, const char *tag, gridsam2__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (gridsam2__FileName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam2__FileName_USCOREType, sizeof(gridsam2__FileName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam2__FileName_USCOREType)
			return (gridsam2__FileName_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((gridsam2__FileName_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->gridsam2__FileName_USCOREType::__item), "gridsam2:FileName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 gridsam2__FileName_USCOREType * SOAP_FMAC6 soap_new_gridsam2__FileName_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_gridsam2__FileName_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam2__FileName_USCOREType(struct soap *soap, gridsam2__FileName_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam2__FileName_USCOREType * SOAP_FMAC4 soap_instantiate_gridsam2__FileName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam2__FileName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam2__FileName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam2__FileName_USCOREType;
		if (size)
			*size = sizeof(gridsam2__FileName_USCOREType);
		((gridsam2__FileName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam2__FileName_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam2__FileName_USCOREType);
		for (int i = 0; i < n; i++)
			((gridsam2__FileName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam2__FileName_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam2__FileName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam2__FileName_USCOREType %p -> %p\n", q, p));
	*(gridsam2__FileName_USCOREType*)p = *(gridsam2__FileName_USCOREType*)q;
}

void gridsam2__Argument_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->gridsam2__Argument_USCOREType::__item);
	this->gridsam2__Argument_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void gridsam2__Argument_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->gridsam2__Argument_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->gridsam2__Argument_USCOREType::__item);
	/* transient soap skipped */
}

int gridsam2__Argument_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam2__Argument_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam2__Argument_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam2__Argument_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam2__Argument_USCOREType(struct soap *soap, const char *tag, int id, const gridsam2__Argument_USCOREType *a, const char *type)
{
	if (((gridsam2__Argument_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((gridsam2__Argument_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->gridsam2__Argument_USCOREType::__item, "");
}

void *gridsam2__Argument_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam2__Argument_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam2__Argument_USCOREType * SOAP_FMAC4 soap_get_gridsam2__Argument_USCOREType(struct soap *soap, gridsam2__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam2__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam2__Argument_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam2__Argument_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam2__Argument_USCOREType * SOAP_FMAC4 soap_in_gridsam2__Argument_USCOREType(struct soap *soap, const char *tag, gridsam2__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (gridsam2__Argument_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam2__Argument_USCOREType, sizeof(gridsam2__Argument_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam2__Argument_USCOREType)
			return (gridsam2__Argument_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((gridsam2__Argument_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->gridsam2__Argument_USCOREType::__item), "gridsam2:Argument_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 gridsam2__Argument_USCOREType * SOAP_FMAC6 soap_new_gridsam2__Argument_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_gridsam2__Argument_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam2__Argument_USCOREType(struct soap *soap, gridsam2__Argument_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam2__Argument_USCOREType * SOAP_FMAC4 soap_instantiate_gridsam2__Argument_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam2__Argument_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam2__Argument_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam2__Argument_USCOREType;
		if (size)
			*size = sizeof(gridsam2__Argument_USCOREType);
		((gridsam2__Argument_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam2__Argument_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam2__Argument_USCOREType);
		for (int i = 0; i < n; i++)
			((gridsam2__Argument_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam2__Argument_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam2__Argument_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam2__Argument_USCOREType %p -> %p\n", q, p));
	*(gridsam2__Argument_USCOREType*)p = *(gridsam2__Argument_USCOREType*)q;
}

void gridsam2__Environment_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->gridsam2__Environment_USCOREType::__item);
	soap_default_xsd__NCName(soap, &this->gridsam2__Environment_USCOREType::name);
	this->gridsam2__Environment_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void gridsam2__Environment_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->gridsam2__Environment_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->gridsam2__Environment_USCOREType::__item);
	/* transient soap skipped */
}

int gridsam2__Environment_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam2__Environment_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam2__Environment_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam2__Environment_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam2__Environment_USCOREType(struct soap *soap, const char *tag, int id, const gridsam2__Environment_USCOREType *a, const char *type)
{
	if (!((gridsam2__Environment_USCOREType*)a)->name.empty())
		soap_set_attr(soap, "name", ((gridsam2__Environment_USCOREType*)a)->name.c_str());
	if (((gridsam2__Environment_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((gridsam2__Environment_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->gridsam2__Environment_USCOREType::__item, "");
}

void *gridsam2__Environment_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam2__Environment_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam2__Environment_USCOREType * SOAP_FMAC4 soap_get_gridsam2__Environment_USCOREType(struct soap *soap, gridsam2__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam2__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam2__Environment_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam2__Environment_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam2__Environment_USCOREType * SOAP_FMAC4 soap_in_gridsam2__Environment_USCOREType(struct soap *soap, const char *tag, gridsam2__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (gridsam2__Environment_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam2__Environment_USCOREType, sizeof(gridsam2__Environment_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam2__Environment_USCOREType)
			return (gridsam2__Environment_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((gridsam2__Environment_USCOREType*)a)->name.assign(s);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((gridsam2__Environment_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->gridsam2__Environment_USCOREType::__item), "gridsam2:Environment_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 gridsam2__Environment_USCOREType * SOAP_FMAC6 soap_new_gridsam2__Environment_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_gridsam2__Environment_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam2__Environment_USCOREType(struct soap *soap, gridsam2__Environment_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam2__Environment_USCOREType * SOAP_FMAC4 soap_instantiate_gridsam2__Environment_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam2__Environment_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam2__Environment_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam2__Environment_USCOREType;
		if (size)
			*size = sizeof(gridsam2__Environment_USCOREType);
		((gridsam2__Environment_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam2__Environment_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam2__Environment_USCOREType);
		for (int i = 0; i < n; i++)
			((gridsam2__Environment_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam2__Environment_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam2__Environment_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam2__Environment_USCOREType %p -> %p\n", q, p));
	*(gridsam2__Environment_USCOREType*)p = *(gridsam2__Environment_USCOREType*)q;
}

void mpi__MPIApplicationType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__positiveInteger(soap, &this->mpi__MPIApplicationType::mpi__ProcessorCount);
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument);
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment);
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::name = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void mpi__MPIApplicationType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__positiveInteger(soap, &this->mpi__MPIApplicationType::mpi__ProcessorCount);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable);
	soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error);
	soap_serialize_PointerTojsdlposix__DirectoryName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory);
	soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit);
	soap_serialize_PointerTojsdlposix__UserName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName);
	soap_serialize_PointerTojsdlposix__GroupName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName);
	/* transient soap skipped */
}

int mpi__MPIApplicationType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_mpi__MPIApplicationType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int mpi__MPIApplicationType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_mpi__MPIApplicationType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_mpi__MPIApplicationType(struct soap *soap, const char *tag, int id, const mpi__MPIApplicationType *a, const char *type)
{
	if (((jsdlposix__POSIXApplication_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((jsdlposix__POSIXApplication_USCOREType*)a)->name->c_str());
	if (((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_mpi__MPIApplicationType), "mpi:MPIApplicationType"))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Executable", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, "jsdlposix:Argument", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Input", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Output", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Error", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__DirectoryName_USCOREType(soap, "jsdlposix:WorkingDirectory", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, "jsdlposix:Environment", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:WallTimeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:FileSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CoreDumpLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:DataSegmentLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:LockedMemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:MemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:OpenDescriptorsLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:PipeSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:StackSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CPUTimeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ProcessCountLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:VirtualMemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ThreadCountLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__UserName_USCOREType(soap, "jsdlposix:UserName", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__GroupName_USCOREType(soap, "jsdlposix:GroupName", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__positiveInteger(soap, "mpi:ProcessorCount", -1, &(a->mpi__MPIApplicationType::mpi__ProcessorCount), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *mpi__MPIApplicationType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mpi__MPIApplicationType(soap, this, tag, type);
}

SOAP_FMAC3 mpi__MPIApplicationType * SOAP_FMAC4 soap_get_mpi__MPIApplicationType(struct soap *soap, mpi__MPIApplicationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_mpi__MPIApplicationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *mpi__MPIApplicationType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mpi__MPIApplicationType(soap, tag, this, type);
}

SOAP_FMAC3 mpi__MPIApplicationType * SOAP_FMAC4 soap_in_mpi__MPIApplicationType(struct soap *soap, const char *tag, mpi__MPIApplicationType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (mpi__MPIApplicationType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_mpi__MPIApplicationType, sizeof(mpi__MPIApplicationType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_mpi__MPIApplicationType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (mpi__MPIApplicationType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdlposix__POSIXApplication_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((jsdlposix__POSIXApplication_USCOREType*)a)->name->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdlposix__Executable2 = 1;
	size_t soap_flag_jsdlposix__Input2 = 1;
	size_t soap_flag_jsdlposix__Output2 = 1;
	size_t soap_flag_jsdlposix__Error2 = 1;
	size_t soap_flag_jsdlposix__WorkingDirectory2 = 1;
	size_t soap_flag_jsdlposix__WallTimeLimit2 = 1;
	size_t soap_flag_jsdlposix__FileSizeLimit2 = 1;
	size_t soap_flag_jsdlposix__CoreDumpLimit2 = 1;
	size_t soap_flag_jsdlposix__DataSegmentLimit2 = 1;
	size_t soap_flag_jsdlposix__LockedMemoryLimit2 = 1;
	size_t soap_flag_jsdlposix__MemoryLimit2 = 1;
	size_t soap_flag_jsdlposix__OpenDescriptorsLimit2 = 1;
	size_t soap_flag_jsdlposix__PipeSizeLimit2 = 1;
	size_t soap_flag_jsdlposix__StackSizeLimit2 = 1;
	size_t soap_flag_jsdlposix__CPUTimeLimit2 = 1;
	size_t soap_flag_jsdlposix__ProcessCountLimit2 = 1;
	size_t soap_flag_jsdlposix__VirtualMemoryLimit2 = 1;
	size_t soap_flag_jsdlposix__ThreadCountLimit2 = 1;
	size_t soap_flag_jsdlposix__UserName2 = 1;
	size_t soap_flag_jsdlposix__GroupName2 = 1;
	size_t soap_flag_mpi__ProcessorCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdlposix__Executable2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Executable", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Executable2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, "jsdlposix:Argument", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument), "jsdlposix:Argument_Type"))
					continue;
			if (soap_flag_jsdlposix__Input2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Input", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Input2--;
					continue;
				}
			if (soap_flag_jsdlposix__Output2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Output", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Output2--;
					continue;
				}
			if (soap_flag_jsdlposix__Error2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Error", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Error2--;
					continue;
				}
			if (soap_flag_jsdlposix__WorkingDirectory2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__DirectoryName_USCOREType(soap, "jsdlposix:WorkingDirectory", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory), "jsdlposix:DirectoryName_Type"))
				{	soap_flag_jsdlposix__WorkingDirectory2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, "jsdlposix:Environment", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment), "jsdlposix:Environment_Type"))
					continue;
			if (soap_flag_jsdlposix__WallTimeLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:WallTimeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__WallTimeLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__FileSizeLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:FileSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__FileSizeLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__CoreDumpLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CoreDumpLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__CoreDumpLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__DataSegmentLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:DataSegmentLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__DataSegmentLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__LockedMemoryLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:LockedMemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__LockedMemoryLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__MemoryLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:MemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__MemoryLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__OpenDescriptorsLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:OpenDescriptorsLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__OpenDescriptorsLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__PipeSizeLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:PipeSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__PipeSizeLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__StackSizeLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:StackSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__StackSizeLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__CPUTimeLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CPUTimeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__CPUTimeLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__ProcessCountLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ProcessCountLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__ProcessCountLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__VirtualMemoryLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:VirtualMemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__VirtualMemoryLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__ThreadCountLimit2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ThreadCountLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__ThreadCountLimit2--;
					continue;
				}
			if (soap_flag_jsdlposix__UserName2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__UserName_USCOREType(soap, "jsdlposix:UserName", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName), "jsdlposix:UserName_Type"))
				{	soap_flag_jsdlposix__UserName2--;
					continue;
				}
			if (soap_flag_jsdlposix__GroupName2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__GroupName_USCOREType(soap, "jsdlposix:GroupName", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName), "jsdlposix:GroupName_Type"))
				{	soap_flag_jsdlposix__GroupName2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_mpi__ProcessorCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__positiveInteger(soap, "mpi:ProcessorCount", &(a->mpi__MPIApplicationType::mpi__ProcessorCount), "xsd:positiveInteger"))
				{	soap_flag_mpi__ProcessorCount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mpi__MPIApplicationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_mpi__MPIApplicationType, 0, sizeof(mpi__MPIApplicationType), 0, soap_copy_mpi__MPIApplicationType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mpi__ProcessorCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 mpi__MPIApplicationType * SOAP_FMAC6 soap_new_mpi__MPIApplicationType(struct soap *soap, int n)
{	return soap_instantiate_mpi__MPIApplicationType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_mpi__MPIApplicationType(struct soap *soap, mpi__MPIApplicationType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 mpi__MPIApplicationType * SOAP_FMAC4 soap_instantiate_mpi__MPIApplicationType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_mpi__MPIApplicationType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_mpi__MPIApplicationType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new mpi__MPIApplicationType;
		if (size)
			*size = sizeof(mpi__MPIApplicationType);
		((mpi__MPIApplicationType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new mpi__MPIApplicationType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(mpi__MPIApplicationType);
		for (int i = 0; i < n; i++)
			((mpi__MPIApplicationType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (mpi__MPIApplicationType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_mpi__MPIApplicationType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying mpi__MPIApplicationType %p -> %p\n", q, p));
	*(mpi__MPIApplicationType*)p = *(mpi__MPIApplicationType*)q;
}

void myproxy__MyProxyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->myproxy__MyProxyType::ProxyServer);
	this->myproxy__MyProxyType::ProxyServerDN = NULL;
	this->myproxy__MyProxyType::ProxyServerPort = NULL;
	soap_default_std__string(soap, &this->myproxy__MyProxyType::ProxyServerUserName);
	soap_default_std__string(soap, &this->myproxy__MyProxyType::ProxyServerPassPhrase);
	this->myproxy__MyProxyType::ProxyServerLifetime = NULL;
	/* transient soap skipped */
}

void myproxy__MyProxyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->myproxy__MyProxyType::ProxyServer, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->myproxy__MyProxyType::ProxyServer);
	soap_serialize_PointerTostd__string(soap, &this->myproxy__MyProxyType::ProxyServerDN);
	soap_serialize_PointerToint(soap, &this->myproxy__MyProxyType::ProxyServerPort);
	soap_embedded(soap, &this->myproxy__MyProxyType::ProxyServerUserName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->myproxy__MyProxyType::ProxyServerUserName);
	soap_embedded(soap, &this->myproxy__MyProxyType::ProxyServerPassPhrase, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->myproxy__MyProxyType::ProxyServerPassPhrase);
	soap_serialize_PointerToint(soap, &this->myproxy__MyProxyType::ProxyServerLifetime);
	/* transient soap skipped */
}

int myproxy__MyProxyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_myproxy__MyProxyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int myproxy__MyProxyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_myproxy__MyProxyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_myproxy__MyProxyType(struct soap *soap, const char *tag, int id, const myproxy__MyProxyType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_myproxy__MyProxyType), type))
		return soap->error;
	if (soap_out_std__string(soap, "myproxy:ProxyServer", -1, &(a->myproxy__MyProxyType::ProxyServer), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "myproxy:ProxyServerDN", -1, &(a->myproxy__MyProxyType::ProxyServerDN), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "myproxy:ProxyServerPort", -1, &(a->myproxy__MyProxyType::ProxyServerPort), ""))
		return soap->error;
	if (soap_out_std__string(soap, "myproxy:ProxyServerUserName", -1, &(a->myproxy__MyProxyType::ProxyServerUserName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "myproxy:ProxyServerPassPhrase", -1, &(a->myproxy__MyProxyType::ProxyServerPassPhrase), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "myproxy:ProxyServerLifetime", -1, &(a->myproxy__MyProxyType::ProxyServerLifetime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *myproxy__MyProxyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_myproxy__MyProxyType(soap, this, tag, type);
}

SOAP_FMAC3 myproxy__MyProxyType * SOAP_FMAC4 soap_get_myproxy__MyProxyType(struct soap *soap, myproxy__MyProxyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_myproxy__MyProxyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *myproxy__MyProxyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_myproxy__MyProxyType(soap, tag, this, type);
}

SOAP_FMAC3 myproxy__MyProxyType * SOAP_FMAC4 soap_in_myproxy__MyProxyType(struct soap *soap, const char *tag, myproxy__MyProxyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (myproxy__MyProxyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_myproxy__MyProxyType, sizeof(myproxy__MyProxyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_myproxy__MyProxyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (myproxy__MyProxyType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ProxyServer1 = 1;
	size_t soap_flag_ProxyServerDN1 = 1;
	size_t soap_flag_ProxyServerPort1 = 1;
	size_t soap_flag_ProxyServerUserName1 = 1;
	size_t soap_flag_ProxyServerPassPhrase1 = 1;
	size_t soap_flag_ProxyServerLifetime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProxyServer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "myproxy:ProxyServer", &(a->myproxy__MyProxyType::ProxyServer), "xsd:string"))
				{	soap_flag_ProxyServer1--;
					continue;
				}
			if (soap_flag_ProxyServerDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "myproxy:ProxyServerDN", &(a->myproxy__MyProxyType::ProxyServerDN), "xsd:string"))
				{	soap_flag_ProxyServerDN1--;
					continue;
				}
			if (soap_flag_ProxyServerPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "myproxy:ProxyServerPort", &(a->myproxy__MyProxyType::ProxyServerPort), "xsd:int"))
				{	soap_flag_ProxyServerPort1--;
					continue;
				}
			if (soap_flag_ProxyServerUserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "myproxy:ProxyServerUserName", &(a->myproxy__MyProxyType::ProxyServerUserName), "xsd:string"))
				{	soap_flag_ProxyServerUserName1--;
					continue;
				}
			if (soap_flag_ProxyServerPassPhrase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "myproxy:ProxyServerPassPhrase", &(a->myproxy__MyProxyType::ProxyServerPassPhrase), "xsd:string"))
				{	soap_flag_ProxyServerPassPhrase1--;
					continue;
				}
			if (soap_flag_ProxyServerLifetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "myproxy:ProxyServerLifetime", &(a->myproxy__MyProxyType::ProxyServerLifetime), "xsd:int"))
				{	soap_flag_ProxyServerLifetime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (myproxy__MyProxyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_myproxy__MyProxyType, 0, sizeof(myproxy__MyProxyType), 0, soap_copy_myproxy__MyProxyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProxyServer1 > 0 || soap_flag_ProxyServerUserName1 > 0 || soap_flag_ProxyServerPassPhrase1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 myproxy__MyProxyType * SOAP_FMAC6 soap_new_myproxy__MyProxyType(struct soap *soap, int n)
{	return soap_instantiate_myproxy__MyProxyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_myproxy__MyProxyType(struct soap *soap, myproxy__MyProxyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 myproxy__MyProxyType * SOAP_FMAC4 soap_instantiate_myproxy__MyProxyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_myproxy__MyProxyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_myproxy__MyProxyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new myproxy__MyProxyType;
		if (size)
			*size = sizeof(myproxy__MyProxyType);
		((myproxy__MyProxyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new myproxy__MyProxyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(myproxy__MyProxyType);
		for (int i = 0; i < n; i++)
			((myproxy__MyProxyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (myproxy__MyProxyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_myproxy__MyProxyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying myproxy__MyProxyType %p -> %p\n", q, p));
	*(myproxy__MyProxyType*)p = *(myproxy__MyProxyType*)q;
}

void jsdlposix__POSIXApplication_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument);
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment);
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::name = NULL;
	this->jsdlposix__POSIXApplication_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__POSIXApplication_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable);
	soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output);
	soap_serialize_PointerTojsdlposix__FileName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error);
	soap_serialize_PointerTojsdlposix__DirectoryName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory);
	soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit);
	soap_serialize_PointerTojsdlposix__Limits_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit);
	soap_serialize_PointerTojsdlposix__UserName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName);
	soap_serialize_PointerTojsdlposix__GroupName_USCOREType(soap, &this->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName);
	/* transient soap skipped */
}

int jsdlposix__POSIXApplication_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__POSIXApplication_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__POSIXApplication_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__POSIXApplication_USCOREType *a, const char *type)
{
	if (((jsdlposix__POSIXApplication_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((jsdlposix__POSIXApplication_USCOREType*)a)->name->c_str());
	if (((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Executable", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, "jsdlposix:Argument", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Input", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Output", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Error", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__DirectoryName_USCOREType(soap, "jsdlposix:WorkingDirectory", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, "jsdlposix:Environment", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:WallTimeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:FileSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CoreDumpLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:DataSegmentLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:LockedMemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:MemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:OpenDescriptorsLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:PipeSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:StackSizeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CPUTimeLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ProcessCountLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:VirtualMemoryLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ThreadCountLimit", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__UserName_USCOREType(soap, "jsdlposix:UserName", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName), ""))
		return soap->error;
	if (soap_out_PointerTojsdlposix__GroupName_USCOREType(soap, "jsdlposix:GroupName", -1, &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdlposix__POSIXApplication_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__POSIXApplication_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, jsdlposix__POSIXApplication_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__POSIXApplication_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__POSIXApplication_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__POSIXApplication_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, const char *tag, jsdlposix__POSIXApplication_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdlposix__POSIXApplication_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType, sizeof(jsdlposix__POSIXApplication_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdlposix__POSIXApplication_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdlposix__POSIXApplication_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((jsdlposix__POSIXApplication_USCOREType*)a)->name->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__POSIXApplication_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdlposix__Executable1 = 1;
	size_t soap_flag_jsdlposix__Input1 = 1;
	size_t soap_flag_jsdlposix__Output1 = 1;
	size_t soap_flag_jsdlposix__Error1 = 1;
	size_t soap_flag_jsdlposix__WorkingDirectory1 = 1;
	size_t soap_flag_jsdlposix__WallTimeLimit1 = 1;
	size_t soap_flag_jsdlposix__FileSizeLimit1 = 1;
	size_t soap_flag_jsdlposix__CoreDumpLimit1 = 1;
	size_t soap_flag_jsdlposix__DataSegmentLimit1 = 1;
	size_t soap_flag_jsdlposix__LockedMemoryLimit1 = 1;
	size_t soap_flag_jsdlposix__MemoryLimit1 = 1;
	size_t soap_flag_jsdlposix__OpenDescriptorsLimit1 = 1;
	size_t soap_flag_jsdlposix__PipeSizeLimit1 = 1;
	size_t soap_flag_jsdlposix__StackSizeLimit1 = 1;
	size_t soap_flag_jsdlposix__CPUTimeLimit1 = 1;
	size_t soap_flag_jsdlposix__ProcessCountLimit1 = 1;
	size_t soap_flag_jsdlposix__VirtualMemoryLimit1 = 1;
	size_t soap_flag_jsdlposix__ThreadCountLimit1 = 1;
	size_t soap_flag_jsdlposix__UserName1 = 1;
	size_t soap_flag_jsdlposix__GroupName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdlposix__Executable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Executable", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Executable), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Executable1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, "jsdlposix:Argument", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Argument), "jsdlposix:Argument_Type"))
					continue;
			if (soap_flag_jsdlposix__Input1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Input", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Input), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Input1--;
					continue;
				}
			if (soap_flag_jsdlposix__Output1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Output", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Output), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Output1--;
					continue;
				}
			if (soap_flag_jsdlposix__Error1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__FileName_USCOREType(soap, "jsdlposix:Error", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Error), "jsdlposix:FileName_Type"))
				{	soap_flag_jsdlposix__Error1--;
					continue;
				}
			if (soap_flag_jsdlposix__WorkingDirectory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__DirectoryName_USCOREType(soap, "jsdlposix:WorkingDirectory", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WorkingDirectory), "jsdlposix:DirectoryName_Type"))
				{	soap_flag_jsdlposix__WorkingDirectory1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, "jsdlposix:Environment", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__Environment), "jsdlposix:Environment_Type"))
					continue;
			if (soap_flag_jsdlposix__WallTimeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:WallTimeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__WallTimeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__WallTimeLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__FileSizeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:FileSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__FileSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__FileSizeLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__CoreDumpLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CoreDumpLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CoreDumpLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__CoreDumpLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__DataSegmentLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:DataSegmentLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__DataSegmentLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__DataSegmentLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__LockedMemoryLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:LockedMemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__LockedMemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__LockedMemoryLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__MemoryLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:MemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__MemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__MemoryLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__OpenDescriptorsLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:OpenDescriptorsLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__OpenDescriptorsLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__OpenDescriptorsLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__PipeSizeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:PipeSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__PipeSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__PipeSizeLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__StackSizeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:StackSizeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__StackSizeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__StackSizeLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__CPUTimeLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:CPUTimeLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__CPUTimeLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__CPUTimeLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__ProcessCountLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ProcessCountLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ProcessCountLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__ProcessCountLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__VirtualMemoryLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:VirtualMemoryLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__VirtualMemoryLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__VirtualMemoryLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__ThreadCountLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__Limits_USCOREType(soap, "jsdlposix:ThreadCountLimit", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__ThreadCountLimit), "jsdlposix:Limits_Type"))
				{	soap_flag_jsdlposix__ThreadCountLimit1--;
					continue;
				}
			if (soap_flag_jsdlposix__UserName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__UserName_USCOREType(soap, "jsdlposix:UserName", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__UserName), "jsdlposix:UserName_Type"))
				{	soap_flag_jsdlposix__UserName1--;
					continue;
				}
			if (soap_flag_jsdlposix__GroupName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdlposix__GroupName_USCOREType(soap, "jsdlposix:GroupName", &(a->jsdlposix__POSIXApplication_USCOREType::jsdlposix__GroupName), "jsdlposix:GroupName_Type"))
				{	soap_flag_jsdlposix__GroupName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdlposix__POSIXApplication_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType, 0, sizeof(jsdlposix__POSIXApplication_USCOREType), 0, soap_copy_jsdlposix__POSIXApplication_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdlposix__POSIXApplication_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__POSIXApplication_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, jsdlposix__POSIXApplication_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__POSIXApplication_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__POSIXApplication_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__POSIXApplication_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "mpi:MPIApplicationType"))
	{	cp->type = SOAP_TYPE_mpi__MPIApplicationType;
		if (n < 0)
		{	cp->ptr = (void*)new mpi__MPIApplicationType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(mpi__MPIApplicationType);
			((mpi__MPIApplicationType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new mpi__MPIApplicationType[n];
			if (size)
				*size = n * sizeof(mpi__MPIApplicationType);
			for (int i = 0; i < n; i++)
				((mpi__MPIApplicationType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (mpi__MPIApplicationType*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__POSIXApplication_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__POSIXApplication_USCOREType);
		((jsdlposix__POSIXApplication_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__POSIXApplication_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__POSIXApplication_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__POSIXApplication_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__POSIXApplication_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__POSIXApplication_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__POSIXApplication_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__POSIXApplication_USCOREType*)p = *(jsdlposix__POSIXApplication_USCOREType*)q;
}

void jsdlposix__GroupName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__GroupName_USCOREType::__item);
	this->jsdlposix__GroupName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__GroupName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__GroupName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__GroupName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__GroupName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__GroupName_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__GroupName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__GroupName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__GroupName_USCOREType *a, const char *type)
{
	if (((jsdlposix__GroupName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__GroupName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__GroupName_USCOREType::__item, "");
}

void *jsdlposix__GroupName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__GroupName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__GroupName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__GroupName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, jsdlposix__GroupName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__GroupName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__GroupName_USCOREType, sizeof(jsdlposix__GroupName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__GroupName_USCOREType)
			return (jsdlposix__GroupName_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__GroupName_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__GroupName_USCOREType::__item), "jsdlposix:GroupName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdlposix__GroupName_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__GroupName_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__GroupName_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__GroupName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__GroupName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__GroupName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__GroupName_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__GroupName_USCOREType);
		((jsdlposix__GroupName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__GroupName_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__GroupName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__GroupName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__GroupName_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__GroupName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__GroupName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__GroupName_USCOREType*)p = *(jsdlposix__GroupName_USCOREType*)q;
}

void jsdlposix__UserName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__UserName_USCOREType::__item);
	this->jsdlposix__UserName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__UserName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__UserName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__UserName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__UserName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__UserName_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__UserName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__UserName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__UserName_USCOREType *a, const char *type)
{
	if (((jsdlposix__UserName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__UserName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__UserName_USCOREType::__item, "");
}

void *jsdlposix__UserName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__UserName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__UserName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__UserName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, jsdlposix__UserName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__UserName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__UserName_USCOREType, sizeof(jsdlposix__UserName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__UserName_USCOREType)
			return (jsdlposix__UserName_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__UserName_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__UserName_USCOREType::__item), "jsdlposix:UserName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdlposix__UserName_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__UserName_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__UserName_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__UserName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__UserName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__UserName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__UserName_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__UserName_USCOREType);
		((jsdlposix__UserName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__UserName_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__UserName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__UserName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__UserName_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__UserName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__UserName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__UserName_USCOREType*)p = *(jsdlposix__UserName_USCOREType*)q;
}

void jsdlposix__Limits_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__nonNegativeInteger(soap, &this->jsdlposix__Limits_USCOREType::__item);
	this->jsdlposix__Limits_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__Limits_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__nonNegativeInteger(soap, &this->jsdlposix__Limits_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__Limits_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__Limits_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__Limits_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__Limits_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__Limits_USCOREType *a, const char *type)
{
	if (((jsdlposix__Limits_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__Limits_USCOREType*)a)->__anyAttribute);
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->jsdlposix__Limits_USCOREType::__item, "");
}

void *jsdlposix__Limits_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__Limits_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__Limits_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__Limits_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, jsdlposix__Limits_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__Limits_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__Limits_USCOREType, sizeof(jsdlposix__Limits_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__Limits_USCOREType)
			return (jsdlposix__Limits_USCOREType *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__Limits_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &(a->jsdlposix__Limits_USCOREType::__item), "jsdlposix:Limits_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdlposix__Limits_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__Limits_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__Limits_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__Limits_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__Limits_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__Limits_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__Limits_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__Limits_USCOREType);
		((jsdlposix__Limits_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__Limits_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__Limits_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__Limits_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__Limits_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__Limits_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__Limits_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__Limits_USCOREType*)p = *(jsdlposix__Limits_USCOREType*)q;
}

void jsdlposix__DirectoryName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__DirectoryName_USCOREType::__item);
	this->jsdlposix__DirectoryName_USCOREType::filesystemName = NULL;
	this->jsdlposix__DirectoryName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__DirectoryName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__DirectoryName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__DirectoryName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__DirectoryName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__DirectoryName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__DirectoryName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__DirectoryName_USCOREType *a, const char *type)
{
	if (((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__DirectoryName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__DirectoryName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__DirectoryName_USCOREType::__item, "");
}

void *jsdlposix__DirectoryName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__DirectoryName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__DirectoryName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__DirectoryName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, jsdlposix__DirectoryName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__DirectoryName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType, sizeof(jsdlposix__DirectoryName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__DirectoryName_USCOREType)
			return (jsdlposix__DirectoryName_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__DirectoryName_USCOREType*)a)->filesystemName->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__DirectoryName_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__DirectoryName_USCOREType::__item), "jsdlposix:DirectoryName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdlposix__DirectoryName_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__DirectoryName_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__DirectoryName_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__DirectoryName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__DirectoryName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__DirectoryName_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__DirectoryName_USCOREType);
		((jsdlposix__DirectoryName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__DirectoryName_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__DirectoryName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__DirectoryName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__DirectoryName_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__DirectoryName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__DirectoryName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__DirectoryName_USCOREType*)p = *(jsdlposix__DirectoryName_USCOREType*)q;
}

void jsdlposix__FileName_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__FileName_USCOREType::__item);
	this->jsdlposix__FileName_USCOREType::filesystemName = NULL;
	this->jsdlposix__FileName_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__FileName_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__FileName_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__FileName_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__FileName_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__FileName_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__FileName_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__FileName_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__FileName_USCOREType *a, const char *type)
{
	if (((jsdlposix__FileName_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__FileName_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__FileName_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__FileName_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__FileName_USCOREType::__item, "");
}

void *jsdlposix__FileName_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__FileName_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__FileName_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__FileName_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, jsdlposix__FileName_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__FileName_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__FileName_USCOREType, sizeof(jsdlposix__FileName_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__FileName_USCOREType)
			return (jsdlposix__FileName_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdlposix__FileName_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__FileName_USCOREType*)a)->filesystemName->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__FileName_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__FileName_USCOREType::__item), "jsdlposix:FileName_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdlposix__FileName_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__FileName_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__FileName_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__FileName_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__FileName_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__FileName_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__FileName_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__FileName_USCOREType);
		((jsdlposix__FileName_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__FileName_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__FileName_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__FileName_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__FileName_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__FileName_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__FileName_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__FileName_USCOREType*)p = *(jsdlposix__FileName_USCOREType*)q;
}

void jsdlposix__Argument_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__normalizedString(soap, &this->jsdlposix__Argument_USCOREType::__item);
	this->jsdlposix__Argument_USCOREType::filesystemName = NULL;
	this->jsdlposix__Argument_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__Argument_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__normalizedString(soap, &this->jsdlposix__Argument_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__Argument_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__Argument_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__Argument_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__Argument_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__Argument_USCOREType *a, const char *type)
{
	if (((jsdlposix__Argument_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__Argument_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__Argument_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__Argument_USCOREType*)a)->__anyAttribute);
	return soap_out_xsd__normalizedString(soap, tag, id, &a->jsdlposix__Argument_USCOREType::__item, "");
}

void *jsdlposix__Argument_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__Argument_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__Argument_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__Argument_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, jsdlposix__Argument_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__Argument_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__Argument_USCOREType, sizeof(jsdlposix__Argument_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__Argument_USCOREType)
			return (jsdlposix__Argument_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdlposix__Argument_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__Argument_USCOREType*)a)->filesystemName->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__Argument_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_xsd__normalizedString(soap, tag, &(a->jsdlposix__Argument_USCOREType::__item), "jsdlposix:Argument_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdlposix__Argument_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__Argument_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__Argument_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__Argument_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__Argument_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__Argument_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__Argument_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__Argument_USCOREType);
		((jsdlposix__Argument_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__Argument_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__Argument_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__Argument_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__Argument_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__Argument_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__Argument_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__Argument_USCOREType*)p = *(jsdlposix__Argument_USCOREType*)q;
}

void jsdlposix__Environment_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdlposix__Environment_USCOREType::__item);
	soap_default_xsd__NCName(soap, &this->jsdlposix__Environment_USCOREType::name);
	this->jsdlposix__Environment_USCOREType::filesystemName = NULL;
	this->jsdlposix__Environment_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdlposix__Environment_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdlposix__Environment_USCOREType::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdlposix__Environment_USCOREType::__item);
	/* transient soap skipped */
}

int jsdlposix__Environment_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdlposix__Environment_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdlposix__Environment_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdlposix__Environment_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, int id, const jsdlposix__Environment_USCOREType *a, const char *type)
{
	if (!((jsdlposix__Environment_USCOREType*)a)->name.empty())
		soap_set_attr(soap, "name", ((jsdlposix__Environment_USCOREType*)a)->name.c_str());
	if (((jsdlposix__Environment_USCOREType*)a)->filesystemName)
		soap_set_attr(soap, "filesystemName", ((jsdlposix__Environment_USCOREType*)a)->filesystemName->c_str());
	if (((jsdlposix__Environment_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdlposix__Environment_USCOREType*)a)->__anyAttribute);
	return soap_out_std__string(soap, tag, id, &a->jsdlposix__Environment_USCOREType::__item, "");
}

void *jsdlposix__Environment_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdlposix__Environment_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType * SOAP_FMAC4 soap_get_jsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdlposix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdlposix__Environment_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdlposix__Environment_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType * SOAP_FMAC4 soap_in_jsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, jsdlposix__Environment_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdlposix__Environment_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdlposix__Environment_USCOREType, sizeof(jsdlposix__Environment_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdlposix__Environment_USCOREType)
			return (jsdlposix__Environment_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((jsdlposix__Environment_USCOREType*)a)->name.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "filesystemName", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdlposix__Environment_USCOREType*)a)->filesystemName = soap_new_std__string(soap, -1);
				((jsdlposix__Environment_USCOREType*)a)->filesystemName->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdlposix__Environment_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_std__string(soap, tag, &(a->jsdlposix__Environment_USCOREType::__item), "jsdlposix:Environment_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdlposix__Environment_USCOREType * SOAP_FMAC6 soap_new_jsdlposix__Environment_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdlposix__Environment_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType * SOAP_FMAC4 soap_instantiate_jsdlposix__Environment_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdlposix__Environment_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdlposix__Environment_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdlposix__Environment_USCOREType;
		if (size)
			*size = sizeof(jsdlposix__Environment_USCOREType);
		((jsdlposix__Environment_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdlposix__Environment_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdlposix__Environment_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdlposix__Environment_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdlposix__Environment_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdlposix__Environment_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdlposix__Environment_USCOREType %p -> %p\n", q, p));
	*(jsdlposix__Environment_USCOREType*)p = *(jsdlposix__Environment_USCOREType*)q;
}

void jsdl__SourceTarget_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__SourceTarget_USCOREType::jsdl__URI = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	this->jsdl__SourceTarget_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__SourceTarget_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyURI(soap, &this->jsdl__SourceTarget_USCOREType::jsdl__URI);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__SourceTarget_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__SourceTarget_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__SourceTarget_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__SourceTarget_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "jsdl:URI", -1, &(a->jsdl__SourceTarget_USCOREType::jsdl__URI), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__SourceTarget_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__SourceTarget_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__SourceTarget_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_get_jsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__SourceTarget_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__SourceTarget_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_in_jsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__SourceTarget_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__SourceTarget_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__SourceTarget_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__SourceTarget_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__URI1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__anyURI(soap, "jsdl:URI", &(a->jsdl__SourceTarget_USCOREType::jsdl__URI), "xsd:anyURI"))
				{	soap_flag_jsdl__URI1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__SourceTarget_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__SourceTarget_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__SourceTarget_USCOREType, 0, sizeof(jsdl__SourceTarget_USCOREType), 0, soap_copy_jsdl__SourceTarget_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__SourceTarget_USCOREType * SOAP_FMAC6 soap_new_jsdl__SourceTarget_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__SourceTarget_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__SourceTarget_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__SourceTarget_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__SourceTarget_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType;
		if (size)
			*size = sizeof(jsdl__SourceTarget_USCOREType);
		((jsdl__SourceTarget_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__SourceTarget_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__SourceTarget_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__SourceTarget_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__SourceTarget_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__SourceTarget_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__SourceTarget_USCOREType %p -> %p\n", q, p));
	*(jsdl__SourceTarget_USCOREType*)p = *(jsdl__SourceTarget_USCOREType*)q;
}

void jsdl__DataStaging_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName);
	this->jsdl__DataStaging_USCOREType::jsdl__FilesystemName = NULL;
	soap_default_jsdl__CreationFlagEnumeration(soap, &this->jsdl__DataStaging_USCOREType::jsdl__CreationFlag);
	this->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination = NULL;
	this->jsdl__DataStaging_USCOREType::jsdl__Source = NULL;
	this->jsdl__DataStaging_USCOREType::jsdl__Target = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	this->jsdl__DataStaging_USCOREType::name = NULL;
	this->jsdl__DataStaging_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__DataStaging_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FileName);
	soap_serialize_PointerToxsd__NCName(soap, &this->jsdl__DataStaging_USCOREType::jsdl__FilesystemName);
	soap_serialize_PointerTobool(soap, &this->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::jsdl__Source);
	soap_serialize_PointerTojsdl__SourceTarget_USCOREType(soap, &this->jsdl__DataStaging_USCOREType::jsdl__Target);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__DataStaging_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__DataStaging_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__DataStaging_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__DataStaging_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (((jsdl__DataStaging_USCOREType*)a)->name)
		soap_set_attr(soap, "name", ((jsdl__DataStaging_USCOREType*)a)->name->c_str());
	if (((jsdl__DataStaging_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__DataStaging_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType), type))
		return soap->error;
	if (soap_out_std__string(soap, "jsdl:FileName", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__FileName), ""))
		return soap->error;
	if (soap_out_PointerToxsd__NCName(soap, "jsdl:FilesystemName", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__FilesystemName), ""))
		return soap->error;
	if (soap_out_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__CreationFlag), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "jsdl:DeleteOnTermination", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__Source), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", -1, &(a->jsdl__DataStaging_USCOREType::jsdl__Target), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__DataStaging_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__DataStaging_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__DataStaging_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_get_jsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__DataStaging_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__DataStaging_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_in_jsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__DataStaging_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__DataStaging_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__DataStaging_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdl__DataStaging_USCOREType*)a)->name = soap_new_std__string(soap, -1);
				((jsdl__DataStaging_USCOREType*)a)->name->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__DataStaging_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__FileName1 = 1;
	size_t soap_flag_jsdl__FilesystemName1 = 1;
	size_t soap_flag_jsdl__CreationFlag1 = 1;
	size_t soap_flag_jsdl__DeleteOnTermination1 = 1;
	size_t soap_flag_jsdl__Source1 = 1;
	size_t soap_flag_jsdl__Target1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "jsdl:FileName", &(a->jsdl__DataStaging_USCOREType::jsdl__FileName), "xsd:string"))
				{	soap_flag_jsdl__FileName1--;
					continue;
				}
			if (soap_flag_jsdl__FilesystemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__NCName(soap, "jsdl:FilesystemName", &(a->jsdl__DataStaging_USCOREType::jsdl__FilesystemName), "xsd:NCName"))
				{	soap_flag_jsdl__FilesystemName1--;
					continue;
				}
			if (soap_flag_jsdl__CreationFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__CreationFlagEnumeration(soap, "jsdl:CreationFlag", &(a->jsdl__DataStaging_USCOREType::jsdl__CreationFlag), "jsdl:CreationFlagEnumeration"))
				{	soap_flag_jsdl__CreationFlag1--;
					continue;
				}
			if (soap_flag_jsdl__DeleteOnTermination1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "jsdl:DeleteOnTermination", &(a->jsdl__DataStaging_USCOREType::jsdl__DeleteOnTermination), "xsd:boolean"))
				{	soap_flag_jsdl__DeleteOnTermination1--;
					continue;
				}
			if (soap_flag_jsdl__Source1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Source", &(a->jsdl__DataStaging_USCOREType::jsdl__Source), "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Source1--;
					continue;
				}
			if (soap_flag_jsdl__Target1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, "jsdl:Target", &(a->jsdl__DataStaging_USCOREType::jsdl__Target), "jsdl:SourceTarget_Type"))
				{	soap_flag_jsdl__Target1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__DataStaging_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__DataStaging_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__DataStaging_USCOREType, 0, sizeof(jsdl__DataStaging_USCOREType), 0, soap_copy_jsdl__DataStaging_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__FileName1 > 0 || soap_flag_jsdl__CreationFlag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__DataStaging_USCOREType * SOAP_FMAC6 soap_new_jsdl__DataStaging_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__DataStaging_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType;
		if (size)
			*size = sizeof(jsdl__DataStaging_USCOREType);
		((jsdl__DataStaging_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__DataStaging_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__DataStaging_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__DataStaging_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__DataStaging_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__DataStaging_USCOREType %p -> %p\n", q, p));
	*(jsdl__DataStaging_USCOREType*)p = *(jsdl__DataStaging_USCOREType*)q;
}

void jsdl__OperatingSystemType_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__OperatingSystemTypeEnumeration(soap, &this->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	this->jsdl__OperatingSystemType_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystemType_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystemType_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystemType_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__OperatingSystemType_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystemType_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", -1, &(a->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystemType_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystemType_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__OperatingSystemType_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystemType_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystemType_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__OperatingSystemType_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystemType_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystemType_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__OperatingSystemName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__OperatingSystemTypeEnumeration(soap, "jsdl:OperatingSystemName", &(a->jsdl__OperatingSystemType_USCOREType::jsdl__OperatingSystemName), "jsdl:OperatingSystemTypeEnumeration"))
				{	soap_flag_jsdl__OperatingSystemName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystemType_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystemType_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, 0, sizeof(jsdl__OperatingSystemType_USCOREType), 0, soap_copy_jsdl__OperatingSystemType_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__OperatingSystemName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC6 soap_new_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystemType_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType;
		if (size)
			*size = sizeof(jsdl__OperatingSystemType_USCOREType);
		((jsdl__OperatingSystemType_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__OperatingSystemType_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystemType_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystemType_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystemType_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystemType_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystemType_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystemType_USCOREType*)p = *(jsdl__OperatingSystemType_USCOREType*)q;
}

void jsdl__OperatingSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType = NULL;
	this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion = NULL;
	this->jsdl__OperatingSystem_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	this->jsdl__OperatingSystem_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__OperatingSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__OperatingSystem_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__OperatingSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__OperatingSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__OperatingSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__OperatingSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:OperatingSystemVersion", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__OperatingSystem_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__OperatingSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__OperatingSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__OperatingSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__OperatingSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__OperatingSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__OperatingSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__OperatingSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__OperatingSystem_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__OperatingSystemType1 = 1;
	size_t soap_flag_jsdl__OperatingSystemVersion1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__OperatingSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, "jsdl:OperatingSystemType", &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemType), "jsdl:OperatingSystemType_Type"))
				{	soap_flag_jsdl__OperatingSystemType1--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystemVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:OperatingSystemVersion", &(a->jsdl__OperatingSystem_USCOREType::jsdl__OperatingSystemVersion), "xsd:string"))
				{	soap_flag_jsdl__OperatingSystemVersion1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__OperatingSystem_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__OperatingSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__OperatingSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, 0, sizeof(jsdl__OperatingSystem_USCOREType), 0, soap_copy_jsdl__OperatingSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__OperatingSystem_USCOREType * SOAP_FMAC6 soap_new_jsdl__OperatingSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__OperatingSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__OperatingSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType;
		if (size)
			*size = sizeof(jsdl__OperatingSystem_USCOREType);
		((jsdl__OperatingSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__OperatingSystem_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__OperatingSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__OperatingSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__OperatingSystem_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__OperatingSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__OperatingSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__OperatingSystem_USCOREType*)p = *(jsdl__OperatingSystem_USCOREType*)q;
}

void jsdl__FileSystem_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__FileSystem_USCOREType::jsdl__FileSystemType = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__Description = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__MountPoint = NULL;
	this->jsdl__FileSystem_USCOREType::jsdl__DiskSpace = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	soap_default_xsd__NCName(soap, &this->jsdl__FileSystem_USCOREType::name);
	this->jsdl__FileSystem_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__FileSystem_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(soap, &this->jsdl__FileSystem_USCOREType::jsdl__FileSystemType);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::jsdl__Description);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__FileSystem_USCOREType::jsdl__MountPoint);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__FileSystem_USCOREType::jsdl__DiskSpace);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__FileSystem_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__FileSystem_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__FileSystem_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__FileSystem_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (!((jsdl__FileSystem_USCOREType*)a)->name.empty())
		soap_set_attr(soap, "name", ((jsdl__FileSystem_USCOREType*)a)->name.c_str());
	if (((jsdl__FileSystem_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__FileSystem_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__FileSystemType), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:MountPoint", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__MountPoint), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", -1, &(a->jsdl__FileSystem_USCOREType::jsdl__DiskSpace), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__FileSystem_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__FileSystem_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__FileSystem_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_get_jsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__FileSystem_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__FileSystem_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_in_jsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__FileSystem_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__FileSystem_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__FileSystem_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((jsdl__FileSystem_USCOREType*)a)->name.assign(s);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__FileSystem_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__FileSystemType1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	size_t soap_flag_jsdl__MountPoint1 = 1;
	size_t soap_flag_jsdl__DiskSpace1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__FileSystemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, "jsdl:FileSystemType", &(a->jsdl__FileSystem_USCOREType::jsdl__FileSystemType), "jsdl:FileSystemTypeEnumeration"))
				{	soap_flag_jsdl__FileSystemType1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__FileSystem_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap_flag_jsdl__MountPoint1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:MountPoint", &(a->jsdl__FileSystem_USCOREType::jsdl__MountPoint), "xsd:string"))
				{	soap_flag_jsdl__MountPoint1--;
					continue;
				}
			if (soap_flag_jsdl__DiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:DiskSpace", &(a->jsdl__FileSystem_USCOREType::jsdl__DiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__DiskSpace1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__FileSystem_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__FileSystem_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__FileSystem_USCOREType, 0, sizeof(jsdl__FileSystem_USCOREType), 0, soap_copy_jsdl__FileSystem_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__FileSystem_USCOREType * SOAP_FMAC6 soap_new_jsdl__FileSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__FileSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType;
		if (size)
			*size = sizeof(jsdl__FileSystem_USCOREType);
		((jsdl__FileSystem_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__FileSystem_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__FileSystem_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__FileSystem_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__FileSystem_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__FileSystem_USCOREType %p -> %p\n", q, p));
	*(jsdl__FileSystem_USCOREType*)p = *(jsdl__FileSystem_USCOREType*)q;
}

void jsdl__CPUArchitecture_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_jsdl__ProcessorArchitectureEnumeration(soap, &this->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	this->jsdl__CPUArchitecture_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__CPUArchitecture_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__CPUArchitecture_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__CPUArchitecture_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__CPUArchitecture_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CPUArchitecture_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType), type))
		return soap->error;
	if (soap_out_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", -1, &(a->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__CPUArchitecture_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CPUArchitecture_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_get_jsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__CPUArchitecture_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CPUArchitecture_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_in_jsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CPUArchitecture_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__CPUArchitecture_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CPUArchitecture_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__CPUArchitecture_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__CPUArchitectureName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CPUArchitectureName1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_jsdl__ProcessorArchitectureEnumeration(soap, "jsdl:CPUArchitectureName", &(a->jsdl__CPUArchitecture_USCOREType::jsdl__CPUArchitectureName), "jsdl:ProcessorArchitectureEnumeration"))
				{	soap_flag_jsdl__CPUArchitectureName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__CPUArchitecture_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CPUArchitecture_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, 0, sizeof(jsdl__CPUArchitecture_USCOREType), 0, soap_copy_jsdl__CPUArchitecture_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__CPUArchitectureName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC6 soap_new_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CPUArchitecture_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType;
		if (size)
			*size = sizeof(jsdl__CPUArchitecture_USCOREType);
		((jsdl__CPUArchitecture_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__CPUArchitecture_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CPUArchitecture_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CPUArchitecture_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CPUArchitecture_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CPUArchitecture_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CPUArchitecture_USCOREType %p -> %p\n", q, p));
	*(jsdl__CPUArchitecture_USCOREType*)p = *(jsdl__CPUArchitecture_USCOREType*)q;
}

void jsdl__CandidateHosts_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::jsdl__HostName);
	/* transient soap skipped */
}

void jsdl__CandidateHosts_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__CandidateHosts_USCOREType::jsdl__HostName);
	/* transient soap skipped */
}

int jsdl__CandidateHosts_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__CandidateHosts_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__CandidateHosts_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:HostName", -1, &(a->jsdl__CandidateHosts_USCOREType::jsdl__HostName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__CandidateHosts_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__CandidateHosts_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_get_jsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__CandidateHosts_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__CandidateHosts_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_in_jsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__CandidateHosts_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__CandidateHosts_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__CandidateHosts_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:HostName", &(a->jsdl__CandidateHosts_USCOREType::jsdl__HostName), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__CandidateHosts_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, 0, sizeof(jsdl__CandidateHosts_USCOREType), 0, soap_copy_jsdl__CandidateHosts_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__CandidateHosts_USCOREType * SOAP_FMAC6 soap_new_jsdl__CandidateHosts_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__CandidateHosts_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__CandidateHosts_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType;
		if (size)
			*size = sizeof(jsdl__CandidateHosts_USCOREType);
		((jsdl__CandidateHosts_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__CandidateHosts_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__CandidateHosts_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__CandidateHosts_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__CandidateHosts_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__CandidateHosts_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__CandidateHosts_USCOREType %p -> %p\n", q, p));
	*(jsdl__CandidateHosts_USCOREType*)p = *(jsdl__CandidateHosts_USCOREType*)q;
}

void jsdl__Resources_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Resources_USCOREType::jsdl__CandidateHosts = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__FileSystem);
	this->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution = NULL;
	this->jsdl__Resources_USCOREType::jsdl__OperatingSystem = NULL;
	this->jsdl__Resources_USCOREType::jsdl__CPUArchitecture = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalCPUTime = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalCPUCount = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace = NULL;
	this->jsdl__Resources_USCOREType::jsdl__TotalResourceCount = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	this->jsdl__Resources_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Resources_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__CandidateHosts);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__FileSystem);
	soap_serialize_PointerTobool(soap, &this->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution);
	soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__OperatingSystem);
	soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__CPUArchitecture);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalCPUTime);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalCPUCount);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace);
	soap_serialize_PointerTojsdl__RangeValue_USCOREType(soap, &this->jsdl__Resources_USCOREType::jsdl__TotalResourceCount);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Resources_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Resources_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Resources_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Resources_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Resources_USCOREType *a, const char *type)
{
	if (((jsdl__Resources_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Resources_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Resources_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", -1, &(a->jsdl__Resources_USCOREType::jsdl__CandidateHosts), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", -1, &(a->jsdl__Resources_USCOREType::jsdl__FileSystem), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "jsdl:ExclusiveExecution", -1, &(a->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", -1, &(a->jsdl__Resources_USCOREType::jsdl__OperatingSystem), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", -1, &(a->jsdl__Resources_USCOREType::jsdl__CPUArchitecture), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", -1, &(a->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUTime), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUCount), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", -1, &(a->jsdl__Resources_USCOREType::jsdl__TotalResourceCount), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Resources_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Resources_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Resources_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_get_jsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Resources_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Resources_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_in_jsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Resources_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Resources_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Resources_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Resources_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__CandidateHosts1 = 1;
	size_t soap_flag_jsdl__ExclusiveExecution1 = 1;
	size_t soap_flag_jsdl__OperatingSystem1 = 1;
	size_t soap_flag_jsdl__CPUArchitecture1 = 1;
	size_t soap_flag_jsdl__IndividualCPUSpeed1 = 1;
	size_t soap_flag_jsdl__IndividualCPUTime1 = 1;
	size_t soap_flag_jsdl__IndividualCPUCount1 = 1;
	size_t soap_flag_jsdl__IndividualNetworkBandwidth1 = 1;
	size_t soap_flag_jsdl__IndividualPhysicalMemory1 = 1;
	size_t soap_flag_jsdl__IndividualVirtualMemory1 = 1;
	size_t soap_flag_jsdl__IndividualDiskSpace1 = 1;
	size_t soap_flag_jsdl__TotalCPUTime1 = 1;
	size_t soap_flag_jsdl__TotalCPUCount1 = 1;
	size_t soap_flag_jsdl__TotalPhysicalMemory1 = 1;
	size_t soap_flag_jsdl__TotalVirtualMemory1 = 1;
	size_t soap_flag_jsdl__TotalDiskSpace1 = 1;
	size_t soap_flag_jsdl__TotalResourceCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__CandidateHosts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, "jsdl:CandidateHosts", &(a->jsdl__Resources_USCOREType::jsdl__CandidateHosts), "jsdl:CandidateHosts_Type"))
				{	soap_flag_jsdl__CandidateHosts1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, "jsdl:FileSystem", &(a->jsdl__Resources_USCOREType::jsdl__FileSystem), "jsdl:FileSystem_Type"))
					continue;
			if (soap_flag_jsdl__ExclusiveExecution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "jsdl:ExclusiveExecution", &(a->jsdl__Resources_USCOREType::jsdl__ExclusiveExecution), "xsd:boolean"))
				{	soap_flag_jsdl__ExclusiveExecution1--;
					continue;
				}
			if (soap_flag_jsdl__OperatingSystem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, "jsdl:OperatingSystem", &(a->jsdl__Resources_USCOREType::jsdl__OperatingSystem), "jsdl:OperatingSystem_Type"))
				{	soap_flag_jsdl__OperatingSystem1--;
					continue;
				}
			if (soap_flag_jsdl__CPUArchitecture1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, "jsdl:CPUArchitecture", &(a->jsdl__Resources_USCOREType::jsdl__CPUArchitecture), "jsdl:CPUArchitecture_Type"))
				{	soap_flag_jsdl__CPUArchitecture1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUSpeed", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUSpeed), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUSpeed1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUTime", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUTime1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualCPUCount", &(a->jsdl__Resources_USCOREType::jsdl__IndividualCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualCPUCount1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualNetworkBandwidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualNetworkBandwidth", &(a->jsdl__Resources_USCOREType::jsdl__IndividualNetworkBandwidth), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualNetworkBandwidth1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualPhysicalMemory", &(a->jsdl__Resources_USCOREType::jsdl__IndividualPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualPhysicalMemory1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualVirtualMemory", &(a->jsdl__Resources_USCOREType::jsdl__IndividualVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualVirtualMemory1--;
					continue;
				}
			if (soap_flag_jsdl__IndividualDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:IndividualDiskSpace", &(a->jsdl__Resources_USCOREType::jsdl__IndividualDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__IndividualDiskSpace1--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUTime", &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUTime), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUTime1--;
					continue;
				}
			if (soap_flag_jsdl__TotalCPUCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalCPUCount", &(a->jsdl__Resources_USCOREType::jsdl__TotalCPUCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalCPUCount1--;
					continue;
				}
			if (soap_flag_jsdl__TotalPhysicalMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalPhysicalMemory", &(a->jsdl__Resources_USCOREType::jsdl__TotalPhysicalMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalPhysicalMemory1--;
					continue;
				}
			if (soap_flag_jsdl__TotalVirtualMemory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalVirtualMemory", &(a->jsdl__Resources_USCOREType::jsdl__TotalVirtualMemory), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalVirtualMemory1--;
					continue;
				}
			if (soap_flag_jsdl__TotalDiskSpace1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalDiskSpace", &(a->jsdl__Resources_USCOREType::jsdl__TotalDiskSpace), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalDiskSpace1--;
					continue;
				}
			if (soap_flag_jsdl__TotalResourceCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__RangeValue_USCOREType(soap, "jsdl:TotalResourceCount", &(a->jsdl__Resources_USCOREType::jsdl__TotalResourceCount), "jsdl:RangeValue_Type"))
				{	soap_flag_jsdl__TotalResourceCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Resources_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Resources_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Resources_USCOREType, 0, sizeof(jsdl__Resources_USCOREType), 0, soap_copy_jsdl__Resources_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Resources_USCOREType * SOAP_FMAC6 soap_new_jsdl__Resources_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Resources_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Resources_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Resources_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Resources_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Resources_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Resources_USCOREType;
		if (size)
			*size = sizeof(jsdl__Resources_USCOREType);
		((jsdl__Resources_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Resources_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Resources_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Resources_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Resources_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Resources_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Resources_USCOREType %p -> %p\n", q, p));
	*(jsdl__Resources_USCOREType*)p = *(jsdl__Resources_USCOREType*)q;
}

void jsdl__Application_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Application_USCOREType::jsdl__ApplicationName = NULL;
	this->jsdl__Application_USCOREType::jsdl__ApplicationVersion = NULL;
	this->jsdl__Application_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	this->jsdl__Application_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Application_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::jsdl__ApplicationName);
	soap_serialize_PointerTostd__string(soap, &this->jsdl__Application_USCOREType::jsdl__ApplicationVersion);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__Application_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__Application_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__Application_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Application_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Application_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Application_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Application_USCOREType *a, const char *type)
{
	if (((jsdl__Application_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Application_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Application_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:ApplicationName", -1, &(a->jsdl__Application_USCOREType::jsdl__ApplicationName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:ApplicationVersion", -1, &(a->jsdl__Application_USCOREType::jsdl__ApplicationVersion), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__Application_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__Application_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Application_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Application_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_get_jsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Application_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Application_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_in_jsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Application_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Application_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Application_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Application_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__ApplicationName1 = 1;
	size_t soap_flag_jsdl__ApplicationVersion1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__ApplicationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:ApplicationName", &(a->jsdl__Application_USCOREType::jsdl__ApplicationName), "xsd:string"))
				{	soap_flag_jsdl__ApplicationName1--;
					continue;
				}
			if (soap_flag_jsdl__ApplicationVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:ApplicationVersion", &(a->jsdl__Application_USCOREType::jsdl__ApplicationVersion), "xsd:string"))
				{	soap_flag_jsdl__ApplicationVersion1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__Application_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__Application_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Application_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Application_USCOREType, 0, sizeof(jsdl__Application_USCOREType), 0, soap_copy_jsdl__Application_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Application_USCOREType * SOAP_FMAC6 soap_new_jsdl__Application_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Application_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Application_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Application_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Application_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Application_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Application_USCOREType;
		if (size)
			*size = sizeof(jsdl__Application_USCOREType);
		((jsdl__Application_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Application_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Application_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Application_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Application_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Application_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Application_USCOREType %p -> %p\n", q, p));
	*(jsdl__Application_USCOREType*)p = *(jsdl__Application_USCOREType*)q;
}

void jsdl__JobIdentification_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobIdentification_USCOREType::jsdl__JobName = NULL;
	this->jsdl__JobIdentification_USCOREType::jsdl__Description = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobProject);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	this->jsdl__JobIdentification_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobIdentification_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobName);
	soap_serialize_PointerTojsdl__Description_USCOREType(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__Description);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->jsdl__JobIdentification_USCOREType::jsdl__JobProject);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobIdentification_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobIdentification_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobIdentification_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobIdentification_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "jsdl:JobName", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobName), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__Description), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:JobAnnotation", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "jsdl:JobProject", -1, &(a->jsdl__JobIdentification_USCOREType::jsdl__JobProject), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobIdentification_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobIdentification_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobIdentification_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobIdentification_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobIdentification_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobIdentification_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__JobIdentification_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobIdentification_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobIdentification_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__JobName1 = 1;
	size_t soap_flag_jsdl__Description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "jsdl:JobName", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobName), "xsd:string"))
				{	soap_flag_jsdl__JobName1--;
					continue;
				}
			if (soap_flag_jsdl__Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTojsdl__Description_USCOREType(soap, "jsdl:Description", &(a->jsdl__JobIdentification_USCOREType::jsdl__Description), "jsdl:Description_Type"))
				{	soap_flag_jsdl__Description1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:JobAnnotation", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobAnnotation), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "jsdl:JobProject", &(a->jsdl__JobIdentification_USCOREType::jsdl__JobProject), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobIdentification_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobIdentification_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobIdentification_USCOREType, 0, sizeof(jsdl__JobIdentification_USCOREType), 0, soap_copy_jsdl__JobIdentification_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobIdentification_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobIdentification_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobIdentification_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobIdentification_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobIdentification_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__JobIdentification_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobIdentification_USCOREType);
		((jsdl__JobIdentification_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobIdentification_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobIdentification_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobIdentification_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobIdentification_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobIdentification_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobIdentification_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobIdentification_USCOREType*)p = *(jsdl__JobIdentification_USCOREType*)q;
}

void jsdl__JobDescription_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDescription_USCOREType::jsdl__JobIdentification = NULL;
	this->jsdl__JobDescription_USCOREType::jsdl__Application = NULL;
	this->jsdl__JobDescription_USCOREType::jsdl__Resources = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__DataStaging);
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	this->jsdl__JobDescription_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobDescription_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobIdentification_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__JobIdentification);
	soap_serialize_PointerTojsdl__Application_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__Application);
	soap_serialize_PointerTojsdl__Resources_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__Resources);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, &this->jsdl__JobDescription_USCOREType::jsdl__DataStaging);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDescription_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDescription_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobDescription_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDescription_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (((jsdl__JobDescription_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDescription_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__JobIdentification), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__Application), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__Resources), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", -1, &(a->jsdl__JobDescription_USCOREType::jsdl__DataStaging), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDescription_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDescription_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDescription_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobDescription_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDescription_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDescription_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__JobDescription_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDescription_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDescription_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__JobIdentification1 = 1;
	size_t soap_flag_jsdl__Application1 = 1;
	size_t soap_flag_jsdl__Resources1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobIdentification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, "jsdl:JobIdentification", &(a->jsdl__JobDescription_USCOREType::jsdl__JobIdentification), "jsdl:JobIdentification_Type"))
				{	soap_flag_jsdl__JobIdentification1--;
					continue;
				}
			if (soap_flag_jsdl__Application1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Application_USCOREType(soap, "jsdl:Application", &(a->jsdl__JobDescription_USCOREType::jsdl__Application), "jsdl:Application_Type"))
				{	soap_flag_jsdl__Application1--;
					continue;
				}
			if (soap_flag_jsdl__Resources1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Resources_USCOREType(soap, "jsdl:Resources", &(a->jsdl__JobDescription_USCOREType::jsdl__Resources), "jsdl:Resources_Type"))
				{	soap_flag_jsdl__Resources1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, "jsdl:DataStaging", &(a->jsdl__JobDescription_USCOREType::jsdl__DataStaging), "jsdl:DataStaging_Type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDescription_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDescription_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDescription_USCOREType, 0, sizeof(jsdl__JobDescription_USCOREType), 0, soap_copy_jsdl__JobDescription_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobDescription_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobDescription_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobDescription_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobDescription_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDescription_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__JobDescription_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobDescription_USCOREType);
		((jsdl__JobDescription_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobDescription_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDescription_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDescription_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDescription_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDescription_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDescription_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDescription_USCOREType*)p = *(jsdl__JobDescription_USCOREType*)q;
}

void jsdl__JobDefinition_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__JobDefinition_USCOREType::jsdl__JobDescription = NULL;
	soap_default_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	this->jsdl__JobDefinition_USCOREType::id = NULL;
	this->jsdl__JobDefinition_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__JobDefinition_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDescription_USCOREType(soap, &this->jsdl__JobDefinition_USCOREType::jsdl__JobDescription);
	soap_serialize_std__vectorTemplateOf_XML(soap, &this->jsdl__JobDefinition_USCOREType::__any);
	/* transient soap skipped */
}

int jsdl__JobDefinition_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__JobDefinition_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__JobDefinition_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (((jsdl__JobDefinition_USCOREType*)a)->id)
		soap_set_attr(soap, "id", ((jsdl__JobDefinition_USCOREType*)a)->id->c_str());
	if (((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", -1, &(a->jsdl__JobDefinition_USCOREType::jsdl__JobDescription), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_XML(soap, "-any", -1, &(a->jsdl__JobDefinition_USCOREType::__any), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__JobDefinition_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__JobDefinition_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_get_jsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__JobDefinition_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__JobDefinition_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_in_jsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__JobDefinition_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__JobDefinition_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__JobDefinition_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((jsdl__JobDefinition_USCOREType*)a)->id = soap_new_std__string(soap, -1);
				((jsdl__JobDefinition_USCOREType*)a)->id->assign(s);
			}
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__JobDefinition_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_jsdl__JobDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDescription1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDescription_USCOREType(soap, "jsdl:JobDescription", &(a->jsdl__JobDefinition_USCOREType::jsdl__JobDescription), "jsdl:JobDescription_Type"))
				{	soap_flag_jsdl__JobDescription1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "-any", &(a->jsdl__JobDefinition_USCOREType::__any), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__JobDefinition_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__JobDefinition_USCOREType, 0, sizeof(jsdl__JobDefinition_USCOREType), 0, soap_copy_jsdl__JobDefinition_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDescription1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__JobDefinition_USCOREType * SOAP_FMAC6 soap_new_jsdl__JobDefinition_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__JobDefinition_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__JobDefinition_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__JobDefinition_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__JobDefinition_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType;
		if (size)
			*size = sizeof(jsdl__JobDefinition_USCOREType);
		((jsdl__JobDefinition_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__JobDefinition_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__JobDefinition_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__JobDefinition_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__JobDefinition_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__JobDefinition_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__JobDefinition_USCOREType %p -> %p\n", q, p));
	*(jsdl__JobDefinition_USCOREType*)p = *(jsdl__JobDefinition_USCOREType*)q;
}

void jsdl__RangeValue_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__RangeValue_USCOREType::UpperBoundedRange = NULL;
	this->jsdl__RangeValue_USCOREType::LowerBoundedRange = NULL;
	soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	this->jsdl__RangeValue_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__RangeValue_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::UpperBoundedRange);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::LowerBoundedRange);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Exact);
	soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, &this->jsdl__RangeValue_USCOREType::Range);
	/* transient soap skipped */
}

int jsdl__RangeValue_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__RangeValue_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__RangeValue_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (((jsdl__RangeValue_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__RangeValue_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", -1, &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "jsdl:Exact", -1, &(a->jsdl__RangeValue_USCOREType::Exact), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "jsdl:Range", -1, &(a->jsdl__RangeValue_USCOREType::Range), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__RangeValue_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__RangeValue_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_get_jsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__RangeValue_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__RangeValue_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_in_jsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__RangeValue_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__RangeValue_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__RangeValue_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__RangeValue_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_UpperBoundedRange1 = 1;
	size_t soap_flag_LowerBoundedRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpperBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBoundedRange", &(a->jsdl__RangeValue_USCOREType::UpperBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBoundedRange1--;
					continue;
				}
			if (soap_flag_LowerBoundedRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBoundedRange", &(a->jsdl__RangeValue_USCOREType::LowerBoundedRange), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBoundedRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, "jsdl:Exact", &(a->jsdl__RangeValue_USCOREType::Exact), "jsdl:Exact_Type"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, "jsdl:Range", &(a->jsdl__RangeValue_USCOREType::Range), "jsdl:Range_Type"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__RangeValue_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__RangeValue_USCOREType, 0, sizeof(jsdl__RangeValue_USCOREType), 0, soap_copy_jsdl__RangeValue_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__RangeValue_USCOREType * SOAP_FMAC6 soap_new_jsdl__RangeValue_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__RangeValue_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__RangeValue_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__RangeValue_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__RangeValue_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType;
		if (size)
			*size = sizeof(jsdl__RangeValue_USCOREType);
		((jsdl__RangeValue_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__RangeValue_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__RangeValue_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__RangeValue_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__RangeValue_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__RangeValue_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__RangeValue_USCOREType %p -> %p\n", q, p));
	*(jsdl__RangeValue_USCOREType*)p = *(jsdl__RangeValue_USCOREType*)q;
}

void jsdl__Range_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->jsdl__Range_USCOREType::LowerBound = NULL;
	this->jsdl__Range_USCOREType::UpperBound = NULL;
	this->jsdl__Range_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Range_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::LowerBound);
	soap_serialize_PointerTojsdl__Boundary_USCOREType(soap, &this->jsdl__Range_USCOREType::UpperBound);
	/* transient soap skipped */
}

int jsdl__Range_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Range_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Range_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Range_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Range_USCOREType *a, const char *type)
{
	if (((jsdl__Range_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Range_USCOREType*)a)->__anyAttribute);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_jsdl__Range_USCOREType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", -1, &(a->jsdl__Range_USCOREType::LowerBound), ""))
		return soap->error;
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", -1, &(a->jsdl__Range_USCOREType::UpperBound), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *jsdl__Range_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Range_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_get_jsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Range_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Range_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_in_jsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (jsdl__Range_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Range_USCOREType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (jsdl__Range_USCOREType *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Range_USCOREType*)a)->__anyAttribute))
		return NULL;
	size_t soap_flag_LowerBound1 = 1;
	size_t soap_flag_UpperBound1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LowerBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:LowerBound", &(a->jsdl__Range_USCOREType::LowerBound), "jsdl:Boundary_Type"))
				{	soap_flag_LowerBound1--;
					continue;
				}
			if (soap_flag_UpperBound1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__Boundary_USCOREType(soap, "jsdl:UpperBound", &(a->jsdl__Range_USCOREType::UpperBound), "jsdl:Boundary_Type"))
				{	soap_flag_UpperBound1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (jsdl__Range_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_jsdl__Range_USCOREType, 0, sizeof(jsdl__Range_USCOREType), 0, soap_copy_jsdl__Range_USCOREType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LowerBound1 > 0 || soap_flag_UpperBound1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 jsdl__Range_USCOREType * SOAP_FMAC6 soap_new_jsdl__Range_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Range_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Range_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Range_USCOREType;
		if (size)
			*size = sizeof(jsdl__Range_USCOREType);
		((jsdl__Range_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Range_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Range_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Range_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Range_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Range_USCOREType %p -> %p\n", q, p));
	*(jsdl__Range_USCOREType*)p = *(jsdl__Range_USCOREType*)q;
}

void jsdl__Exact_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Exact_USCOREType::__item);
	this->jsdl__Exact_USCOREType::epsilon = NULL;
	this->jsdl__Exact_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Exact_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Exact_USCOREType::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int jsdl__Exact_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Exact_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Exact_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Exact_USCOREType *a, const char *type)
{
	if (((jsdl__Exact_USCOREType*)a)->epsilon)
		soap_set_attr(soap, "epsilon", soap_double2s(soap, *((jsdl__Exact_USCOREType*)a)->epsilon));
	if (((jsdl__Exact_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Exact_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &a->jsdl__Exact_USCOREType::__item, "");
}

void *jsdl__Exact_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Exact_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_get_jsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Exact_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Exact_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_in_jsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Exact_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Exact_USCOREType)
			return (jsdl__Exact_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "epsilon", 0);
		if (t)
		{
			if (!(((jsdl__Exact_USCOREType*)a)->epsilon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((jsdl__Exact_USCOREType*)a)->epsilon))
				return NULL;
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Exact_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Exact_USCOREType::__item), "jsdl:Exact_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__Exact_USCOREType * SOAP_FMAC6 soap_new_jsdl__Exact_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Exact_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Exact_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Exact_USCOREType;
		if (size)
			*size = sizeof(jsdl__Exact_USCOREType);
		((jsdl__Exact_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Exact_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Exact_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Exact_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Exact_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Exact_USCOREType %p -> %p\n", q, p));
	*(jsdl__Exact_USCOREType*)p = *(jsdl__Exact_USCOREType*)q;
}

void jsdl__Boundary_USCOREType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->jsdl__Boundary_USCOREType::__item);
	this->jsdl__Boundary_USCOREType::exclusiveBound = NULL;
	this->jsdl__Boundary_USCOREType::__anyAttribute = NULL;
	/* transient soap skipped */
}

void jsdl__Boundary_USCOREType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->jsdl__Boundary_USCOREType::__item, SOAP_TYPE_double);
	/* transient soap skipped */
}

int jsdl__Boundary_USCOREType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int jsdl__Boundary_USCOREType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_jsdl__Boundary_USCOREType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, const jsdl__Boundary_USCOREType *a, const char *type)
{
	if (((jsdl__Boundary_USCOREType*)a)->exclusiveBound)
		soap_set_attr(soap, "exclusiveBound", soap_bool2s(soap, *((jsdl__Boundary_USCOREType*)a)->exclusiveBound));
	if (((jsdl__Boundary_USCOREType*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((jsdl__Boundary_USCOREType*)a)->__anyAttribute);
	return soap_out_double(soap, tag, id, &a->jsdl__Boundary_USCOREType::__item, "");
}

void *jsdl__Boundary_USCOREType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_jsdl__Boundary_USCOREType(soap, this, tag, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_get_jsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_jsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *jsdl__Boundary_USCOREType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_jsdl__Boundary_USCOREType(soap, tag, this, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_in_jsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (jsdl__Boundary_USCOREType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_jsdl__Boundary_USCOREType)
			return (jsdl__Boundary_USCOREType *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "exclusiveBound", 0);
		if (t)
		{
			if (!(((jsdl__Boundary_USCOREType*)a)->exclusiveBound = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((jsdl__Boundary_USCOREType*)a)->exclusiveBound))
			return NULL;
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((jsdl__Boundary_USCOREType*)a)->__anyAttribute))
		return NULL;
	if (!soap_in_double(soap, tag, &(a->jsdl__Boundary_USCOREType::__item), "jsdl:Boundary_Type"))
		return NULL;
	return a;
}

SOAP_FMAC5 jsdl__Boundary_USCOREType * SOAP_FMAC6 soap_new_jsdl__Boundary_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_jsdl__Boundary_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_jsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType * SOAP_FMAC4 soap_instantiate_jsdl__Boundary_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_jsdl__Boundary_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_jsdl__Boundary_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new jsdl__Boundary_USCOREType;
		if (size)
			*size = sizeof(jsdl__Boundary_USCOREType);
		((jsdl__Boundary_USCOREType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new jsdl__Boundary_USCOREType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(jsdl__Boundary_USCOREType);
		for (int i = 0; i < n; i++)
			((jsdl__Boundary_USCOREType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (jsdl__Boundary_USCOREType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_jsdl__Boundary_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying jsdl__Boundary_USCOREType %p -> %p\n", q, p));
	*(jsdl__Boundary_USCOREType*)p = *(jsdl__Boundary_USCOREType*)q;
}

void _gridsam__UnknownJobFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__UnknownJobFault::JobIdentifier);
	/* transient soap skipped */
}

void _gridsam__UnknownJobFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__UnknownJobFault::JobIdentifier);
	/* transient soap skipped */
}

int _gridsam__UnknownJobFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__UnknownJobFault);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__UnknownJobFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__UnknownJobFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__UnknownJobFault(struct soap *soap, const char *tag, int id, const _gridsam__UnknownJobFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__UnknownJobFault), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", -1, &(a->_gridsam__UnknownJobFault::JobIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__UnknownJobFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__UnknownJobFault(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__UnknownJobFault * SOAP_FMAC4 soap_get__gridsam__UnknownJobFault(struct soap *soap, _gridsam__UnknownJobFault *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__UnknownJobFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__UnknownJobFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__UnknownJobFault(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__UnknownJobFault * SOAP_FMAC4 soap_in__gridsam__UnknownJobFault(struct soap *soap, const char *tag, _gridsam__UnknownJobFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__UnknownJobFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__UnknownJobFault, sizeof(_gridsam__UnknownJobFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__UnknownJobFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__UnknownJobFault *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", &(a->_gridsam__UnknownJobFault::JobIdentifier), "gridsam:JobIdentifierType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__UnknownJobFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__UnknownJobFault, 0, sizeof(_gridsam__UnknownJobFault), 0, soap_copy__gridsam__UnknownJobFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__UnknownJobFault * SOAP_FMAC6 soap_new__gridsam__UnknownJobFault(struct soap *soap, int n)
{	return soap_instantiate__gridsam__UnknownJobFault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__UnknownJobFault(struct soap *soap, _gridsam__UnknownJobFault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__UnknownJobFault * SOAP_FMAC4 soap_instantiate__gridsam__UnknownJobFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__UnknownJobFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__UnknownJobFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__UnknownJobFault;
		if (size)
			*size = sizeof(_gridsam__UnknownJobFault);
		((_gridsam__UnknownJobFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__UnknownJobFault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__UnknownJobFault);
		for (int i = 0; i < n; i++)
			((_gridsam__UnknownJobFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__UnknownJobFault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__UnknownJobFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__UnknownJobFault %p -> %p\n", q, p));
	*(_gridsam__UnknownJobFault*)p = *(_gridsam__UnknownJobFault*)q;
}

void _gridsam__startJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, &this->_gridsam__startJobResponse::gridsam__JobStatus);
	/* transient soap skipped */
}

void _gridsam__startJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, &this->_gridsam__startJobResponse::gridsam__JobStatus);
	/* transient soap skipped */
}

int _gridsam__startJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__startJobResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__startJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__startJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__startJobResponse(struct soap *soap, const char *tag, int id, const _gridsam__startJobResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__startJobResponse), type))
		return soap->error;
	soap_element_result(soap, "gridsam:JobStatus");
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, "gridsam:JobStatus", -1, &(a->_gridsam__startJobResponse::gridsam__JobStatus), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__startJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__startJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__startJobResponse * SOAP_FMAC4 soap_get__gridsam__startJobResponse(struct soap *soap, _gridsam__startJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__startJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__startJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__startJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__startJobResponse * SOAP_FMAC4 soap_in__gridsam__startJobResponse(struct soap *soap, const char *tag, _gridsam__startJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__startJobResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__startJobResponse, sizeof(_gridsam__startJobResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__startJobResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__startJobResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, "gridsam:JobStatus", &(a->_gridsam__startJobResponse::gridsam__JobStatus), "gridsam:JobStatusType"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "gridsam:JobStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__startJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__startJobResponse, 0, sizeof(_gridsam__startJobResponse), 0, soap_copy__gridsam__startJobResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__startJobResponse * SOAP_FMAC6 soap_new__gridsam__startJobResponse(struct soap *soap, int n)
{	return soap_instantiate__gridsam__startJobResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__startJobResponse(struct soap *soap, _gridsam__startJobResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__startJobResponse * SOAP_FMAC4 soap_instantiate__gridsam__startJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__startJobResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__startJobResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__startJobResponse;
		if (size)
			*size = sizeof(_gridsam__startJobResponse);
		((_gridsam__startJobResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__startJobResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__startJobResponse);
		for (int i = 0; i < n; i++)
			((_gridsam__startJobResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__startJobResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__startJobResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__startJobResponse %p -> %p\n", q, p));
	*(_gridsam__startJobResponse*)p = *(_gridsam__startJobResponse*)q;
}

void _gridsam__startJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__startJob::gridsam__JobIdentifier);
	/* transient soap skipped */
}

void _gridsam__startJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__startJob::gridsam__JobIdentifier);
	/* transient soap skipped */
}

int _gridsam__startJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__startJob);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__startJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__startJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__startJob(struct soap *soap, const char *tag, int id, const _gridsam__startJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__startJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", -1, &(a->_gridsam__startJob::gridsam__JobIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__startJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__startJob(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__startJob * SOAP_FMAC4 soap_get__gridsam__startJob(struct soap *soap, _gridsam__startJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__startJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__startJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__startJob(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__startJob * SOAP_FMAC4 soap_in__gridsam__startJob(struct soap *soap, const char *tag, _gridsam__startJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__startJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__startJob, sizeof(_gridsam__startJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__startJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__startJob *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", &(a->_gridsam__startJob::gridsam__JobIdentifier), "gridsam:JobIdentifierType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__startJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__startJob, 0, sizeof(_gridsam__startJob), 0, soap_copy__gridsam__startJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__startJob * SOAP_FMAC6 soap_new__gridsam__startJob(struct soap *soap, int n)
{	return soap_instantiate__gridsam__startJob(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__startJob(struct soap *soap, _gridsam__startJob *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__startJob * SOAP_FMAC4 soap_instantiate__gridsam__startJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__startJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__startJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__startJob;
		if (size)
			*size = sizeof(_gridsam__startJob);
		((_gridsam__startJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__startJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__startJob);
		for (int i = 0; i < n; i++)
			((_gridsam__startJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__startJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__startJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__startJob %p -> %p\n", q, p));
	*(_gridsam__startJob*)p = *(_gridsam__startJob*)q;
}

void _gridsam__terminateJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, &this->_gridsam__terminateJobResponse::gridsam__JobStatus);
	/* transient soap skipped */
}

void _gridsam__terminateJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, &this->_gridsam__terminateJobResponse::gridsam__JobStatus);
	/* transient soap skipped */
}

int _gridsam__terminateJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__terminateJobResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__terminateJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__terminateJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__terminateJobResponse(struct soap *soap, const char *tag, int id, const _gridsam__terminateJobResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__terminateJobResponse), type))
		return soap->error;
	soap_element_result(soap, "gridsam:JobStatus");
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, "gridsam:JobStatus", -1, &(a->_gridsam__terminateJobResponse::gridsam__JobStatus), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__terminateJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__terminateJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__terminateJobResponse * SOAP_FMAC4 soap_get__gridsam__terminateJobResponse(struct soap *soap, _gridsam__terminateJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__terminateJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__terminateJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__terminateJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__terminateJobResponse * SOAP_FMAC4 soap_in__gridsam__terminateJobResponse(struct soap *soap, const char *tag, _gridsam__terminateJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__terminateJobResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__terminateJobResponse, sizeof(_gridsam__terminateJobResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__terminateJobResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__terminateJobResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, "gridsam:JobStatus", &(a->_gridsam__terminateJobResponse::gridsam__JobStatus), "gridsam:JobStatusType"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "gridsam:JobStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__terminateJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__terminateJobResponse, 0, sizeof(_gridsam__terminateJobResponse), 0, soap_copy__gridsam__terminateJobResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__terminateJobResponse * SOAP_FMAC6 soap_new__gridsam__terminateJobResponse(struct soap *soap, int n)
{	return soap_instantiate__gridsam__terminateJobResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__terminateJobResponse(struct soap *soap, _gridsam__terminateJobResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__terminateJobResponse * SOAP_FMAC4 soap_instantiate__gridsam__terminateJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__terminateJobResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__terminateJobResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__terminateJobResponse;
		if (size)
			*size = sizeof(_gridsam__terminateJobResponse);
		((_gridsam__terminateJobResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__terminateJobResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__terminateJobResponse);
		for (int i = 0; i < n; i++)
			((_gridsam__terminateJobResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__terminateJobResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__terminateJobResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__terminateJobResponse %p -> %p\n", q, p));
	*(_gridsam__terminateJobResponse*)p = *(_gridsam__terminateJobResponse*)q;
}

void _gridsam__terminateJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__terminateJob::gridsam__JobIdentifier);
	/* transient soap skipped */
}

void _gridsam__terminateJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__terminateJob::gridsam__JobIdentifier);
	/* transient soap skipped */
}

int _gridsam__terminateJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__terminateJob);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__terminateJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__terminateJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__terminateJob(struct soap *soap, const char *tag, int id, const _gridsam__terminateJob *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__terminateJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", -1, &(a->_gridsam__terminateJob::gridsam__JobIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__terminateJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__terminateJob(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__terminateJob * SOAP_FMAC4 soap_get__gridsam__terminateJob(struct soap *soap, _gridsam__terminateJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__terminateJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__terminateJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__terminateJob(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__terminateJob * SOAP_FMAC4 soap_in__gridsam__terminateJob(struct soap *soap, const char *tag, _gridsam__terminateJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__terminateJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__terminateJob, sizeof(_gridsam__terminateJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__terminateJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__terminateJob *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", &(a->_gridsam__terminateJob::gridsam__JobIdentifier), "gridsam:JobIdentifierType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__terminateJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__terminateJob, 0, sizeof(_gridsam__terminateJob), 0, soap_copy__gridsam__terminateJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__terminateJob * SOAP_FMAC6 soap_new__gridsam__terminateJob(struct soap *soap, int n)
{	return soap_instantiate__gridsam__terminateJob(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__terminateJob(struct soap *soap, _gridsam__terminateJob *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__terminateJob * SOAP_FMAC4 soap_instantiate__gridsam__terminateJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__terminateJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__terminateJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__terminateJob;
		if (size)
			*size = sizeof(_gridsam__terminateJob);
		((_gridsam__terminateJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__terminateJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__terminateJob);
		for (int i = 0; i < n; i++)
			((_gridsam__terminateJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__terminateJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__terminateJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__terminateJob %p -> %p\n", q, p));
	*(_gridsam__terminateJob*)p = *(_gridsam__terminateJob*)q;
}

void _gridsam__getJobStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, &this->_gridsam__getJobStatusResponse::gridsam__JobStatus);
	/* transient soap skipped */
}

void _gridsam__getJobStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, &this->_gridsam__getJobStatusResponse::gridsam__JobStatus);
	/* transient soap skipped */
}

int _gridsam__getJobStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__getJobStatusResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__getJobStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__getJobStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__getJobStatusResponse(struct soap *soap, const char *tag, int id, const _gridsam__getJobStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__getJobStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "gridsam:JobStatus");
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, "gridsam:JobStatus", -1, &(a->_gridsam__getJobStatusResponse::gridsam__JobStatus), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__getJobStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__getJobStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__getJobStatusResponse * SOAP_FMAC4 soap_get__gridsam__getJobStatusResponse(struct soap *soap, _gridsam__getJobStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__getJobStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__getJobStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__getJobStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__getJobStatusResponse * SOAP_FMAC4 soap_in__gridsam__getJobStatusResponse(struct soap *soap, const char *tag, _gridsam__getJobStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__getJobStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__getJobStatusResponse, sizeof(_gridsam__getJobStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__getJobStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__getJobStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, "gridsam:JobStatus", &(a->_gridsam__getJobStatusResponse::gridsam__JobStatus), "gridsam:JobStatusType"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "gridsam:JobStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__getJobStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__getJobStatusResponse, 0, sizeof(_gridsam__getJobStatusResponse), 0, soap_copy__gridsam__getJobStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__getJobStatusResponse * SOAP_FMAC6 soap_new__gridsam__getJobStatusResponse(struct soap *soap, int n)
{	return soap_instantiate__gridsam__getJobStatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__getJobStatusResponse(struct soap *soap, _gridsam__getJobStatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__getJobStatusResponse * SOAP_FMAC4 soap_instantiate__gridsam__getJobStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__getJobStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__getJobStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__getJobStatusResponse;
		if (size)
			*size = sizeof(_gridsam__getJobStatusResponse);
		((_gridsam__getJobStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__getJobStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__getJobStatusResponse);
		for (int i = 0; i < n; i++)
			((_gridsam__getJobStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__getJobStatusResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__getJobStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__getJobStatusResponse %p -> %p\n", q, p));
	*(_gridsam__getJobStatusResponse*)p = *(_gridsam__getJobStatusResponse*)q;
}

void _gridsam__getJobStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__getJobStatus::gridsam__JobIdentifier);
	/* transient soap skipped */
}

void _gridsam__getJobStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__getJobStatus::gridsam__JobIdentifier);
	/* transient soap skipped */
}

int _gridsam__getJobStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__getJobStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__getJobStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__getJobStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__getJobStatus(struct soap *soap, const char *tag, int id, const _gridsam__getJobStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__getJobStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", -1, &(a->_gridsam__getJobStatus::gridsam__JobIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__getJobStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__getJobStatus(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__getJobStatus * SOAP_FMAC4 soap_get__gridsam__getJobStatus(struct soap *soap, _gridsam__getJobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__getJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__getJobStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__getJobStatus(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__getJobStatus * SOAP_FMAC4 soap_in__gridsam__getJobStatus(struct soap *soap, const char *tag, _gridsam__getJobStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__getJobStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__getJobStatus, sizeof(_gridsam__getJobStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__getJobStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__getJobStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", &(a->_gridsam__getJobStatus::gridsam__JobIdentifier), "gridsam:JobIdentifierType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__getJobStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__getJobStatus, 0, sizeof(_gridsam__getJobStatus), 0, soap_copy__gridsam__getJobStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__getJobStatus * SOAP_FMAC6 soap_new__gridsam__getJobStatus(struct soap *soap, int n)
{	return soap_instantiate__gridsam__getJobStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__getJobStatus(struct soap *soap, _gridsam__getJobStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__getJobStatus * SOAP_FMAC4 soap_instantiate__gridsam__getJobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__getJobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__getJobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__getJobStatus;
		if (size)
			*size = sizeof(_gridsam__getJobStatus);
		((_gridsam__getJobStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__getJobStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__getJobStatus);
		for (int i = 0; i < n; i++)
			((_gridsam__getJobStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__getJobStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__getJobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__getJobStatus %p -> %p\n", q, p));
	*(_gridsam__getJobStatus*)p = *(_gridsam__getJobStatus*)q;
}

void _gridsam__submitJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__submitJobResponse::gridsam__JobIdentifier);
	/* transient soap skipped */
}

void _gridsam__submitJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, &this->_gridsam__submitJobResponse::gridsam__JobIdentifier);
	/* transient soap skipped */
}

int _gridsam__submitJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__submitJobResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__submitJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__submitJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__submitJobResponse(struct soap *soap, const char *tag, int id, const _gridsam__submitJobResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__submitJobResponse), type))
		return soap->error;
	soap_element_result(soap, "gridsam:JobIdentifier");
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", -1, &(a->_gridsam__submitJobResponse::gridsam__JobIdentifier), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__submitJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__submitJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__submitJobResponse * SOAP_FMAC4 soap_get__gridsam__submitJobResponse(struct soap *soap, _gridsam__submitJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__submitJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__submitJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__submitJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__submitJobResponse * SOAP_FMAC4 soap_in__gridsam__submitJobResponse(struct soap *soap, const char *tag, _gridsam__submitJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__submitJobResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__submitJobResponse, sizeof(_gridsam__submitJobResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__submitJobResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__submitJobResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", &(a->_gridsam__submitJobResponse::gridsam__JobIdentifier), "gridsam:JobIdentifierType"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "gridsam:JobIdentifier");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__submitJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__submitJobResponse, 0, sizeof(_gridsam__submitJobResponse), 0, soap_copy__gridsam__submitJobResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__submitJobResponse * SOAP_FMAC6 soap_new__gridsam__submitJobResponse(struct soap *soap, int n)
{	return soap_instantiate__gridsam__submitJobResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__submitJobResponse(struct soap *soap, _gridsam__submitJobResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__submitJobResponse * SOAP_FMAC4 soap_instantiate__gridsam__submitJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__submitJobResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__submitJobResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__submitJobResponse;
		if (size)
			*size = sizeof(_gridsam__submitJobResponse);
		((_gridsam__submitJobResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__submitJobResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__submitJobResponse);
		for (int i = 0; i < n; i++)
			((_gridsam__submitJobResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__submitJobResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__submitJobResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__submitJobResponse %p -> %p\n", q, p));
	*(_gridsam__submitJobResponse*)p = *(_gridsam__submitJobResponse*)q;
}

void _gridsam__submitJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(soap, &this->_gridsam__submitJob::gridsam__JobDescription);
	this->_gridsam__submitJob::startSuspended = (bool)0;
	/* transient soap skipped */
}

void _gridsam__submitJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(soap, &this->_gridsam__submitJob::gridsam__JobDescription);
	/* transient soap skipped */
}

int _gridsam__submitJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__submitJob);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__submitJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__submitJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__submitJob(struct soap *soap, const char *tag, int id, const _gridsam__submitJob *a, const char *type)
{
	soap_set_attr(soap, "startSuspended", soap_bool2s(soap, ((_gridsam__submitJob*)a)->startSuspended));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__submitJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(soap, "gridsam:JobDescription", -1, &(a->_gridsam__submitJob::gridsam__JobDescription), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__submitJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__submitJob(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__submitJob * SOAP_FMAC4 soap_get__gridsam__submitJob(struct soap *soap, _gridsam__submitJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__submitJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__submitJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__submitJob(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__submitJob * SOAP_FMAC4 soap_in__gridsam__submitJob(struct soap *soap, const char *tag, _gridsam__submitJob *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__submitJob *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__submitJob, sizeof(_gridsam__submitJob), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__submitJob)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__submitJob *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "startSuspended", 0), &((_gridsam__submitJob*)a)->startSuspended))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(soap, "gridsam:JobDescription", &(a->_gridsam__submitJob::gridsam__JobDescription), "gridsam:JobDescriptionType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__submitJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__submitJob, 0, sizeof(_gridsam__submitJob), 0, soap_copy__gridsam__submitJob);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__submitJob * SOAP_FMAC6 soap_new__gridsam__submitJob(struct soap *soap, int n)
{	return soap_instantiate__gridsam__submitJob(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__submitJob(struct soap *soap, _gridsam__submitJob *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__submitJob * SOAP_FMAC4 soap_instantiate__gridsam__submitJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__submitJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__submitJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__submitJob;
		if (size)
			*size = sizeof(_gridsam__submitJob);
		((_gridsam__submitJob*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__submitJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__submitJob);
		for (int i = 0; i < n; i++)
			((_gridsam__submitJob*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__submitJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__submitJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__submitJob %p -> %p\n", q, p));
	*(_gridsam__submitJob*)p = *(_gridsam__submitJob*)q;
}

void _gridsam__Stage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_gridsam__StateType(soap, &this->_gridsam__Stage::State);
	soap_default_std__string(soap, &this->_gridsam__Stage::Description);
	soap_default_time(soap, &this->_gridsam__Stage::Time);
	/* transient soap skipped */
}

void _gridsam__Stage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_gridsam__Stage::Description, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_gridsam__Stage::Description);
	/* transient soap skipped */
}

int _gridsam__Stage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__Stage);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__Stage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__Stage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__Stage(struct soap *soap, const char *tag, int id, const _gridsam__Stage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__Stage), type))
		return soap->error;
	if (soap_out_gridsam__StateType(soap, "gridsam:State", -1, &(a->_gridsam__Stage::State), ""))
		return soap->error;
	if (soap_out_std__string(soap, "gridsam:Description", -1, &(a->_gridsam__Stage::Description), ""))
		return soap->error;
	if (soap_out_time(soap, "gridsam:Time", -1, &(a->_gridsam__Stage::Time), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__Stage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__Stage(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__Stage * SOAP_FMAC4 soap_get__gridsam__Stage(struct soap *soap, _gridsam__Stage *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__Stage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__Stage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__Stage(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__Stage * SOAP_FMAC4 soap_in__gridsam__Stage(struct soap *soap, const char *tag, _gridsam__Stage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__Stage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__Stage, sizeof(_gridsam__Stage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__Stage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__Stage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_State1 = 1;
	size_t soap_flag_Description1 = 1;
	size_t soap_flag_Time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_gridsam__StateType(soap, "gridsam:State", &(a->_gridsam__Stage::State), "gridsam:StateType"))
				{	soap_flag_State1--;
					continue;
				}
			if (soap_flag_Description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "gridsam:Description", &(a->_gridsam__Stage::Description), "xsd:string"))
				{	soap_flag_Description1--;
					continue;
				}
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "gridsam:Time", &(a->_gridsam__Stage::Time), "xsd:dateTime"))
				{	soap_flag_Time1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__Stage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__Stage, 0, sizeof(_gridsam__Stage), 0, soap_copy__gridsam__Stage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State1 > 0 || soap_flag_Description1 > 0 || soap_flag_Time1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__Stage * SOAP_FMAC6 soap_new__gridsam__Stage(struct soap *soap, int n)
{	return soap_instantiate__gridsam__Stage(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__Stage(struct soap *soap, _gridsam__Stage *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__Stage * SOAP_FMAC4 soap_instantiate__gridsam__Stage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__Stage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__Stage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__Stage;
		if (size)
			*size = sizeof(_gridsam__Stage);
		((_gridsam__Stage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__Stage[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__Stage);
		for (int i = 0; i < n; i++)
			((_gridsam__Stage*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__Stage*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__Stage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__Stage %p -> %p\n", q, p));
	*(_gridsam__Stage*)p = *(_gridsam__Stage*)q;
}

void _gridsam__Property::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_gridsam__Property::__any = NULL;
	this->_gridsam__Property::name = NULL;
	this->_gridsam__Property::__mixed = NULL;
	/* transient soap skipped */
}

void _gridsam__Property::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _gridsam__Property::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__gridsam__Property);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _gridsam__Property::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__gridsam__Property(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__gridsam__Property(struct soap *soap, const char *tag, int id, const _gridsam__Property *a, const char *type)
{
	if (((_gridsam__Property*)a)->name)
		soap_set_attr(soap, "name", ((_gridsam__Property*)a)->name->c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__gridsam__Property), type))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->_gridsam__Property::__any), NULL);
	soap_outliteral(soap, "-mixed", &(a->_gridsam__Property::__mixed), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_gridsam__Property::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__gridsam__Property(soap, this, tag, type);
}

SOAP_FMAC3 _gridsam__Property * SOAP_FMAC4 soap_get__gridsam__Property(struct soap *soap, _gridsam__Property *p, const char *tag, const char *type)
{
	if ((p = soap_in__gridsam__Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_gridsam__Property::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__gridsam__Property(soap, tag, this, type);
}

SOAP_FMAC3 _gridsam__Property * SOAP_FMAC4 soap_in__gridsam__Property(struct soap *soap, const char *tag, _gridsam__Property *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_gridsam__Property *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__gridsam__Property, sizeof(_gridsam__Property), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__gridsam__Property)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_gridsam__Property *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((_gridsam__Property*)a)->name = soap_new_std__string(soap, -1);
				((_gridsam__Property*)a)->name->assign(s);
			}
		}
	}
	size_t soap_flag___any1 = 1;
	size_t soap_flag___mixed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->_gridsam__Property::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap_flag___mixed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &(a->_gridsam__Property::__mixed)))
				{	soap_flag___mixed1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_gridsam__Property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__gridsam__Property, 0, sizeof(_gridsam__Property), 0, soap_copy__gridsam__Property);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _gridsam__Property * SOAP_FMAC6 soap_new__gridsam__Property(struct soap *soap, int n)
{	return soap_instantiate__gridsam__Property(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__gridsam__Property(struct soap *soap, _gridsam__Property *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _gridsam__Property * SOAP_FMAC4 soap_instantiate__gridsam__Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__gridsam__Property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__gridsam__Property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _gridsam__Property;
		if (size)
			*size = sizeof(_gridsam__Property);
		((_gridsam__Property*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _gridsam__Property[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_gridsam__Property);
		for (int i = 0; i < n; i++)
			((_gridsam__Property*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_gridsam__Property*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__gridsam__Property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _gridsam__Property %p -> %p\n", q, p));
	*(_gridsam__Property*)p = *(_gridsam__Property*)q;
}

void gridsam__JobDescriptionType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->gridsam__JobDescriptionType::jsdl__JobDefinition = NULL;
	this->gridsam__JobDescriptionType::__any = NULL;
	/* transient soap skipped */
}

void gridsam__JobDescriptionType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTojsdl__JobDefinition_USCOREType(soap, &this->gridsam__JobDescriptionType::jsdl__JobDefinition);
	/* transient soap skipped */
}

int gridsam__JobDescriptionType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam__JobDescriptionType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam__JobDescriptionType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam__JobDescriptionType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam__JobDescriptionType(struct soap *soap, const char *tag, int id, const gridsam__JobDescriptionType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gridsam__JobDescriptionType), type))
		return soap->error;
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", -1, &(a->gridsam__JobDescriptionType::jsdl__JobDefinition), ""))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->gridsam__JobDescriptionType::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *gridsam__JobDescriptionType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam__JobDescriptionType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam__JobDescriptionType * SOAP_FMAC4 soap_get_gridsam__JobDescriptionType(struct soap *soap, gridsam__JobDescriptionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam__JobDescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam__JobDescriptionType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam__JobDescriptionType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam__JobDescriptionType * SOAP_FMAC4 soap_in_gridsam__JobDescriptionType(struct soap *soap, const char *tag, gridsam__JobDescriptionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (gridsam__JobDescriptionType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam__JobDescriptionType, sizeof(gridsam__JobDescriptionType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam__JobDescriptionType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (gridsam__JobDescriptionType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_jsdl__JobDefinition1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jsdl__JobDefinition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, "jsdl:JobDefinition", &(a->gridsam__JobDescriptionType::jsdl__JobDefinition), "jsdl:JobDefinition_Type"))
				{	soap_flag_jsdl__JobDefinition1--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->gridsam__JobDescriptionType::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (gridsam__JobDescriptionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gridsam__JobDescriptionType, 0, sizeof(gridsam__JobDescriptionType), 0, soap_copy_gridsam__JobDescriptionType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jsdl__JobDefinition1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 gridsam__JobDescriptionType * SOAP_FMAC6 soap_new_gridsam__JobDescriptionType(struct soap *soap, int n)
{	return soap_instantiate_gridsam__JobDescriptionType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam__JobDescriptionType(struct soap *soap, gridsam__JobDescriptionType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam__JobDescriptionType * SOAP_FMAC4 soap_instantiate_gridsam__JobDescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam__JobDescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam__JobDescriptionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam__JobDescriptionType;
		if (size)
			*size = sizeof(gridsam__JobDescriptionType);
		((gridsam__JobDescriptionType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam__JobDescriptionType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam__JobDescriptionType);
		for (int i = 0; i < n; i++)
			((gridsam__JobDescriptionType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam__JobDescriptionType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam__JobDescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam__JobDescriptionType %p -> %p\n", q, p));
	*(gridsam__JobDescriptionType*)p = *(gridsam__JobDescriptionType*)q;
}

void gridsam__JobIdentifierType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->gridsam__JobIdentifierType::ID);
	/* transient soap skipped */
}

void gridsam__JobIdentifierType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->gridsam__JobIdentifierType::ID, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->gridsam__JobIdentifierType::ID);
	/* transient soap skipped */
}

int gridsam__JobIdentifierType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam__JobIdentifierType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam__JobIdentifierType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam__JobIdentifierType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam__JobIdentifierType(struct soap *soap, const char *tag, int id, const gridsam__JobIdentifierType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gridsam__JobIdentifierType), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "gridsam:ID", -1, &(a->gridsam__JobIdentifierType::ID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *gridsam__JobIdentifierType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam__JobIdentifierType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam__JobIdentifierType * SOAP_FMAC4 soap_get_gridsam__JobIdentifierType(struct soap *soap, gridsam__JobIdentifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam__JobIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam__JobIdentifierType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam__JobIdentifierType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam__JobIdentifierType * SOAP_FMAC4 soap_in_gridsam__JobIdentifierType(struct soap *soap, const char *tag, gridsam__JobIdentifierType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (gridsam__JobIdentifierType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam__JobIdentifierType, sizeof(gridsam__JobIdentifierType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam__JobIdentifierType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (gridsam__JobIdentifierType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "gridsam:ID", &(a->gridsam__JobIdentifierType::ID), "xsd:anyURI"))
				{	soap_flag_ID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (gridsam__JobIdentifierType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gridsam__JobIdentifierType, 0, sizeof(gridsam__JobIdentifierType), 0, soap_copy_gridsam__JobIdentifierType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 gridsam__JobIdentifierType * SOAP_FMAC6 soap_new_gridsam__JobIdentifierType(struct soap *soap, int n)
{	return soap_instantiate_gridsam__JobIdentifierType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam__JobIdentifierType(struct soap *soap, gridsam__JobIdentifierType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam__JobIdentifierType * SOAP_FMAC4 soap_instantiate_gridsam__JobIdentifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam__JobIdentifierType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam__JobIdentifierType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam__JobIdentifierType;
		if (size)
			*size = sizeof(gridsam__JobIdentifierType);
		((gridsam__JobIdentifierType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam__JobIdentifierType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam__JobIdentifierType);
		for (int i = 0; i < n; i++)
			((gridsam__JobIdentifierType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam__JobIdentifierType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam__JobIdentifierType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam__JobIdentifierType %p -> %p\n", q, p));
	*(gridsam__JobIdentifierType*)p = *(gridsam__JobIdentifierType*)q;
}

void gridsam__JobStatusType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->gridsam__JobStatusType::gridsam__JobIdentifier = NULL;
	soap_default_std__vectorTemplateOfPointerTo_gridsam__Stage(soap, &this->gridsam__JobStatusType::gridsam__Stage);
	soap_default_std__vectorTemplateOfPointerTo_gridsam__Property(soap, &this->gridsam__JobStatusType::gridsam__Property);
	/* transient soap skipped */
}

void gridsam__JobStatusType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTogridsam__JobIdentifierType(soap, &this->gridsam__JobStatusType::gridsam__JobIdentifier);
	soap_serialize_std__vectorTemplateOfPointerTo_gridsam__Stage(soap, &this->gridsam__JobStatusType::gridsam__Stage);
	soap_serialize_std__vectorTemplateOfPointerTo_gridsam__Property(soap, &this->gridsam__JobStatusType::gridsam__Property);
	/* transient soap skipped */
}

int gridsam__JobStatusType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_gridsam__JobStatusType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int gridsam__JobStatusType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_gridsam__JobStatusType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_gridsam__JobStatusType(struct soap *soap, const char *tag, int id, const gridsam__JobStatusType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_gridsam__JobStatusType), type))
		return soap->error;
	if (soap_out_PointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", -1, &(a->gridsam__JobStatusType::gridsam__JobIdentifier), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_gridsam__Stage(soap, "gridsam:Stage", -1, &(a->gridsam__JobStatusType::gridsam__Stage), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_gridsam__Property(soap, "gridsam:Property", -1, &(a->gridsam__JobStatusType::gridsam__Property), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *gridsam__JobStatusType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_gridsam__JobStatusType(soap, this, tag, type);
}

SOAP_FMAC3 gridsam__JobStatusType * SOAP_FMAC4 soap_get_gridsam__JobStatusType(struct soap *soap, gridsam__JobStatusType *p, const char *tag, const char *type)
{
	if ((p = soap_in_gridsam__JobStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *gridsam__JobStatusType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_gridsam__JobStatusType(soap, tag, this, type);
}

SOAP_FMAC3 gridsam__JobStatusType * SOAP_FMAC4 soap_in_gridsam__JobStatusType(struct soap *soap, const char *tag, gridsam__JobStatusType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (gridsam__JobStatusType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_gridsam__JobStatusType, sizeof(gridsam__JobStatusType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_gridsam__JobStatusType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (gridsam__JobStatusType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_gridsam__JobIdentifier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gridsam__JobIdentifier1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogridsam__JobIdentifierType(soap, "gridsam:JobIdentifier", &(a->gridsam__JobStatusType::gridsam__JobIdentifier), "gridsam:JobIdentifierType"))
				{	soap_flag_gridsam__JobIdentifier1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_gridsam__Stage(soap, "gridsam:Stage", &(a->gridsam__JobStatusType::gridsam__Stage), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_gridsam__Property(soap, "gridsam:Property", &(a->gridsam__JobStatusType::gridsam__Property), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (gridsam__JobStatusType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_gridsam__JobStatusType, 0, sizeof(gridsam__JobStatusType), 0, soap_copy_gridsam__JobStatusType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_gridsam__JobIdentifier1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 gridsam__JobStatusType * SOAP_FMAC6 soap_new_gridsam__JobStatusType(struct soap *soap, int n)
{	return soap_instantiate_gridsam__JobStatusType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_gridsam__JobStatusType(struct soap *soap, gridsam__JobStatusType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 gridsam__JobStatusType * SOAP_FMAC4 soap_instantiate_gridsam__JobStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_gridsam__JobStatusType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_gridsam__JobStatusType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new gridsam__JobStatusType;
		if (size)
			*size = sizeof(gridsam__JobStatusType);
		((gridsam__JobStatusType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new gridsam__JobStatusType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(gridsam__JobStatusType);
		for (int i = 0; i < n; i++)
			((gridsam__JobStatusType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (gridsam__JobStatusType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_gridsam__JobStatusType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying gridsam__JobStatusType %p -> %p\n", q, p));
	*(gridsam__JobStatusType*)p = *(gridsam__JobStatusType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__positiveInteger(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__positiveInteger(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__positiveInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__positiveInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__positiveInteger, 0, sizeof(std::string), 0, soap_copy_xsd__positiveInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__positiveInteger(struct soap *soap, int n)
{	return soap_instantiate_xsd__positiveInteger(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__positiveInteger(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__positiveInteger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__positiveInteger(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__positiveInteger, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__positiveInteger(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__normalizedString(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__normalizedString(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__normalizedString(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__normalizedString);
	if (soap_out_xsd__normalizedString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__normalizedString(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__normalizedString), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__normalizedString(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__normalizedString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__normalizedString(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__normalizedString, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__normalizedString, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__normalizedString, 0, sizeof(std::string), 0, soap_copy_xsd__normalizedString);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__normalizedString(struct soap *soap, int n)
{	return soap_instantiate_xsd__normalizedString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__normalizedString(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__normalizedString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__normalizedString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__normalizedString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__normalizedString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__nonNegativeInteger(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__nonNegativeInteger, 0, sizeof(std::string), 0, soap_copy_xsd__nonNegativeInteger);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__nonNegativeInteger(struct soap *soap, int n)
{	return soap_instantiate_xsd__nonNegativeInteger(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__nonNegativeInteger(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__nonNegativeInteger(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonNegativeInteger(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__nonNegativeInteger, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__nonNegativeInteger(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__anyURI(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__anyURI(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyURI(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyURI(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyURI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__NCName(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__NCName, 0, sizeof(std::string), 0, soap_copy_xsd__NCName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__NCName(struct soap *soap, int n)
{	return soap_instantiate_xsd__NCName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__NCName(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__NCName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NCName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__NCName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__NCName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__ID(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ID(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ID(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__ID);
	if (soap_out_xsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ID(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__ID), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ID(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__ID(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__ID, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__ID, 0, sizeof(std::string), 0, soap_copy_xsd__ID);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__ID(struct soap *soap, int n)
{	return soap_instantiate_xsd__ID(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__ID(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__ID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__ID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__ID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__ID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___jobsubmission__submitJob(struct soap *soap, struct __jobsubmission__submitJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->gridsam__submitJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___jobsubmission__submitJob(struct soap *soap, const struct __jobsubmission__submitJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_gridsam__submitJob(soap, &a->gridsam__submitJob);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___jobsubmission__submitJob(struct soap *soap, const struct __jobsubmission__submitJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___jobsubmission__submitJob(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___jobsubmission__submitJob(struct soap *soap, const char *tag, int id, const struct __jobsubmission__submitJob *a, const char *type)
{
	if (soap_out_PointerTo_gridsam__submitJob(soap, "gridsam:submitJob", -1, &a->gridsam__submitJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __jobsubmission__submitJob * SOAP_FMAC4 soap_get___jobsubmission__submitJob(struct soap *soap, struct __jobsubmission__submitJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___jobsubmission__submitJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __jobsubmission__submitJob * SOAP_FMAC4 soap_in___jobsubmission__submitJob(struct soap *soap, const char *tag, struct __jobsubmission__submitJob *a, const char *type)
{
	size_t soap_flag_gridsam__submitJob = 1;
	short soap_flag;
	a = (struct __jobsubmission__submitJob *)soap_id_enter(soap, "", a, SOAP_TYPE___jobsubmission__submitJob, sizeof(struct __jobsubmission__submitJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___jobsubmission__submitJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gridsam__submitJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_gridsam__submitJob(soap, "gridsam:submitJob", &a->gridsam__submitJob, ""))
				{	soap_flag_gridsam__submitJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __jobsubmission__submitJob * SOAP_FMAC6 soap_new___jobsubmission__submitJob(struct soap *soap, int n)
{	return soap_instantiate___jobsubmission__submitJob(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___jobsubmission__submitJob(struct soap *soap, struct __jobsubmission__submitJob *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __jobsubmission__submitJob * SOAP_FMAC4 soap_instantiate___jobsubmission__submitJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___jobsubmission__submitJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___jobsubmission__submitJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __jobsubmission__submitJob;
		if (size)
			*size = sizeof(struct __jobsubmission__submitJob);
	}
	else
	{	cp->ptr = (void*)new struct __jobsubmission__submitJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __jobsubmission__submitJob);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __jobsubmission__submitJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___jobsubmission__submitJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __jobsubmission__submitJob %p -> %p\n", q, p));
	*(struct __jobsubmission__submitJob*)p = *(struct __jobsubmission__submitJob*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___jobmonitoring__getJobStatus(struct soap *soap, struct __jobmonitoring__getJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->gridsam__getJobStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___jobmonitoring__getJobStatus(struct soap *soap, const struct __jobmonitoring__getJobStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_gridsam__getJobStatus(soap, &a->gridsam__getJobStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___jobmonitoring__getJobStatus(struct soap *soap, const struct __jobmonitoring__getJobStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___jobmonitoring__getJobStatus(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___jobmonitoring__getJobStatus(struct soap *soap, const char *tag, int id, const struct __jobmonitoring__getJobStatus *a, const char *type)
{
	if (soap_out_PointerTo_gridsam__getJobStatus(soap, "gridsam:getJobStatus", -1, &a->gridsam__getJobStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __jobmonitoring__getJobStatus * SOAP_FMAC4 soap_get___jobmonitoring__getJobStatus(struct soap *soap, struct __jobmonitoring__getJobStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___jobmonitoring__getJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __jobmonitoring__getJobStatus * SOAP_FMAC4 soap_in___jobmonitoring__getJobStatus(struct soap *soap, const char *tag, struct __jobmonitoring__getJobStatus *a, const char *type)
{
	size_t soap_flag_gridsam__getJobStatus = 1;
	short soap_flag;
	a = (struct __jobmonitoring__getJobStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___jobmonitoring__getJobStatus, sizeof(struct __jobmonitoring__getJobStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___jobmonitoring__getJobStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gridsam__getJobStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_gridsam__getJobStatus(soap, "gridsam:getJobStatus", &a->gridsam__getJobStatus, ""))
				{	soap_flag_gridsam__getJobStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __jobmonitoring__getJobStatus * SOAP_FMAC6 soap_new___jobmonitoring__getJobStatus(struct soap *soap, int n)
{	return soap_instantiate___jobmonitoring__getJobStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___jobmonitoring__getJobStatus(struct soap *soap, struct __jobmonitoring__getJobStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __jobmonitoring__getJobStatus * SOAP_FMAC4 soap_instantiate___jobmonitoring__getJobStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___jobmonitoring__getJobStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___jobmonitoring__getJobStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __jobmonitoring__getJobStatus;
		if (size)
			*size = sizeof(struct __jobmonitoring__getJobStatus);
	}
	else
	{	cp->ptr = (void*)new struct __jobmonitoring__getJobStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __jobmonitoring__getJobStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __jobmonitoring__getJobStatus*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___jobmonitoring__getJobStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __jobmonitoring__getJobStatus %p -> %p\n", q, p));
	*(struct __jobmonitoring__getJobStatus*)p = *(struct __jobmonitoring__getJobStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___jobcontrol__startJob(struct soap *soap, struct __jobcontrol__startJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->gridsam__startJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___jobcontrol__startJob(struct soap *soap, const struct __jobcontrol__startJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_gridsam__startJob(soap, &a->gridsam__startJob);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___jobcontrol__startJob(struct soap *soap, const struct __jobcontrol__startJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___jobcontrol__startJob(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___jobcontrol__startJob(struct soap *soap, const char *tag, int id, const struct __jobcontrol__startJob *a, const char *type)
{
	if (soap_out_PointerTo_gridsam__startJob(soap, "gridsam:startJob", -1, &a->gridsam__startJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __jobcontrol__startJob * SOAP_FMAC4 soap_get___jobcontrol__startJob(struct soap *soap, struct __jobcontrol__startJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___jobcontrol__startJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __jobcontrol__startJob * SOAP_FMAC4 soap_in___jobcontrol__startJob(struct soap *soap, const char *tag, struct __jobcontrol__startJob *a, const char *type)
{
	size_t soap_flag_gridsam__startJob = 1;
	short soap_flag;
	a = (struct __jobcontrol__startJob *)soap_id_enter(soap, "", a, SOAP_TYPE___jobcontrol__startJob, sizeof(struct __jobcontrol__startJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___jobcontrol__startJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gridsam__startJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_gridsam__startJob(soap, "gridsam:startJob", &a->gridsam__startJob, ""))
				{	soap_flag_gridsam__startJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __jobcontrol__startJob * SOAP_FMAC6 soap_new___jobcontrol__startJob(struct soap *soap, int n)
{	return soap_instantiate___jobcontrol__startJob(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___jobcontrol__startJob(struct soap *soap, struct __jobcontrol__startJob *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __jobcontrol__startJob * SOAP_FMAC4 soap_instantiate___jobcontrol__startJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___jobcontrol__startJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___jobcontrol__startJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __jobcontrol__startJob;
		if (size)
			*size = sizeof(struct __jobcontrol__startJob);
	}
	else
	{	cp->ptr = (void*)new struct __jobcontrol__startJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __jobcontrol__startJob);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __jobcontrol__startJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___jobcontrol__startJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __jobcontrol__startJob %p -> %p\n", q, p));
	*(struct __jobcontrol__startJob*)p = *(struct __jobcontrol__startJob*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___jobcontrol__terminateJob(struct soap *soap, struct __jobcontrol__terminateJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->gridsam__terminateJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___jobcontrol__terminateJob(struct soap *soap, const struct __jobcontrol__terminateJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_gridsam__terminateJob(soap, &a->gridsam__terminateJob);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___jobcontrol__terminateJob(struct soap *soap, const struct __jobcontrol__terminateJob *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___jobcontrol__terminateJob(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___jobcontrol__terminateJob(struct soap *soap, const char *tag, int id, const struct __jobcontrol__terminateJob *a, const char *type)
{
	if (soap_out_PointerTo_gridsam__terminateJob(soap, "gridsam:terminateJob", -1, &a->gridsam__terminateJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __jobcontrol__terminateJob * SOAP_FMAC4 soap_get___jobcontrol__terminateJob(struct soap *soap, struct __jobcontrol__terminateJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___jobcontrol__terminateJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __jobcontrol__terminateJob * SOAP_FMAC4 soap_in___jobcontrol__terminateJob(struct soap *soap, const char *tag, struct __jobcontrol__terminateJob *a, const char *type)
{
	size_t soap_flag_gridsam__terminateJob = 1;
	short soap_flag;
	a = (struct __jobcontrol__terminateJob *)soap_id_enter(soap, "", a, SOAP_TYPE___jobcontrol__terminateJob, sizeof(struct __jobcontrol__terminateJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___jobcontrol__terminateJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gridsam__terminateJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_gridsam__terminateJob(soap, "gridsam:terminateJob", &a->gridsam__terminateJob, ""))
				{	soap_flag_gridsam__terminateJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __jobcontrol__terminateJob * SOAP_FMAC6 soap_new___jobcontrol__terminateJob(struct soap *soap, int n)
{	return soap_instantiate___jobcontrol__terminateJob(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___jobcontrol__terminateJob(struct soap *soap, struct __jobcontrol__terminateJob *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __jobcontrol__terminateJob * SOAP_FMAC4 soap_instantiate___jobcontrol__terminateJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___jobcontrol__terminateJob(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___jobcontrol__terminateJob, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __jobcontrol__terminateJob;
		if (size)
			*size = sizeof(struct __jobcontrol__terminateJob);
	}
	else
	{	cp->ptr = (void*)new struct __jobcontrol__terminateJob[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __jobcontrol__terminateJob);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __jobcontrol__terminateJob*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___jobcontrol__terminateJob(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __jobcontrol__terminateJob %p -> %p\n", q, p));
	*(struct __jobcontrol__terminateJob*)p = *(struct __jobcontrol__terminateJob*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->gridsam__AuthorisationFault = NULL;
	a->gridsam__JobStartFault = NULL;
	a->gridsam__JobTerminationFault = NULL;
	a->gridsam__UnknownJobFault = NULL;
	a->gridsam__JobMonitoringFault = NULL;
	a->gridsam__JobSubmissionFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &a->gridsam__AuthorisationFault);
	soap_serialize_PointerTostd__string(soap, &a->gridsam__JobStartFault);
	soap_serialize_PointerTostd__string(soap, &a->gridsam__JobTerminationFault);
	soap_serialize_PointerTo_gridsam__UnknownJobFault(soap, &a->gridsam__UnknownJobFault);
	soap_serialize_PointerTostd__string(soap, &a->gridsam__JobMonitoringFault);
	soap_serialize_PointerTostd__string(soap, &a->gridsam__JobSubmissionFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "gridsam:AuthorisationFault", -1, &a->gridsam__AuthorisationFault, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "gridsam:JobStartFault", -1, &a->gridsam__JobStartFault, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "gridsam:JobTerminationFault", -1, &a->gridsam__JobTerminationFault, ""))
		return soap->error;
	if (soap_out_PointerTo_gridsam__UnknownJobFault(soap, "gridsam:UnknownJobFault", -1, &a->gridsam__UnknownJobFault, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "gridsam:JobMonitoringFault", -1, &a->gridsam__JobMonitoringFault, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "gridsam:JobSubmissionFault", -1, &a->gridsam__JobSubmissionFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_gridsam__AuthorisationFault = 1;
	size_t soap_flag_gridsam__JobStartFault = 1;
	size_t soap_flag_gridsam__JobTerminationFault = 1;
	size_t soap_flag_gridsam__UnknownJobFault = 1;
	size_t soap_flag_gridsam__JobMonitoringFault = 1;
	size_t soap_flag_gridsam__JobSubmissionFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_gridsam__AuthorisationFault && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "gridsam:AuthorisationFault", &a->gridsam__AuthorisationFault, "xsd:string"))
				{	soap_flag_gridsam__AuthorisationFault--;
					continue;
				}
			if (soap_flag_gridsam__JobStartFault && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "gridsam:JobStartFault", &a->gridsam__JobStartFault, "xsd:string"))
				{	soap_flag_gridsam__JobStartFault--;
					continue;
				}
			if (soap_flag_gridsam__JobTerminationFault && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "gridsam:JobTerminationFault", &a->gridsam__JobTerminationFault, "xsd:string"))
				{	soap_flag_gridsam__JobTerminationFault--;
					continue;
				}
			if (soap_flag_gridsam__UnknownJobFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_gridsam__UnknownJobFault(soap, "gridsam:UnknownJobFault", &a->gridsam__UnknownJobFault, ""))
				{	soap_flag_gridsam__UnknownJobFault--;
					continue;
				}
			if (soap_flag_gridsam__JobMonitoringFault && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "gridsam:JobMonitoringFault", &a->gridsam__JobMonitoringFault, "xsd:string"))
				{	soap_flag_gridsam__JobMonitoringFault--;
					continue;
				}
			if (soap_flag_gridsam__JobSubmissionFault && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "gridsam:JobSubmissionFault", &a->gridsam__JobSubmissionFault, "xsd:string"))
				{	soap_flag_gridsam__JobSubmissionFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__submitJobResponse(struct soap *soap, _gridsam__submitJobResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__submitJobResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__submitJobResponse(struct soap *soap, _gridsam__submitJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__submitJobResponse);
	if (soap_out_PointerTo_gridsam__submitJobResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__submitJobResponse(struct soap *soap, const char *tag, int id, _gridsam__submitJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__submitJobResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__submitJobResponse ** SOAP_FMAC4 soap_get_PointerTo_gridsam__submitJobResponse(struct soap *soap, _gridsam__submitJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__submitJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__submitJobResponse ** SOAP_FMAC4 soap_in_PointerTo_gridsam__submitJobResponse(struct soap *soap, const char *tag, _gridsam__submitJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__submitJobResponse **)soap_malloc(soap, sizeof(_gridsam__submitJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__submitJobResponse *)soap_instantiate__gridsam__submitJobResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__submitJobResponse ** p = (_gridsam__submitJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__submitJobResponse, sizeof(_gridsam__submitJobResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__submitJob(struct soap *soap, _gridsam__submitJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__submitJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__submitJob(struct soap *soap, _gridsam__submitJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__submitJob);
	if (soap_out_PointerTo_gridsam__submitJob(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__submitJob(struct soap *soap, const char *tag, int id, _gridsam__submitJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__submitJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__submitJob ** SOAP_FMAC4 soap_get_PointerTo_gridsam__submitJob(struct soap *soap, _gridsam__submitJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__submitJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__submitJob ** SOAP_FMAC4 soap_in_PointerTo_gridsam__submitJob(struct soap *soap, const char *tag, _gridsam__submitJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__submitJob **)soap_malloc(soap, sizeof(_gridsam__submitJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__submitJob *)soap_instantiate__gridsam__submitJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__submitJob ** p = (_gridsam__submitJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__submitJob, sizeof(_gridsam__submitJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__getJobStatusResponse(struct soap *soap, _gridsam__getJobStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__getJobStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__getJobStatusResponse(struct soap *soap, _gridsam__getJobStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__getJobStatusResponse);
	if (soap_out_PointerTo_gridsam__getJobStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__getJobStatusResponse(struct soap *soap, const char *tag, int id, _gridsam__getJobStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__getJobStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__getJobStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_gridsam__getJobStatusResponse(struct soap *soap, _gridsam__getJobStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__getJobStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__getJobStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_gridsam__getJobStatusResponse(struct soap *soap, const char *tag, _gridsam__getJobStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__getJobStatusResponse **)soap_malloc(soap, sizeof(_gridsam__getJobStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__getJobStatusResponse *)soap_instantiate__gridsam__getJobStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__getJobStatusResponse ** p = (_gridsam__getJobStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__getJobStatusResponse, sizeof(_gridsam__getJobStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__getJobStatus(struct soap *soap, _gridsam__getJobStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__getJobStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__getJobStatus(struct soap *soap, _gridsam__getJobStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__getJobStatus);
	if (soap_out_PointerTo_gridsam__getJobStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__getJobStatus(struct soap *soap, const char *tag, int id, _gridsam__getJobStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__getJobStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__getJobStatus ** SOAP_FMAC4 soap_get_PointerTo_gridsam__getJobStatus(struct soap *soap, _gridsam__getJobStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__getJobStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__getJobStatus ** SOAP_FMAC4 soap_in_PointerTo_gridsam__getJobStatus(struct soap *soap, const char *tag, _gridsam__getJobStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__getJobStatus **)soap_malloc(soap, sizeof(_gridsam__getJobStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__getJobStatus *)soap_instantiate__gridsam__getJobStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__getJobStatus ** p = (_gridsam__getJobStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__getJobStatus, sizeof(_gridsam__getJobStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__startJobResponse(struct soap *soap, _gridsam__startJobResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__startJobResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__startJobResponse(struct soap *soap, _gridsam__startJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__startJobResponse);
	if (soap_out_PointerTo_gridsam__startJobResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__startJobResponse(struct soap *soap, const char *tag, int id, _gridsam__startJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__startJobResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__startJobResponse ** SOAP_FMAC4 soap_get_PointerTo_gridsam__startJobResponse(struct soap *soap, _gridsam__startJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__startJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__startJobResponse ** SOAP_FMAC4 soap_in_PointerTo_gridsam__startJobResponse(struct soap *soap, const char *tag, _gridsam__startJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__startJobResponse **)soap_malloc(soap, sizeof(_gridsam__startJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__startJobResponse *)soap_instantiate__gridsam__startJobResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__startJobResponse ** p = (_gridsam__startJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__startJobResponse, sizeof(_gridsam__startJobResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__startJob(struct soap *soap, _gridsam__startJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__startJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__startJob(struct soap *soap, _gridsam__startJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__startJob);
	if (soap_out_PointerTo_gridsam__startJob(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__startJob(struct soap *soap, const char *tag, int id, _gridsam__startJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__startJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__startJob ** SOAP_FMAC4 soap_get_PointerTo_gridsam__startJob(struct soap *soap, _gridsam__startJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__startJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__startJob ** SOAP_FMAC4 soap_in_PointerTo_gridsam__startJob(struct soap *soap, const char *tag, _gridsam__startJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__startJob **)soap_malloc(soap, sizeof(_gridsam__startJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__startJob *)soap_instantiate__gridsam__startJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__startJob ** p = (_gridsam__startJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__startJob, sizeof(_gridsam__startJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__terminateJobResponse(struct soap *soap, _gridsam__terminateJobResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__terminateJobResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__terminateJobResponse(struct soap *soap, _gridsam__terminateJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__terminateJobResponse);
	if (soap_out_PointerTo_gridsam__terminateJobResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__terminateJobResponse(struct soap *soap, const char *tag, int id, _gridsam__terminateJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__terminateJobResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__terminateJobResponse ** SOAP_FMAC4 soap_get_PointerTo_gridsam__terminateJobResponse(struct soap *soap, _gridsam__terminateJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__terminateJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__terminateJobResponse ** SOAP_FMAC4 soap_in_PointerTo_gridsam__terminateJobResponse(struct soap *soap, const char *tag, _gridsam__terminateJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__terminateJobResponse **)soap_malloc(soap, sizeof(_gridsam__terminateJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__terminateJobResponse *)soap_instantiate__gridsam__terminateJobResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__terminateJobResponse ** p = (_gridsam__terminateJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__terminateJobResponse, sizeof(_gridsam__terminateJobResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__terminateJob(struct soap *soap, _gridsam__terminateJob *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__terminateJob))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__terminateJob(struct soap *soap, _gridsam__terminateJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__terminateJob);
	if (soap_out_PointerTo_gridsam__terminateJob(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__terminateJob(struct soap *soap, const char *tag, int id, _gridsam__terminateJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__terminateJob);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__terminateJob ** SOAP_FMAC4 soap_get_PointerTo_gridsam__terminateJob(struct soap *soap, _gridsam__terminateJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__terminateJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__terminateJob ** SOAP_FMAC4 soap_in_PointerTo_gridsam__terminateJob(struct soap *soap, const char *tag, _gridsam__terminateJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__terminateJob **)soap_malloc(soap, sizeof(_gridsam__terminateJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__terminateJob *)soap_instantiate__gridsam__terminateJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__terminateJob ** p = (_gridsam__terminateJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__terminateJob, sizeof(_gridsam__terminateJob), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__UnknownJobFault(struct soap *soap, _gridsam__UnknownJobFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__UnknownJobFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__UnknownJobFault(struct soap *soap, _gridsam__UnknownJobFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__UnknownJobFault);
	if (soap_out_PointerTo_gridsam__UnknownJobFault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__UnknownJobFault(struct soap *soap, const char *tag, int id, _gridsam__UnknownJobFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__UnknownJobFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__UnknownJobFault ** SOAP_FMAC4 soap_get_PointerTo_gridsam__UnknownJobFault(struct soap *soap, _gridsam__UnknownJobFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__UnknownJobFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__UnknownJobFault ** SOAP_FMAC4 soap_in_PointerTo_gridsam__UnknownJobFault(struct soap *soap, const char *tag, _gridsam__UnknownJobFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__UnknownJobFault **)soap_malloc(soap, sizeof(_gridsam__UnknownJobFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__UnknownJobFault *)soap_instantiate__gridsam__UnknownJobFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__UnknownJobFault ** p = (_gridsam__UnknownJobFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__UnknownJobFault, sizeof(_gridsam__UnknownJobFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam2__UserName_USCOREType(struct soap *soap, gridsam2__UserName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam2__UserName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam2__UserName_USCOREType(struct soap *soap, gridsam2__UserName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam2__UserName_USCOREType);
	if (soap_out_PointerTogridsam2__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam2__UserName_USCOREType(struct soap *soap, const char *tag, int id, gridsam2__UserName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam2__UserName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam2__UserName_USCOREType ** SOAP_FMAC4 soap_get_PointerTogridsam2__UserName_USCOREType(struct soap *soap, gridsam2__UserName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam2__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam2__UserName_USCOREType ** SOAP_FMAC4 soap_in_PointerTogridsam2__UserName_USCOREType(struct soap *soap, const char *tag, gridsam2__UserName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam2__UserName_USCOREType **)soap_malloc(soap, sizeof(gridsam2__UserName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam2__UserName_USCOREType *)soap_instantiate_gridsam2__UserName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam2__UserName_USCOREType ** p = (gridsam2__UserName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam2__UserName_USCOREType, sizeof(gridsam2__UserName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam2__Environment_USCOREType(struct soap *soap, gridsam2__Environment_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam2__Environment_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam2__Environment_USCOREType(struct soap *soap, gridsam2__Environment_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam2__Environment_USCOREType);
	if (soap_out_PointerTogridsam2__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam2__Environment_USCOREType(struct soap *soap, const char *tag, int id, gridsam2__Environment_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam2__Environment_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam2__Environment_USCOREType ** SOAP_FMAC4 soap_get_PointerTogridsam2__Environment_USCOREType(struct soap *soap, gridsam2__Environment_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam2__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam2__Environment_USCOREType ** SOAP_FMAC4 soap_in_PointerTogridsam2__Environment_USCOREType(struct soap *soap, const char *tag, gridsam2__Environment_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam2__Environment_USCOREType **)soap_malloc(soap, sizeof(gridsam2__Environment_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam2__Environment_USCOREType *)soap_instantiate_gridsam2__Environment_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam2__Environment_USCOREType ** p = (gridsam2__Environment_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam2__Environment_USCOREType, sizeof(gridsam2__Environment_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam2__DirectoryName_USCOREType(struct soap *soap, gridsam2__DirectoryName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam2__DirectoryName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam2__DirectoryName_USCOREType(struct soap *soap, gridsam2__DirectoryName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam2__DirectoryName_USCOREType);
	if (soap_out_PointerTogridsam2__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam2__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, gridsam2__DirectoryName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam2__DirectoryName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam2__DirectoryName_USCOREType ** SOAP_FMAC4 soap_get_PointerTogridsam2__DirectoryName_USCOREType(struct soap *soap, gridsam2__DirectoryName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam2__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam2__DirectoryName_USCOREType ** SOAP_FMAC4 soap_in_PointerTogridsam2__DirectoryName_USCOREType(struct soap *soap, const char *tag, gridsam2__DirectoryName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam2__DirectoryName_USCOREType **)soap_malloc(soap, sizeof(gridsam2__DirectoryName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam2__DirectoryName_USCOREType *)soap_instantiate_gridsam2__DirectoryName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam2__DirectoryName_USCOREType ** p = (gridsam2__DirectoryName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam2__DirectoryName_USCOREType, sizeof(gridsam2__DirectoryName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam2__Argument_USCOREType(struct soap *soap, gridsam2__Argument_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam2__Argument_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam2__Argument_USCOREType(struct soap *soap, gridsam2__Argument_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam2__Argument_USCOREType);
	if (soap_out_PointerTogridsam2__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam2__Argument_USCOREType(struct soap *soap, const char *tag, int id, gridsam2__Argument_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam2__Argument_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam2__Argument_USCOREType ** SOAP_FMAC4 soap_get_PointerTogridsam2__Argument_USCOREType(struct soap *soap, gridsam2__Argument_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam2__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam2__Argument_USCOREType ** SOAP_FMAC4 soap_in_PointerTogridsam2__Argument_USCOREType(struct soap *soap, const char *tag, gridsam2__Argument_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam2__Argument_USCOREType **)soap_malloc(soap, sizeof(gridsam2__Argument_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam2__Argument_USCOREType *)soap_instantiate_gridsam2__Argument_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam2__Argument_USCOREType ** p = (gridsam2__Argument_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam2__Argument_USCOREType, sizeof(gridsam2__Argument_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam2__FileName_USCOREType(struct soap *soap, gridsam2__FileName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam2__FileName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam2__FileName_USCOREType(struct soap *soap, gridsam2__FileName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam2__FileName_USCOREType);
	if (soap_out_PointerTogridsam2__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam2__FileName_USCOREType(struct soap *soap, const char *tag, int id, gridsam2__FileName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam2__FileName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam2__FileName_USCOREType ** SOAP_FMAC4 soap_get_PointerTogridsam2__FileName_USCOREType(struct soap *soap, gridsam2__FileName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam2__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam2__FileName_USCOREType ** SOAP_FMAC4 soap_in_PointerTogridsam2__FileName_USCOREType(struct soap *soap, const char *tag, gridsam2__FileName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam2__FileName_USCOREType **)soap_malloc(soap, sizeof(gridsam2__FileName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam2__FileName_USCOREType *)soap_instantiate_gridsam2__FileName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam2__FileName_USCOREType ** p = (gridsam2__FileName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam2__FileName_USCOREType, sizeof(gridsam2__FileName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__GroupName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__GroupName_USCOREType);
	if (soap_out_PointerTojsdlposix__GroupName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__GroupName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__GroupName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, jsdlposix__GroupName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__GroupName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdlposix__GroupName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__GroupName_USCOREType(struct soap *soap, const char *tag, jsdlposix__GroupName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__GroupName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__GroupName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__GroupName_USCOREType *)soap_instantiate_jsdlposix__GroupName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__GroupName_USCOREType ** p = (jsdlposix__GroupName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__GroupName_USCOREType, sizeof(jsdlposix__GroupName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__UserName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__UserName_USCOREType);
	if (soap_out_PointerTojsdlposix__UserName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__UserName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__UserName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, jsdlposix__UserName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__UserName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdlposix__UserName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__UserName_USCOREType(struct soap *soap, const char *tag, jsdlposix__UserName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__UserName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__UserName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__UserName_USCOREType *)soap_instantiate_jsdlposix__UserName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__UserName_USCOREType ** p = (jsdlposix__UserName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__UserName_USCOREType, sizeof(jsdlposix__UserName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__Limits_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__Limits_USCOREType);
	if (soap_out_PointerTojsdlposix__Limits_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__Limits_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__Limits_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, jsdlposix__Limits_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__Limits_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdlposix__Limits_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__Limits_USCOREType(struct soap *soap, const char *tag, jsdlposix__Limits_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__Limits_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__Limits_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__Limits_USCOREType *)soap_instantiate_jsdlposix__Limits_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__Limits_USCOREType ** p = (jsdlposix__Limits_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__Limits_USCOREType, sizeof(jsdlposix__Limits_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__Environment_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__Environment_USCOREType);
	if (soap_out_PointerTojsdlposix__Environment_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__Environment_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__Environment_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, jsdlposix__Environment_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__Environment_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdlposix__Environment_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, jsdlposix__Environment_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__Environment_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__Environment_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__Environment_USCOREType *)soap_instantiate_jsdlposix__Environment_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__Environment_USCOREType ** p = (jsdlposix__Environment_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__Environment_USCOREType, sizeof(jsdlposix__Environment_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__DirectoryName_USCOREType);
	if (soap_out_PointerTojsdlposix__DirectoryName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__DirectoryName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, jsdlposix__DirectoryName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__DirectoryName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdlposix__DirectoryName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__DirectoryName_USCOREType(struct soap *soap, const char *tag, jsdlposix__DirectoryName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__DirectoryName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__DirectoryName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__DirectoryName_USCOREType *)soap_instantiate_jsdlposix__DirectoryName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__DirectoryName_USCOREType ** p = (jsdlposix__DirectoryName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__DirectoryName_USCOREType, sizeof(jsdlposix__DirectoryName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__Argument_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__Argument_USCOREType);
	if (soap_out_PointerTojsdlposix__Argument_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__Argument_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__Argument_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, jsdlposix__Argument_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__Argument_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdlposix__Argument_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, jsdlposix__Argument_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__Argument_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__Argument_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__Argument_USCOREType *)soap_instantiate_jsdlposix__Argument_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__Argument_USCOREType ** p = (jsdlposix__Argument_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__Argument_USCOREType, sizeof(jsdlposix__Argument_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdlposix__FileName_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdlposix__FileName_USCOREType);
	if (soap_out_PointerTojsdlposix__FileName_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, int id, jsdlposix__FileName_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdlposix__FileName_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, jsdlposix__FileName_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdlposix__FileName_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdlposix__FileName_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdlposix__FileName_USCOREType(struct soap *soap, const char *tag, jsdlposix__FileName_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdlposix__FileName_USCOREType **)soap_malloc(soap, sizeof(jsdlposix__FileName_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdlposix__FileName_USCOREType *)soap_instantiate_jsdlposix__FileName_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdlposix__FileName_USCOREType ** p = (jsdlposix__FileName_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdlposix__FileName_USCOREType, sizeof(jsdlposix__FileName_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__SourceTarget_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__SourceTarget_USCOREType);
	if (soap_out_PointerTojsdl__SourceTarget_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, int id, jsdl__SourceTarget_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__SourceTarget_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, jsdl__SourceTarget_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__SourceTarget_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__SourceTarget_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__SourceTarget_USCOREType(struct soap *soap, const char *tag, jsdl__SourceTarget_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__SourceTarget_USCOREType **)soap_malloc(soap, sizeof(jsdl__SourceTarget_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__SourceTarget_USCOREType *)soap_instantiate_jsdl__SourceTarget_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__SourceTarget_USCOREType ** p = (jsdl__SourceTarget_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__SourceTarget_USCOREType, sizeof(jsdl__SourceTarget_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__NCName);
	if (soap_out_PointerToxsd__NCName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystemType_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystemType_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, jsdl__OperatingSystemType_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystemType_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__OperatingSystemType_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystemType_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystemType_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystemType_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystemType_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystemType_USCOREType *)soap_instantiate_jsdl__OperatingSystemType_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystemType_USCOREType ** p = (jsdl__OperatingSystemType_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystemType_USCOREType, sizeof(jsdl__OperatingSystemType_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystemTypeEnumeration);
	if (soap_out_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, int id, enum jsdl__FileSystemTypeEnumeration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystemTypeEnumeration);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__FileSystemTypeEnumeration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, enum jsdl__FileSystemTypeEnumeration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystemTypeEnumeration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum jsdl__FileSystemTypeEnumeration ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystemTypeEnumeration(struct soap *soap, const char *tag, enum jsdl__FileSystemTypeEnumeration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum jsdl__FileSystemTypeEnumeration **)soap_malloc(soap, sizeof(enum jsdl__FileSystemTypeEnumeration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__FileSystemTypeEnumeration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum jsdl__FileSystemTypeEnumeration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystemTypeEnumeration, sizeof(enum jsdl__FileSystemTypeEnumeration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__RangeValue_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__RangeValue_USCOREType);
	if (soap_out_PointerTojsdl__RangeValue_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, int id, jsdl__RangeValue_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__RangeValue_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, jsdl__RangeValue_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__RangeValue_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__RangeValue_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__RangeValue_USCOREType(struct soap *soap, const char *tag, jsdl__RangeValue_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__RangeValue_USCOREType **)soap_malloc(soap, sizeof(jsdl__RangeValue_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__RangeValue_USCOREType *)soap_instantiate_jsdl__RangeValue_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__RangeValue_USCOREType ** p = (jsdl__RangeValue_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__RangeValue_USCOREType, sizeof(jsdl__RangeValue_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CPUArchitecture_USCOREType);
	if (soap_out_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CPUArchitecture_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, jsdl__CPUArchitecture_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CPUArchitecture_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__CPUArchitecture_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CPUArchitecture_USCOREType(struct soap *soap, const char *tag, jsdl__CPUArchitecture_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CPUArchitecture_USCOREType **)soap_malloc(soap, sizeof(jsdl__CPUArchitecture_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CPUArchitecture_USCOREType *)soap_instantiate_jsdl__CPUArchitecture_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CPUArchitecture_USCOREType ** p = (jsdl__CPUArchitecture_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CPUArchitecture_USCOREType, sizeof(jsdl__CPUArchitecture_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__OperatingSystem_USCOREType);
	if (soap_out_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__OperatingSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__OperatingSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, jsdl__OperatingSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__OperatingSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__OperatingSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__OperatingSystem_USCOREType(struct soap *soap, const char *tag, jsdl__OperatingSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__OperatingSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__OperatingSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__OperatingSystem_USCOREType *)soap_instantiate_jsdl__OperatingSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__OperatingSystem_USCOREType ** p = (jsdl__OperatingSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__OperatingSystem_USCOREType, sizeof(jsdl__OperatingSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__FileSystem_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__FileSystem_USCOREType);
	if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, jsdl__FileSystem_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__FileSystem_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, jsdl__FileSystem_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__FileSystem_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, jsdl__FileSystem_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__FileSystem_USCOREType **)soap_malloc(soap, sizeof(jsdl__FileSystem_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__FileSystem_USCOREType *)soap_instantiate_jsdl__FileSystem_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__FileSystem_USCOREType ** p = (jsdl__FileSystem_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__CandidateHosts_USCOREType);
	if (soap_out_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, int id, jsdl__CandidateHosts_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__CandidateHosts_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, jsdl__CandidateHosts_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__CandidateHosts_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__CandidateHosts_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__CandidateHosts_USCOREType(struct soap *soap, const char *tag, jsdl__CandidateHosts_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__CandidateHosts_USCOREType **)soap_malloc(soap, sizeof(jsdl__CandidateHosts_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__CandidateHosts_USCOREType *)soap_instantiate_jsdl__CandidateHosts_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__CandidateHosts_USCOREType ** p = (jsdl__CandidateHosts_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__CandidateHosts_USCOREType, sizeof(jsdl__CandidateHosts_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Description_USCOREType))
		soap_serialize_jsdl__Description_USCOREType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Description_USCOREType);
	if (soap_out_PointerTojsdl__Description_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Description_USCOREType);
	if (id < 0)
		return soap->error;
	return soap_out_jsdl__Description_USCOREType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTojsdl__Description_USCOREType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Description_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTojsdl__Description_USCOREType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_jsdl__Description_USCOREType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Description_USCOREType, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__DataStaging_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__DataStaging_USCOREType);
	if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, jsdl__DataStaging_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__DataStaging_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, jsdl__DataStaging_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__DataStaging_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, jsdl__DataStaging_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__DataStaging_USCOREType **)soap_malloc(soap, sizeof(jsdl__DataStaging_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__DataStaging_USCOREType *)soap_instantiate_jsdl__DataStaging_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__DataStaging_USCOREType ** p = (jsdl__DataStaging_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Resources_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Resources_USCOREType);
	if (soap_out_PointerTojsdl__Resources_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Resources_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Resources_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Resources_USCOREType(struct soap *soap, jsdl__Resources_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Resources_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Resources_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Resources_USCOREType(struct soap *soap, const char *tag, jsdl__Resources_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Resources_USCOREType **)soap_malloc(soap, sizeof(jsdl__Resources_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Resources_USCOREType *)soap_instantiate_jsdl__Resources_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Resources_USCOREType ** p = (jsdl__Resources_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Resources_USCOREType, sizeof(jsdl__Resources_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Application_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Application_USCOREType);
	if (soap_out_PointerTojsdl__Application_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Application_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Application_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Application_USCOREType(struct soap *soap, jsdl__Application_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Application_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Application_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Application_USCOREType(struct soap *soap, const char *tag, jsdl__Application_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Application_USCOREType **)soap_malloc(soap, sizeof(jsdl__Application_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Application_USCOREType *)soap_instantiate_jsdl__Application_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Application_USCOREType ** p = (jsdl__Application_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Application_USCOREType, sizeof(jsdl__Application_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobIdentification_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobIdentification_USCOREType);
	if (soap_out_PointerTojsdl__JobIdentification_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobIdentification_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobIdentification_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, jsdl__JobIdentification_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobIdentification_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobIdentification_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobIdentification_USCOREType(struct soap *soap, const char *tag, jsdl__JobIdentification_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobIdentification_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobIdentification_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobIdentification_USCOREType *)soap_instantiate_jsdl__JobIdentification_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobIdentification_USCOREType ** p = (jsdl__JobIdentification_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobIdentification_USCOREType, sizeof(jsdl__JobIdentification_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ID(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__ID))
		soap_serialize_xsd__ID(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ID(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__ID);
	if (soap_out_PointerToxsd__ID(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ID(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__ID);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__ID(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ID(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__ID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ID(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__ID(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__ID, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDescription_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDescription_USCOREType);
	if (soap_out_PointerTojsdl__JobDescription_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDescription_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDescription_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, jsdl__JobDescription_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDescription_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobDescription_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDescription_USCOREType(struct soap *soap, const char *tag, jsdl__JobDescription_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDescription_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDescription_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDescription_USCOREType *)soap_instantiate_jsdl__JobDescription_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDescription_USCOREType ** p = (jsdl__JobDescription_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDescription_USCOREType, sizeof(jsdl__JobDescription_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Range_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Range_USCOREType);
	if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Range_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Range_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Range_USCOREType(struct soap *soap, jsdl__Range_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Range_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Range_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, jsdl__Range_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Range_USCOREType **)soap_malloc(soap, sizeof(jsdl__Range_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Range_USCOREType *)soap_instantiate_jsdl__Range_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Range_USCOREType ** p = (jsdl__Range_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Exact_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Exact_USCOREType);
	if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Exact_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Exact_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Exact_USCOREType(struct soap *soap, jsdl__Exact_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Exact_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, jsdl__Exact_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Exact_USCOREType **)soap_malloc(soap, sizeof(jsdl__Exact_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Exact_USCOREType *)soap_instantiate_jsdl__Exact_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Exact_USCOREType ** p = (jsdl__Exact_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__Boundary_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__Boundary_USCOREType);
	if (soap_out_PointerTojsdl__Boundary_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, int id, jsdl__Boundary_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__Boundary_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__Boundary_USCOREType(struct soap *soap, jsdl__Boundary_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__Boundary_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__Boundary_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__Boundary_USCOREType(struct soap *soap, const char *tag, jsdl__Boundary_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__Boundary_USCOREType **)soap_malloc(soap, sizeof(jsdl__Boundary_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__Boundary_USCOREType *)soap_instantiate_jsdl__Boundary_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__Boundary_USCOREType ** p = (jsdl__Boundary_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__Boundary_USCOREType, sizeof(jsdl__Boundary_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam__JobStatusType(struct soap *soap, gridsam__JobStatusType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam__JobStatusType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam__JobStatusType(struct soap *soap, gridsam__JobStatusType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam__JobStatusType);
	if (soap_out_PointerTogridsam__JobStatusType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam__JobStatusType(struct soap *soap, const char *tag, int id, gridsam__JobStatusType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam__JobStatusType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam__JobStatusType ** SOAP_FMAC4 soap_get_PointerTogridsam__JobStatusType(struct soap *soap, gridsam__JobStatusType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam__JobStatusType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam__JobStatusType ** SOAP_FMAC4 soap_in_PointerTogridsam__JobStatusType(struct soap *soap, const char *tag, gridsam__JobStatusType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam__JobStatusType **)soap_malloc(soap, sizeof(gridsam__JobStatusType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam__JobStatusType *)soap_instantiate_gridsam__JobStatusType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam__JobStatusType ** p = (gridsam__JobStatusType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam__JobStatusType, sizeof(gridsam__JobStatusType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam__JobDescriptionType(struct soap *soap, gridsam__JobDescriptionType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam__JobDescriptionType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam__JobDescriptionType(struct soap *soap, gridsam__JobDescriptionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam__JobDescriptionType);
	if (soap_out_PointerTogridsam__JobDescriptionType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam__JobDescriptionType(struct soap *soap, const char *tag, int id, gridsam__JobDescriptionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam__JobDescriptionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam__JobDescriptionType ** SOAP_FMAC4 soap_get_PointerTogridsam__JobDescriptionType(struct soap *soap, gridsam__JobDescriptionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam__JobDescriptionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam__JobDescriptionType ** SOAP_FMAC4 soap_in_PointerTogridsam__JobDescriptionType(struct soap *soap, const char *tag, gridsam__JobDescriptionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam__JobDescriptionType **)soap_malloc(soap, sizeof(gridsam__JobDescriptionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam__JobDescriptionType *)soap_instantiate_gridsam__JobDescriptionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam__JobDescriptionType ** p = (gridsam__JobDescriptionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam__JobDescriptionType, sizeof(gridsam__JobDescriptionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_jsdl__JobDefinition_USCOREType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTojsdl__JobDefinition_USCOREType);
	if (soap_out_PointerTojsdl__JobDefinition_USCOREType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, int id, jsdl__JobDefinition_USCOREType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_jsdl__JobDefinition_USCOREType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_get_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, jsdl__JobDefinition_USCOREType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTojsdl__JobDefinition_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 jsdl__JobDefinition_USCOREType ** SOAP_FMAC4 soap_in_PointerTojsdl__JobDefinition_USCOREType(struct soap *soap, const char *tag, jsdl__JobDefinition_USCOREType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (jsdl__JobDefinition_USCOREType **)soap_malloc(soap, sizeof(jsdl__JobDefinition_USCOREType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (jsdl__JobDefinition_USCOREType *)soap_instantiate_jsdl__JobDefinition_USCOREType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	jsdl__JobDefinition_USCOREType ** p = (jsdl__JobDefinition_USCOREType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_jsdl__JobDefinition_USCOREType, sizeof(jsdl__JobDefinition_USCOREType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__Property(struct soap *soap, _gridsam__Property *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__Property))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__Property(struct soap *soap, _gridsam__Property *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__Property);
	if (soap_out_PointerTo_gridsam__Property(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__Property(struct soap *soap, const char *tag, int id, _gridsam__Property *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__Property);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__Property ** SOAP_FMAC4 soap_get_PointerTo_gridsam__Property(struct soap *soap, _gridsam__Property **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__Property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__Property ** SOAP_FMAC4 soap_in_PointerTo_gridsam__Property(struct soap *soap, const char *tag, _gridsam__Property **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__Property **)soap_malloc(soap, sizeof(_gridsam__Property *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__Property *)soap_instantiate__gridsam__Property(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__Property ** p = (_gridsam__Property **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__Property, sizeof(_gridsam__Property), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_gridsam__Stage(struct soap *soap, _gridsam__Stage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__gridsam__Stage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_gridsam__Stage(struct soap *soap, _gridsam__Stage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_gridsam__Stage);
	if (soap_out_PointerTo_gridsam__Stage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_gridsam__Stage(struct soap *soap, const char *tag, int id, _gridsam__Stage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__gridsam__Stage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _gridsam__Stage ** SOAP_FMAC4 soap_get_PointerTo_gridsam__Stage(struct soap *soap, _gridsam__Stage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_gridsam__Stage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _gridsam__Stage ** SOAP_FMAC4 soap_in_PointerTo_gridsam__Stage(struct soap *soap, const char *tag, _gridsam__Stage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_gridsam__Stage **)soap_malloc(soap, sizeof(_gridsam__Stage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_gridsam__Stage *)soap_instantiate__gridsam__Stage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_gridsam__Stage ** p = (_gridsam__Stage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__gridsam__Stage, sizeof(_gridsam__Stage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogridsam__JobIdentifierType(struct soap *soap, gridsam__JobIdentifierType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_gridsam__JobIdentifierType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogridsam__JobIdentifierType(struct soap *soap, gridsam__JobIdentifierType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogridsam__JobIdentifierType);
	if (soap_out_PointerTogridsam__JobIdentifierType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogridsam__JobIdentifierType(struct soap *soap, const char *tag, int id, gridsam__JobIdentifierType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_gridsam__JobIdentifierType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 gridsam__JobIdentifierType ** SOAP_FMAC4 soap_get_PointerTogridsam__JobIdentifierType(struct soap *soap, gridsam__JobIdentifierType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogridsam__JobIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 gridsam__JobIdentifierType ** SOAP_FMAC4 soap_in_PointerTogridsam__JobIdentifierType(struct soap *soap, const char *tag, gridsam__JobIdentifierType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (gridsam__JobIdentifierType **)soap_malloc(soap, sizeof(gridsam__JobIdentifierType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (gridsam__JobIdentifierType *)soap_instantiate_gridsam__JobIdentifierType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	gridsam__JobIdentifierType ** p = (gridsam__JobIdentifierType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_gridsam__JobIdentifierType, sizeof(gridsam__JobIdentifierType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, std::vector<gridsam2__Environment_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, const std::vector<gridsam2__Environment_USCOREType * >*a)
{
	for (std::vector<gridsam2__Environment_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTogridsam2__Environment_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<gridsam2__Environment_USCOREType * >*a, const char *type)
{
	for (std::vector<gridsam2__Environment_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTogridsam2__Environment_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<gridsam2__Environment_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, const char *tag, std::vector<gridsam2__Environment_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(soap, -1)))
		return NULL;
	gridsam2__Environment_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_gridsam2__Environment_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType, sizeof(gridsam2__Environment_USCOREType), 1))
				break;
			if (!soap_in_PointerTogridsam2__Environment_USCOREType(soap, tag, NULL, "gridsam2:Environment_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTogridsam2__Environment_USCOREType(soap, tag, &n, "gridsam2:Environment_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<gridsam2__Environment_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, std::vector<gridsam2__Environment_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<gridsam2__Environment_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<gridsam2__Environment_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<gridsam2__Environment_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<gridsam2__Environment_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<gridsam2__Environment_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<gridsam2__Environment_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTogridsam2__Environment_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<gridsam2__Environment_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<gridsam2__Environment_USCOREType * >*)p = *(std::vector<gridsam2__Environment_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, std::vector<gridsam2__Argument_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, const std::vector<gridsam2__Argument_USCOREType * >*a)
{
	for (std::vector<gridsam2__Argument_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTogridsam2__Argument_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<gridsam2__Argument_USCOREType * >*a, const char *type)
{
	for (std::vector<gridsam2__Argument_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTogridsam2__Argument_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<gridsam2__Argument_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, const char *tag, std::vector<gridsam2__Argument_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(soap, -1)))
		return NULL;
	gridsam2__Argument_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_gridsam2__Argument_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType, sizeof(gridsam2__Argument_USCOREType), 1))
				break;
			if (!soap_in_PointerTogridsam2__Argument_USCOREType(soap, tag, NULL, "gridsam2:Argument_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTogridsam2__Argument_USCOREType(soap, tag, &n, "gridsam2:Argument_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<gridsam2__Argument_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, std::vector<gridsam2__Argument_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<gridsam2__Argument_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<gridsam2__Argument_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<gridsam2__Argument_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<gridsam2__Argument_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<gridsam2__Argument_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<gridsam2__Argument_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTogridsam2__Argument_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<gridsam2__Argument_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<gridsam2__Argument_USCOREType * >*)p = *(std::vector<gridsam2__Argument_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, std::vector<jsdlposix__Environment_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, const std::vector<jsdlposix__Environment_USCOREType * >*a)
{
	for (std::vector<jsdlposix__Environment_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdlposix__Environment_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdlposix__Environment_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdlposix__Environment_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdlposix__Environment_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdlposix__Environment_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, const char *tag, std::vector<jsdlposix__Environment_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, -1)))
		return NULL;
	jsdlposix__Environment_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdlposix__Environment_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType, sizeof(jsdlposix__Environment_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdlposix__Environment_USCOREType(soap, tag, NULL, "jsdlposix:Environment_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdlposix__Environment_USCOREType(soap, tag, &n, "jsdlposix:Environment_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdlposix__Environment_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, std::vector<jsdlposix__Environment_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdlposix__Environment_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdlposix__Environment_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdlposix__Environment_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdlposix__Environment_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdlposix__Environment_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdlposix__Environment_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdlposix__Environment_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdlposix__Environment_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdlposix__Environment_USCOREType * >*)p = *(std::vector<jsdlposix__Environment_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, std::vector<jsdlposix__Argument_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, const std::vector<jsdlposix__Argument_USCOREType * >*a)
{
	for (std::vector<jsdlposix__Argument_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdlposix__Argument_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdlposix__Argument_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdlposix__Argument_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdlposix__Argument_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdlposix__Argument_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, const char *tag, std::vector<jsdlposix__Argument_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, -1)))
		return NULL;
	jsdlposix__Argument_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdlposix__Argument_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType, sizeof(jsdlposix__Argument_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdlposix__Argument_USCOREType(soap, tag, NULL, "jsdlposix:Argument_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdlposix__Argument_USCOREType(soap, tag, &n, "jsdlposix:Argument_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdlposix__Argument_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, std::vector<jsdlposix__Argument_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdlposix__Argument_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdlposix__Argument_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdlposix__Argument_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdlposix__Argument_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdlposix__Argument_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdlposix__Argument_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdlposix__Argument_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdlposix__Argument_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdlposix__Argument_USCOREType * >*)p = *(std::vector<jsdlposix__Argument_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, std::vector<jsdl__FileSystem_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const std::vector<jsdl__FileSystem_USCOREType * >*a)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__FileSystem_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__FileSystem_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__FileSystem_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__FileSystem_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__FileSystem_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, -1)))
		return NULL;
	jsdl__FileSystem_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__FileSystem_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, sizeof(jsdl__FileSystem_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, NULL, "jsdl:FileSystem_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__FileSystem_USCOREType(soap, tag, &n, "jsdl:FileSystem_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__FileSystem_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, std::vector<jsdl__FileSystem_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__FileSystem_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__FileSystem_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__FileSystem_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__FileSystem_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__FileSystem_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__FileSystem_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__FileSystem_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__FileSystem_USCOREType * >*)p = *(std::vector<jsdl__FileSystem_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, std::vector<jsdl__DataStaging_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const std::vector<jsdl__DataStaging_USCOREType * >*a)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__DataStaging_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__DataStaging_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__DataStaging_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__DataStaging_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__DataStaging_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, -1)))
		return NULL;
	jsdl__DataStaging_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__DataStaging_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, sizeof(jsdl__DataStaging_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, NULL, "jsdl:DataStaging_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__DataStaging_USCOREType(soap, tag, &n, "jsdl:DataStaging_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__DataStaging_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, std::vector<jsdl__DataStaging_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__DataStaging_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__DataStaging_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__DataStaging_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__DataStaging_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__DataStaging_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__DataStaging_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__DataStaging_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__DataStaging_USCOREType * >*)p = *(std::vector<jsdl__DataStaging_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!soap_inliteral(soap, tag, NULL))
				break;
		}
		else
		{
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, std::vector<jsdl__Range_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const std::vector<jsdl__Range_USCOREType * >*a)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Range_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Range_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Range_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Range_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Range_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, -1)))
		return NULL;
	jsdl__Range_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__Range_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, sizeof(jsdl__Range_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, NULL, "jsdl:Range_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Range_USCOREType(soap, tag, &n, "jsdl:Range_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__Range_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, std::vector<jsdl__Range_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__Range_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Range_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__Range_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__Range_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Range_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Range_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Range_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Range_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Range_USCOREType * >*)p = *(std::vector<jsdl__Range_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, std::vector<jsdl__Exact_USCOREType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const std::vector<jsdl__Exact_USCOREType * >*a)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTojsdl__Exact_USCOREType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, int id, const std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	for (std::vector<jsdl__Exact_USCOREType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTojsdl__Exact_USCOREType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<jsdl__Exact_USCOREType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, const char *tag, std::vector<jsdl__Exact_USCOREType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, -1)))
		return NULL;
	jsdl__Exact_USCOREType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_jsdl__Exact_USCOREType, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, sizeof(jsdl__Exact_USCOREType), 1))
				break;
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, NULL, "jsdl:Exact_Type"))
				break;
		}
		else
		{
			if (!soap_in_PointerTojsdl__Exact_USCOREType(soap, tag, &n, "jsdl:Exact_Type"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<jsdl__Exact_USCOREType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, std::vector<jsdl__Exact_USCOREType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<jsdl__Exact_USCOREType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<jsdl__Exact_USCOREType * >;
		if (size)
			*size = sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<jsdl__Exact_USCOREType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<jsdl__Exact_USCOREType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<jsdl__Exact_USCOREType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTojsdl__Exact_USCOREType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<jsdl__Exact_USCOREType * > %p -> %p\n", q, p));
	*(std::vector<jsdl__Exact_USCOREType * >*)p = *(std::vector<jsdl__Exact_USCOREType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, std::vector<gridsam__JobStatusType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, const std::vector<gridsam__JobStatusType * >*a)
{
	for (std::vector<gridsam__JobStatusType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTogridsam__JobStatusType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, const char *tag, int id, const std::vector<gridsam__JobStatusType * >*a, const char *type)
{
	for (std::vector<gridsam__JobStatusType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTogridsam__JobStatusType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<gridsam__JobStatusType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, const char *tag, std::vector<gridsam__JobStatusType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, -1)))
		return NULL;
	gridsam__JobStatusType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_gridsam__JobStatusType, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobStatusType, sizeof(gridsam__JobStatusType), 1))
				break;
			if (!soap_in_PointerTogridsam__JobStatusType(soap, tag, NULL, "gridsam:JobStatusType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTogridsam__JobStatusType(soap, tag, &n, "gridsam:JobStatusType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<gridsam__JobStatusType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobStatusType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, std::vector<gridsam__JobStatusType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<gridsam__JobStatusType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobStatusType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobStatusType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<gridsam__JobStatusType * >;
		if (size)
			*size = sizeof(std::vector<gridsam__JobStatusType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<gridsam__JobStatusType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<gridsam__JobStatusType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<gridsam__JobStatusType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTogridsam__JobStatusType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<gridsam__JobStatusType * > %p -> %p\n", q, p));
	*(std::vector<gridsam__JobStatusType * >*)p = *(std::vector<gridsam__JobStatusType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, std::vector<gridsam__JobIdentifierType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, const std::vector<gridsam__JobIdentifierType * >*a)
{
	for (std::vector<gridsam__JobIdentifierType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTogridsam__JobIdentifierType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, const char *tag, int id, const std::vector<gridsam__JobIdentifierType * >*a, const char *type)
{
	for (std::vector<gridsam__JobIdentifierType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTogridsam__JobIdentifierType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<gridsam__JobIdentifierType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, const char *tag, std::vector<gridsam__JobIdentifierType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, -1)))
		return NULL;
	gridsam__JobIdentifierType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_gridsam__JobIdentifierType, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobIdentifierType, sizeof(gridsam__JobIdentifierType), 1))
				break;
			if (!soap_in_PointerTogridsam__JobIdentifierType(soap, tag, NULL, "gridsam:JobIdentifierType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTogridsam__JobIdentifierType(soap, tag, &n, "gridsam:JobIdentifierType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<gridsam__JobIdentifierType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, std::vector<gridsam__JobIdentifierType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<gridsam__JobIdentifierType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobIdentifierType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<gridsam__JobIdentifierType * >;
		if (size)
			*size = sizeof(std::vector<gridsam__JobIdentifierType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<gridsam__JobIdentifierType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<gridsam__JobIdentifierType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<gridsam__JobIdentifierType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTogridsam__JobIdentifierType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<gridsam__JobIdentifierType * > %p -> %p\n", q, p));
	*(std::vector<gridsam__JobIdentifierType * >*)p = *(std::vector<gridsam__JobIdentifierType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, std::vector<gridsam__JobDescriptionType * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, const std::vector<gridsam__JobDescriptionType * >*a)
{
	for (std::vector<gridsam__JobDescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTogridsam__JobDescriptionType(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, const char *tag, int id, const std::vector<gridsam__JobDescriptionType * >*a, const char *type)
{
	for (std::vector<gridsam__JobDescriptionType * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTogridsam__JobDescriptionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<gridsam__JobDescriptionType * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, const char *tag, std::vector<gridsam__JobDescriptionType * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(soap, -1)))
		return NULL;
	gridsam__JobDescriptionType *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_gridsam__JobDescriptionType, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobDescriptionType, sizeof(gridsam__JobDescriptionType), 1))
				break;
			if (!soap_in_PointerTogridsam__JobDescriptionType(soap, tag, NULL, "gridsam:JobDescriptionType"))
				break;
		}
		else
		{
			if (!soap_in_PointerTogridsam__JobDescriptionType(soap, tag, &n, "gridsam:JobDescriptionType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<gridsam__JobDescriptionType * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, std::vector<gridsam__JobDescriptionType * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<gridsam__JobDescriptionType * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTogridsam__JobDescriptionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<gridsam__JobDescriptionType * >;
		if (size)
			*size = sizeof(std::vector<gridsam__JobDescriptionType * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<gridsam__JobDescriptionType * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<gridsam__JobDescriptionType * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<gridsam__JobDescriptionType * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTogridsam__JobDescriptionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<gridsam__JobDescriptionType * > %p -> %p\n", q, p));
	*(std::vector<gridsam__JobDescriptionType * >*)p = *(std::vector<gridsam__JobDescriptionType * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, std::vector<_gridsam__Property * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, const std::vector<_gridsam__Property * >*a)
{
	for (std::vector<_gridsam__Property * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_gridsam__Property(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, const char *tag, int id, const std::vector<_gridsam__Property * >*a, const char *type)
{
	for (std::vector<_gridsam__Property * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_gridsam__Property(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_gridsam__Property * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, const char *tag, std::vector<_gridsam__Property * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_gridsam__Property(soap, -1)))
		return NULL;
	_gridsam__Property *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__gridsam__Property, SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Property, sizeof(_gridsam__Property), 1))
				break;
			if (!soap_in_PointerTo_gridsam__Property(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_gridsam__Property(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_gridsam__Property * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Property(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, std::vector<_gridsam__Property * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_gridsam__Property * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_gridsam__Property * >;
		if (size)
			*size = sizeof(std::vector<_gridsam__Property * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_gridsam__Property * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_gridsam__Property * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_gridsam__Property * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_gridsam__Property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_gridsam__Property * > %p -> %p\n", q, p));
	*(std::vector<_gridsam__Property * >*)p = *(std::vector<_gridsam__Property * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, std::vector<_gridsam__Stage * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, const std::vector<_gridsam__Stage * >*a)
{
	for (std::vector<_gridsam__Stage * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_gridsam__Stage(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, const char *tag, int id, const std::vector<_gridsam__Stage * >*a, const char *type)
{
	for (std::vector<_gridsam__Stage * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_gridsam__Stage(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_gridsam__Stage * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, const char *tag, std::vector<_gridsam__Stage * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_gridsam__Stage(soap, -1)))
		return NULL;
	_gridsam__Stage *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__gridsam__Stage, SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Stage, sizeof(_gridsam__Stage), 1))
				break;
			if (!soap_in_PointerTo_gridsam__Stage(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_gridsam__Stage(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_gridsam__Stage * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Stage(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, std::vector<_gridsam__Stage * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_gridsam__Stage * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_gridsam__Stage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_gridsam__Stage, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_gridsam__Stage * >;
		if (size)
			*size = sizeof(std::vector<_gridsam__Stage * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_gridsam__Stage * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_gridsam__Stage * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_gridsam__Stage * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_gridsam__Stage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_gridsam__Stage * > %p -> %p\n", q, p));
	*(std::vector<_gridsam__Stage * >*)p = *(std::vector<_gridsam__Stage * >*)q;
}

/* End of gridsamC.cpp */
