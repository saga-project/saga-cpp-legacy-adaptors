/* besStub.h
   Generated by gSOAP 2.7.11 from ./wsdl/wsdl/basic-execution-service.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef besStub_H
#define besStub_H
#include <vector>
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"

namespace bes {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_bes_bes__overall_state_enumeration
#define SOAP_TYPE_bes_bes__overall_state_enumeration (60)
/* bes:overall-state-enumeration */
enum bes__overall_state_enumeration {bes__overall_state_enumeration__New = 0, bes__overall_state_enumeration__Pending = 1, bes__overall_state_enumeration__StagingIn = 2, bes__overall_state_enumeration__ExecutionPending = 3, bes__overall_state_enumeration__Running = 4, bes__overall_state_enumeration__ExecutionComplete = 5, bes__overall_state_enumeration__StagingOut = 6, bes__overall_state_enumeration__CleaningUp = 7, bes__overall_state_enumeration__Suspended = 8, bes__overall_state_enumeration__ShuttingDown = 9, bes__overall_state_enumeration__NotKnown = 10, bes__overall_state_enumeration__Other = 11, bes__overall_state_enumeration__Done = 12, bes__overall_state_enumeration__Terminated = 13, bes__overall_state_enumeration__Exception = 14};
#endif

#ifndef SOAP_TYPE_bes_bes__data_staging_state_enumeration
#define SOAP_TYPE_bes_bes__data_staging_state_enumeration (61)
/* bes:data-staging-state-enumeration */
enum bes__data_staging_state_enumeration {bes__data_staging_state_enumeration__New = 0, bes__data_staging_state_enumeration__Pending = 1, bes__data_staging_state_enumeration__StagingIn = 2, bes__data_staging_state_enumeration__Waiting = 3, bes__data_staging_state_enumeration__StagingOut = 4, bes__data_staging_state_enumeration__Blocked = 5, bes__data_staging_state_enumeration__Suspended = 6, bes__data_staging_state_enumeration__Done = 7, bes__data_staging_state_enumeration__NotKnown = 8, bes__data_staging_state_enumeration__Terminated = 9, bes__data_staging_state_enumeration__Exception = 10};
#endif

#ifndef SOAP_TYPE_bes_bes__state_change_response_enumeration
#define SOAP_TYPE_bes_bes__state_change_response_enumeration (62)
/* bes:state-change-response-enumeration */
enum bes__state_change_response_enumeration {bes__state_change_response_enumeration__Succeeded = 0, bes__state_change_response_enumeration__Failed = 1};
#endif

#ifndef SOAP_TYPE_bes_addressing__RelationshipType
#define SOAP_TYPE_bes_addressing__RelationshipType (63)
/* addressing:RelationshipType */
enum addressing__RelationshipType {addressing__RelationshipType__http___x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f03_x002faddressing_x002freply = 0};
#endif

#ifndef SOAP_TYPE_bes_addressing__FaultCodesType
#define SOAP_TYPE_bes_addressing__FaultCodesType (64)
/* addressing:FaultCodesType */
enum addressing__FaultCodesType {addressing__FaultCodesType__addressing__InvalidMessageInformationHeader = 0, addressing__FaultCodesType__addressing__MessageInformationHeaderRequired = 1, addressing__FaultCodesType__addressing__DestinationUnreachable = 2, addressing__FaultCodesType__addressing__ActionNotSupported = 3, addressing__FaultCodesType__addressing__EndpointUnavailable = 4};
#endif

#ifndef SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration
#define SOAP_TYPE_bes_jsdl__ProcessorArchitectureEnumeration (65)
/* jsdl:ProcessorArchitectureEnumeration */
enum jsdl__ProcessorArchitectureEnumeration {jsdl__ProcessorArchitectureEnumeration__sparc = 0, jsdl__ProcessorArchitectureEnumeration__powerpc = 1, jsdl__ProcessorArchitectureEnumeration__x86 = 2, jsdl__ProcessorArchitectureEnumeration__x86_USCORE32 = 3, jsdl__ProcessorArchitectureEnumeration__x86_USCORE64 = 4, jsdl__ProcessorArchitectureEnumeration__parisc = 5, jsdl__ProcessorArchitectureEnumeration__mips = 6, jsdl__ProcessorArchitectureEnumeration__ia64 = 7, jsdl__ProcessorArchitectureEnumeration__arm = 8, jsdl__ProcessorArchitectureEnumeration__other = 9};
#endif

#ifndef SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration
#define SOAP_TYPE_bes_jsdl__OperatingSystemTypeEnumeration (66)
/* jsdl:OperatingSystemTypeEnumeration */
enum jsdl__OperatingSystemTypeEnumeration {jsdl__OperatingSystemTypeEnumeration__Unknown = 0, jsdl__OperatingSystemTypeEnumeration__MACOS = 1, jsdl__OperatingSystemTypeEnumeration__ATTUNIX = 2, jsdl__OperatingSystemTypeEnumeration__DGUX = 3, jsdl__OperatingSystemTypeEnumeration__DECNT = 4, jsdl__OperatingSystemTypeEnumeration__Tru64_USCOREUNIX = 5, jsdl__OperatingSystemTypeEnumeration__OpenVMS = 6, jsdl__OperatingSystemTypeEnumeration__HPUX = 7, jsdl__OperatingSystemTypeEnumeration__AIX = 8, jsdl__OperatingSystemTypeEnumeration__MVS = 9, jsdl__OperatingSystemTypeEnumeration__OS400 = 10, jsdl__OperatingSystemTypeEnumeration__OS_USCORE2 = 11, jsdl__OperatingSystemTypeEnumeration__JavaVM = 12, jsdl__OperatingSystemTypeEnumeration__MSDOS = 13, jsdl__OperatingSystemTypeEnumeration__WIN3x = 14, jsdl__OperatingSystemTypeEnumeration__WIN95 = 15, jsdl__OperatingSystemTypeEnumeration__WIN98 = 16, jsdl__OperatingSystemTypeEnumeration__WINNT = 17, jsdl__OperatingSystemTypeEnumeration__WINCE = 18, jsdl__OperatingSystemTypeEnumeration__NCR3000 = 19, jsdl__OperatingSystemTypeEnumeration__NetWare = 20, jsdl__OperatingSystemTypeEnumeration__OSF = 21, jsdl__OperatingSystemTypeEnumeration__DC_USCOREOS = 22, jsdl__OperatingSystemTypeEnumeration__Reliant_USCOREUNIX = 23, jsdl__OperatingSystemTypeEnumeration__SCO_USCOREUnixWare = 24, jsdl__OperatingSystemTypeEnumeration__SCO_USCOREOpenServer = 25, jsdl__OperatingSystemTypeEnumeration__Sequent = 26, jsdl__OperatingSystemTypeEnumeration__IRIX = 27, jsdl__OperatingSystemTypeEnumeration__Solaris = 28, jsdl__OperatingSystemTypeEnumeration__SunOS = 29, jsdl__OperatingSystemTypeEnumeration__U6000 = 30, jsdl__OperatingSystemTypeEnumeration__ASERIES = 31, jsdl__OperatingSystemTypeEnumeration__TandemNSK = 32, jsdl__OperatingSystemTypeEnumeration__TandemNT = 33, jsdl__OperatingSystemTypeEnumeration__BS2000 = 34, jsdl__OperatingSystemTypeEnumeration__LINUX = 35, jsdl__OperatingSystemTypeEnumeration__Lynx = 36, jsdl__OperatingSystemTypeEnumeration__XENIX = 37, jsdl__OperatingSystemTypeEnumeration__VM = 38, jsdl__OperatingSystemTypeEnumeration__Interactive_USCOREUNIX = 39, jsdl__OperatingSystemTypeEnumeration__BSDUNIX = 40, jsdl__OperatingSystemTypeEnumeration__FreeBSD = 41, jsdl__OperatingSystemTypeEnumeration__NetBSD = 42, jsdl__OperatingSystemTypeEnumeration__GNU_USCOREHurd = 43, jsdl__OperatingSystemTypeEnumeration__OS9 = 44, jsdl__OperatingSystemTypeEnumeration__MACH_USCOREKernel = 45, jsdl__OperatingSystemTypeEnumeration__Inferno = 46, jsdl__OperatingSystemTypeEnumeration__QNX = 47, jsdl__OperatingSystemTypeEnumeration__EPOC = 48, jsdl__OperatingSystemTypeEnumeration__IxWorks = 49, jsdl__OperatingSystemTypeEnumeration__VxWorks = 50, jsdl__OperatingSystemTypeEnumeration__MiNT = 51, jsdl__OperatingSystemTypeEnumeration__BeOS = 52, jsdl__OperatingSystemTypeEnumeration__HP_USCOREMPE = 53, jsdl__OperatingSystemTypeEnumeration__NextStep = 54, jsdl__OperatingSystemTypeEnumeration__PalmPilot = 55, jsdl__OperatingSystemTypeEnumeration__Rhapsody = 56, jsdl__OperatingSystemTypeEnumeration__Windows_USCORE2000 = 57, jsdl__OperatingSystemTypeEnumeration__Dedicated = 58, jsdl__OperatingSystemTypeEnumeration__OS_USCORE390 = 59, jsdl__OperatingSystemTypeEnumeration__VSE = 60, jsdl__OperatingSystemTypeEnumeration__TPF = 61, jsdl__OperatingSystemTypeEnumeration__Windows_USCORER_USCOREMe = 62, jsdl__OperatingSystemTypeEnumeration__Caldera_USCOREOpen_USCOREUNIX = 63, jsdl__OperatingSystemTypeEnumeration__OpenBSD = 64, jsdl__OperatingSystemTypeEnumeration__Not_USCOREApplicable = 65, jsdl__OperatingSystemTypeEnumeration__Windows_USCOREXP = 66, jsdl__OperatingSystemTypeEnumeration__z_USCOREOS = 67, jsdl__OperatingSystemTypeEnumeration__other = 68};
#endif

#ifndef SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration
#define SOAP_TYPE_bes_jsdl__FileSystemTypeEnumeration (67)
/* jsdl:FileSystemTypeEnumeration */
enum jsdl__FileSystemTypeEnumeration {jsdl__FileSystemTypeEnumeration__swap = 0, jsdl__FileSystemTypeEnumeration__temporary = 1, jsdl__FileSystemTypeEnumeration__spool = 2, jsdl__FileSystemTypeEnumeration__normal = 3};
#endif

#ifndef SOAP_TYPE_bes_jsdl__CreationFlagEnumeration
#define SOAP_TYPE_bes_jsdl__CreationFlagEnumeration (68)
/* jsdl:CreationFlagEnumeration */
enum jsdl__CreationFlagEnumeration {jsdl__CreationFlagEnumeration__overwrite = 0, jsdl__CreationFlagEnumeration__append = 1, jsdl__CreationFlagEnumeration__dontOverwrite = 2};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_bes_bes__overall_status_type
#define SOAP_TYPE_bes_bes__overall_status_type (14)
/* bes:overall-status-type */
class SOAP_CMAC bes__overall_status_type
{
public:
	enum bes__overall_state_enumeration state;	/* required attribute */
	enum bes__overall_state_enumeration *last_state;	/* optional attribute */
	std::string *other;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_bes_bes__overall_status_type */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__overall_status_type() : state((enum bes__overall_state_enumeration)0), last_state(NULL), other(NULL), soap(NULL) { }
	virtual ~bes__overall_status_type() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__data_stage_status_type
#define SOAP_TYPE_bes_bes__data_stage_status_type (15)
/* bes:data-stage-status-type */
class SOAP_CMAC bes__data_stage_status_type
{
public:
	std::string id;	/* required attribute */
	enum bes__data_staging_state_enumeration state;	/* required attribute */
	enum bes__data_staging_state_enumeration *last_state;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_bes_bes__data_stage_status_type */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__data_stage_status_type() : state((enum bes__data_staging_state_enumeration)0), last_state(NULL), soap(NULL) { }
	virtual ~bes__data_stage_status_type() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__activity_status_type
#define SOAP_TYPE_bes_bes__activity_status_type (16)
/* bes:activity-status-type */
class SOAP_CMAC bes__activity_status_type
{
public:
	class addressing__EndpointReferenceType *activity_identifier;	/* required element of type addressing:EndpointReferenceType */
	bes__overall_status_type *overall_status;	/* required element of type bes:overall-status-type */
	std::vector<bes__data_stage_status_type * >data_stage_status;	/* optional element of type bes:data-stage-status-type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_bes_bes__activity_status_type */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__activity_status_type() : activity_identifier(NULL), overall_status(NULL), soap(NULL) { }
	virtual ~bes__activity_status_type() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__requested_state_change_type
#define SOAP_TYPE_bes_bes__requested_state_change_type (17)
/* bes:requested-state-change-type */
class SOAP_CMAC bes__requested_state_change_type
{
public:
	enum bes__overall_state_enumeration *from;	/* optional attribute */
	enum bes__overall_state_enumeration to;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_bes_bes__requested_state_change_type */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__requested_state_change_type() : from(NULL), to((enum bes__overall_state_enumeration)0), soap(NULL) { }
	virtual ~bes__requested_state_change_type() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__state_change_request_type
#define SOAP_TYPE_bes_bes__state_change_request_type (18)
/* bes:state-change-request-type */
class SOAP_CMAC bes__state_change_request_type
{
public:
	addressing__EndpointReferenceType *activity_identifier;	/* required element of type addressing:EndpointReferenceType */
	bes__requested_state_change_type *requested_state_change;	/* required element of type bes:requested-state-change-type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_bes_bes__state_change_request_type */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__state_change_request_type() : activity_identifier(NULL), requested_state_change(NULL), soap(NULL) { }
	virtual ~bes__state_change_request_type() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__state_change_response_type
#define SOAP_TYPE_bes_bes__state_change_response_type (19)
/* bes:state-change-response-type */
class SOAP_CMAC bes__state_change_response_type
{
public:
	addressing__EndpointReferenceType *activity_identifier;	/* required element of type addressing:EndpointReferenceType */
	std::string *description;	/* optional element of type xsd:string */
	enum bes__state_change_response_enumeration response;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_bes_bes__state_change_response_type */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__state_change_response_type() : activity_identifier(NULL), description(NULL), response((enum bes__state_change_response_enumeration)0), soap(NULL) { }
	virtual ~bes__state_change_response_type() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__activity_jsdl_document_type
#define SOAP_TYPE_bes_bes__activity_jsdl_document_type (20)
/* bes:activity-jsdl-document-type */
class SOAP_CMAC bes__activity_jsdl_document_type
{
public:
	addressing__EndpointReferenceType *activity_identifier;	/* required element of type addressing:EndpointReferenceType */
	class jsdl__JobDefinition_USCOREType *jsdl__JobDefinition;	/* required element of type jsdl:JobDefinition_Type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_bes_bes__activity_jsdl_document_type */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__activity_jsdl_document_type() : activity_identifier(NULL), jsdl__JobDefinition(NULL), soap(NULL) { }
	virtual ~bes__activity_jsdl_document_type() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType
#define SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType (21)
/* bes:NotAcceptingNewActivitiesFaultType */
class SOAP_CMAC bes__NotAcceptingNewActivitiesFaultType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_bes_bes__NotAcceptingNewActivitiesFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__NotAcceptingNewActivitiesFaultType() : soap(NULL) { }
	virtual ~bes__NotAcceptingNewActivitiesFaultType() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType
#define SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType (22)
/* bes:BadlyFormedJSDLDocumentFaultType */
class SOAP_CMAC bes__BadlyFormedJSDLDocumentFaultType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_bes_bes__BadlyFormedJSDLDocumentFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__BadlyFormedJSDLDocumentFaultType() : soap(NULL) { }
	virtual ~bes__BadlyFormedJSDLDocumentFaultType() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType
#define SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType (23)
/* bes:UnsupportedJSDLFaultType */
class SOAP_CMAC bes__UnsupportedJSDLFaultType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_bes_bes__UnsupportedJSDLFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__UnsupportedJSDLFaultType() : soap(NULL) { }
	virtual ~bes__UnsupportedJSDLFaultType() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType
#define SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType (24)
/* bes:UnsupportedFeatureFaultType */
class SOAP_CMAC bes__UnsupportedFeatureFaultType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_bes_bes__UnsupportedFeatureFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__UnsupportedFeatureFaultType() : soap(NULL) { }
	virtual ~bes__UnsupportedFeatureFaultType() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__JobSpecificationFaultType
#define SOAP_TYPE_bes_bes__JobSpecificationFaultType (25)
/* bes:JobSpecificationFaultType */
class SOAP_CMAC bes__JobSpecificationFaultType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_bes_bes__JobSpecificationFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__JobSpecificationFaultType() : soap(NULL) { }
	virtual ~bes__JobSpecificationFaultType() { }
};
#endif

#ifndef SOAP_TYPE_bes_bes__BackendFaultType
#define SOAP_TYPE_bes_bes__BackendFaultType (26)
/* bes:BackendFaultType */
class SOAP_CMAC bes__BackendFaultType
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_bes_bes__BackendFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         bes__BackendFaultType() : soap(NULL) { }
	virtual ~bes__BackendFaultType() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__CreateActivityFromJSDL
#define SOAP_TYPE_bes__bes__CreateActivityFromJSDL (27)
/* bes:CreateActivityFromJSDL */
class SOAP_CMAC _bes__CreateActivityFromJSDL
{
public:
	jsdl__JobDefinition_USCOREType *jsdl__JobDefinition;	/* required element of type jsdl:JobDefinition_Type */
	bool create_suspended;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_bes__bes__CreateActivityFromJSDL */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__CreateActivityFromJSDL() : jsdl__JobDefinition(NULL), create_suspended((bool)0), soap(NULL) { }
	virtual ~_bes__CreateActivityFromJSDL() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse
#define SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse (28)
/* bes:CreateActivityFromJSDLResponse */
class SOAP_CMAC _bes__CreateActivityFromJSDLResponse
{
public:
	addressing__EndpointReferenceType *activity_identifier;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type addressing:EndpointReferenceType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_bes__bes__CreateActivityFromJSDLResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__CreateActivityFromJSDLResponse() : activity_identifier(NULL), soap(NULL) { }
	virtual ~_bes__CreateActivityFromJSDLResponse() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__GetActivityStatus
#define SOAP_TYPE_bes__bes__GetActivityStatus (29)
/* bes:GetActivityStatus */
class SOAP_CMAC _bes__GetActivityStatus
{
public:
	std::vector<addressing__EndpointReferenceType * >activity_identifier;	/* optional element of type addressing:EndpointReferenceType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_bes__bes__GetActivityStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__GetActivityStatus() : soap(NULL) { }
	virtual ~_bes__GetActivityStatus() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__GetActivityStatusResponse
#define SOAP_TYPE_bes__bes__GetActivityStatusResponse (30)
/* bes:GetActivityStatusResponse */
class SOAP_CMAC _bes__GetActivityStatusResponse
{
public:
	std::vector<bes__activity_status_type * >activity_status;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type bes:activity-status-type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_bes__bes__GetActivityStatusResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__GetActivityStatusResponse() : soap(NULL) { }
	virtual ~_bes__GetActivityStatusResponse() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__RequestActivityStateChanges
#define SOAP_TYPE_bes__bes__RequestActivityStateChanges (31)
/* bes:RequestActivityStateChanges */
class SOAP_CMAC _bes__RequestActivityStateChanges
{
public:
	std::vector<bes__state_change_request_type * >state_change_request;	/* optional element of type bes:state-change-request-type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_bes__bes__RequestActivityStateChanges */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__RequestActivityStateChanges() : soap(NULL) { }
	virtual ~_bes__RequestActivityStateChanges() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse
#define SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse (32)
/* bes:RequestActivityStateChangesResponse */
class SOAP_CMAC _bes__RequestActivityStateChangesResponse
{
public:
	std::vector<bes__state_change_response_type * >state_change_response;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type bes:state-change-response-type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_bes__bes__RequestActivityStateChangesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__RequestActivityStateChangesResponse() : soap(NULL) { }
	virtual ~_bes__RequestActivityStateChangesResponse() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse
#define SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse (33)
/* bes:IsAcceptingNewActivitiesResponse */
class SOAP_CMAC _bes__IsAcceptingNewActivitiesResponse
{
public:
	bool response;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_bes__bes__IsAcceptingNewActivitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__IsAcceptingNewActivitiesResponse() : response((bool)0), soap(NULL) { }
	virtual ~_bes__IsAcceptingNewActivitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__GetActivityJSDLDocuments
#define SOAP_TYPE_bes__bes__GetActivityJSDLDocuments (34)
/* bes:GetActivityJSDLDocuments */
class SOAP_CMAC _bes__GetActivityJSDLDocuments
{
public:
	std::vector<addressing__EndpointReferenceType * >activity_identifier;	/* optional element of type addressing:EndpointReferenceType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_bes__bes__GetActivityJSDLDocuments */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__GetActivityJSDLDocuments() : soap(NULL) { }
	virtual ~_bes__GetActivityJSDLDocuments() { }
};
#endif

#ifndef SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse
#define SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse (35)
/* bes:GetActivityJSDLDocumentsResponse */
class SOAP_CMAC _bes__GetActivityJSDLDocumentsResponse
{
public:
	std::vector<bes__activity_jsdl_document_type * >activity_jsdl_document;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type bes:activity-jsdl-document-type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_bes__bes__GetActivityJSDLDocumentsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _bes__GetActivityJSDLDocumentsResponse() : soap(NULL) { }
	virtual ~_bes__GetActivityJSDLDocumentsResponse() { }
};
#endif

#ifndef SOAP_TYPE_bes_addressing__EndpointReferenceType
#define SOAP_TYPE_bes_addressing__EndpointReferenceType (36)
/* addressing:EndpointReferenceType */
class SOAP_CMAC addressing__EndpointReferenceType
{
public:
	class addressing__AttributedURIType *Address;	/* required element of type addressing:AttributedURIType */
	class addressing__ReferenceParametersType *ReferenceParameters;	/* optional element of type addressing:ReferenceParametersType */
	class addressing__MetadataType *addressing__Metadata;	/* optional element of type addressing:MetadataType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_bes_addressing__EndpointReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         addressing__EndpointReferenceType() : Address(NULL), ReferenceParameters(NULL), addressing__Metadata(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~addressing__EndpointReferenceType() { }
};
#endif

#ifndef SOAP_TYPE_bes_addressing__ReferenceParametersType
#define SOAP_TYPE_bes_addressing__ReferenceParametersType (37)
/* addressing:ReferenceParametersType */
class SOAP_CMAC addressing__ReferenceParametersType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_bes_addressing__ReferenceParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         addressing__ReferenceParametersType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~addressing__ReferenceParametersType() { }
};
#endif

#ifndef SOAP_TYPE_bes_addressing__MetadataType
#define SOAP_TYPE_bes_addressing__MetadataType (38)
/* addressing:MetadataType */
class SOAP_CMAC addressing__MetadataType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_bes_addressing__MetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         addressing__MetadataType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~addressing__MetadataType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__Range_USCOREType
#define SOAP_TYPE_bes_jsdl__Range_USCOREType (44)
/* jsdl:Range_Type */
class SOAP_CMAC jsdl__Range_USCOREType
{
public:
	class jsdl__Boundary_USCOREType *LowerBound;	/* required element of type jsdl:Boundary_Type */
	jsdl__Boundary_USCOREType *UpperBound;	/* required element of type jsdl:Boundary_Type */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_bes_jsdl__Range_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Range_USCOREType() : LowerBound(NULL), UpperBound(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Range_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__RangeValue_USCOREType
#define SOAP_TYPE_bes_jsdl__RangeValue_USCOREType (45)
/* jsdl:RangeValue_Type */
class SOAP_CMAC jsdl__RangeValue_USCOREType
{
public:
	jsdl__Boundary_USCOREType *UpperBoundedRange;	/* optional element of type jsdl:Boundary_Type */
	jsdl__Boundary_USCOREType *LowerBoundedRange;	/* optional element of type jsdl:Boundary_Type */
	std::vector<class jsdl__Exact_USCOREType * >Exact;	/* optional element of type jsdl:Exact_Type */
	std::vector<jsdl__Range_USCOREType * >Range;	/* optional element of type jsdl:Range_Type */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_bes_jsdl__RangeValue_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__RangeValue_USCOREType() : UpperBoundedRange(NULL), LowerBoundedRange(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__RangeValue_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType
#define SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType (46)
/* jsdl:JobDefinition_Type */
class SOAP_CMAC jsdl__JobDefinition_USCOREType
{
public:
	class jsdl__JobDescription_USCOREType *jsdl__JobDescription;	/* required element of type jsdl:JobDescription_Type */
	std::vector<char * >__any;
	std::string *id;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_bes_jsdl__JobDefinition_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobDefinition_USCOREType() : jsdl__JobDescription(NULL), id(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__JobDefinition_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__JobDescription_USCOREType
#define SOAP_TYPE_bes_jsdl__JobDescription_USCOREType (47)
/* jsdl:JobDescription_Type */
class SOAP_CMAC jsdl__JobDescription_USCOREType
{
public:
	class jsdl__JobIdentification_USCOREType *jsdl__JobIdentification;	/* optional element of type jsdl:JobIdentification_Type */
	class jsdl__Application_USCOREType *jsdl__Application;	/* optional element of type jsdl:Application_Type */
	class jsdl__Resources_USCOREType *jsdl__Resources;	/* optional element of type jsdl:Resources_Type */
	std::vector<class jsdl__DataStaging_USCOREType * >jsdl__DataStaging;	/* optional element of type jsdl:DataStaging_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_bes_jsdl__JobDescription_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobDescription_USCOREType() : jsdl__JobIdentification(NULL), jsdl__Application(NULL), jsdl__Resources(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__JobDescription_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType
#define SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType (48)
/* jsdl:JobIdentification_Type */
class SOAP_CMAC jsdl__JobIdentification_USCOREType
{
public:
	std::string *jsdl__JobName;	/* optional element of type xsd:string */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::vector<std::string >jsdl__JobAnnotation;	/* optional element of type xsd:string */
	std::vector<std::string >jsdl__JobProject;	/* optional element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_bes_jsdl__JobIdentification_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__JobIdentification_USCOREType() : jsdl__JobName(NULL), jsdl__Description(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__JobIdentification_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__Application_USCOREType
#define SOAP_TYPE_bes_jsdl__Application_USCOREType (49)
/* jsdl:Application_Type */
class SOAP_CMAC jsdl__Application_USCOREType
{
public:
	std::string *jsdl__ApplicationName;	/* optional element of type xsd:string */
	std::string *jsdl__ApplicationVersion;	/* optional element of type xsd:string */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_bes_jsdl__Application_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Application_USCOREType() : jsdl__ApplicationName(NULL), jsdl__ApplicationVersion(NULL), jsdl__Description(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Application_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__Resources_USCOREType
#define SOAP_TYPE_bes_jsdl__Resources_USCOREType (50)
/* jsdl:Resources_Type */
class SOAP_CMAC jsdl__Resources_USCOREType
{
public:
	class jsdl__CandidateHosts_USCOREType *jsdl__CandidateHosts;	/* optional element of type jsdl:CandidateHosts_Type */
	std::vector<class jsdl__FileSystem_USCOREType * >jsdl__FileSystem;	/* optional element of type jsdl:FileSystem_Type */
	bool *jsdl__ExclusiveExecution;	/* optional element of type xsd:boolean */
	class jsdl__OperatingSystem_USCOREType *jsdl__OperatingSystem;	/* optional element of type jsdl:OperatingSystem_Type */
	class jsdl__CPUArchitecture_USCOREType *jsdl__CPUArchitecture;	/* optional element of type jsdl:CPUArchitecture_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualCPUSpeed;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualCPUTime;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualCPUCount;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualNetworkBandwidth;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualPhysicalMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualVirtualMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__IndividualDiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalCPUTime;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalCPUCount;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalPhysicalMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalVirtualMemory;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalDiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	jsdl__RangeValue_USCOREType *jsdl__TotalResourceCount;	/* optional element of type jsdl:RangeValue_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_bes_jsdl__Resources_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Resources_USCOREType() : jsdl__CandidateHosts(NULL), jsdl__ExclusiveExecution(NULL), jsdl__OperatingSystem(NULL), jsdl__CPUArchitecture(NULL), jsdl__IndividualCPUSpeed(NULL), jsdl__IndividualCPUTime(NULL), jsdl__IndividualCPUCount(NULL), jsdl__IndividualNetworkBandwidth(NULL), jsdl__IndividualPhysicalMemory(NULL), jsdl__IndividualVirtualMemory(NULL), jsdl__IndividualDiskSpace(NULL), jsdl__TotalCPUTime(NULL), jsdl__TotalCPUCount(NULL), jsdl__TotalPhysicalMemory(NULL), jsdl__TotalVirtualMemory(NULL), jsdl__TotalDiskSpace(NULL), jsdl__TotalResourceCount(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Resources_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType
#define SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType (51)
/* jsdl:CandidateHosts_Type */
class SOAP_CMAC jsdl__CandidateHosts_USCOREType
{
public:
	std::vector<std::string >jsdl__HostName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_bes_jsdl__CandidateHosts_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__CandidateHosts_USCOREType() : soap(NULL) { }
	virtual ~jsdl__CandidateHosts_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType
#define SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType (52)
/* jsdl:CPUArchitecture_Type */
class SOAP_CMAC jsdl__CPUArchitecture_USCOREType
{
public:
	enum jsdl__ProcessorArchitectureEnumeration jsdl__CPUArchitectureName;	/* required element of type jsdl:ProcessorArchitectureEnumeration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_bes_jsdl__CPUArchitecture_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__CPUArchitecture_USCOREType() : jsdl__CPUArchitectureName((enum jsdl__ProcessorArchitectureEnumeration)0), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__CPUArchitecture_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__FileSystem_USCOREType
#define SOAP_TYPE_bes_jsdl__FileSystem_USCOREType (53)
/* jsdl:FileSystem_Type */
class SOAP_CMAC jsdl__FileSystem_USCOREType
{
public:
	enum jsdl__FileSystemTypeEnumeration *jsdl__FileSystemType;	/* optional element of type jsdl:FileSystemTypeEnumeration */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::string *jsdl__MountPoint;	/* optional element of type xsd:string */
	jsdl__RangeValue_USCOREType *jsdl__DiskSpace;	/* optional element of type jsdl:RangeValue_Type */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_bes_jsdl__FileSystem_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__FileSystem_USCOREType() : jsdl__FileSystemType(NULL), jsdl__Description(NULL), jsdl__MountPoint(NULL), jsdl__DiskSpace(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__FileSystem_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType
#define SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType (54)
/* jsdl:OperatingSystem_Type */
class SOAP_CMAC jsdl__OperatingSystem_USCOREType
{
public:
	class jsdl__OperatingSystemType_USCOREType *jsdl__OperatingSystemType;	/* optional element of type jsdl:OperatingSystemType_Type */
	std::string *jsdl__OperatingSystemVersion;	/* optional element of type xsd:string */
	std::string *jsdl__Description;	/* optional element of type jsdl:Description_Type */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_bes_jsdl__OperatingSystem_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__OperatingSystem_USCOREType() : jsdl__OperatingSystemType(NULL), jsdl__OperatingSystemVersion(NULL), jsdl__Description(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__OperatingSystem_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType
#define SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType (55)
/* jsdl:OperatingSystemType_Type */
class SOAP_CMAC jsdl__OperatingSystemType_USCOREType
{
public:
	enum jsdl__OperatingSystemTypeEnumeration jsdl__OperatingSystemName;	/* required element of type jsdl:OperatingSystemTypeEnumeration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_bes_jsdl__OperatingSystemType_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__OperatingSystemType_USCOREType() : jsdl__OperatingSystemName((enum jsdl__OperatingSystemTypeEnumeration)0), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__OperatingSystemType_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__DataStaging_USCOREType
#define SOAP_TYPE_bes_jsdl__DataStaging_USCOREType (56)
/* jsdl:DataStaging_Type */
class SOAP_CMAC jsdl__DataStaging_USCOREType
{
public:
	std::string jsdl__FileName;	/* required element of type xsd:string */
	std::string *jsdl__FilesystemName;	/* optional element of type xsd:NCName */
	enum jsdl__CreationFlagEnumeration jsdl__CreationFlag;	/* required element of type jsdl:CreationFlagEnumeration */
	bool *jsdl__DeleteOnTermination;	/* optional element of type xsd:boolean */
	class jsdl__SourceTarget_USCOREType *jsdl__Source;	/* optional element of type jsdl:SourceTarget_Type */
	jsdl__SourceTarget_USCOREType *jsdl__Target;	/* optional element of type jsdl:SourceTarget_Type */
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_bes_jsdl__DataStaging_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__DataStaging_USCOREType() : jsdl__FilesystemName(NULL), jsdl__CreationFlag((enum jsdl__CreationFlagEnumeration)0), jsdl__DeleteOnTermination(NULL), jsdl__Source(NULL), jsdl__Target(NULL), name(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__DataStaging_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType
#define SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType (57)
/* jsdl:SourceTarget_Type */
class SOAP_CMAC jsdl__SourceTarget_USCOREType
{
public:
	std::string *jsdl__URI;	/* optional element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_bes_jsdl__SourceTarget_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__SourceTarget_USCOREType() : jsdl__URI(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__SourceTarget_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_addressing__RelatesToType
#define SOAP_TYPE_bes_addressing__RelatesToType (39)
/* Primitive addressing:RelatesToType schema type: */
class SOAP_CMAC addressing__RelatesToType
{
public:
	std::string __item;
	std::string RelationshipType;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_bes_addressing__RelatesToType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         addressing__RelatesToType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~addressing__RelatesToType() { }
};
#endif

#ifndef SOAP_TYPE_bes_addressing__AttributedURIType
#define SOAP_TYPE_bes_addressing__AttributedURIType (40)
/* Primitive addressing:AttributedURIType schema type: */
class SOAP_CMAC addressing__AttributedURIType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_bes_addressing__AttributedURIType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         addressing__AttributedURIType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~addressing__AttributedURIType() { }
};
#endif

#ifndef SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType
#define SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType (41)
/* Primitive addressing:AttributedNonNegativeIntegerType schema type: */
class SOAP_CMAC addressing__AttributedNonNegativeIntegerType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_bes_addressing__AttributedNonNegativeIntegerType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         addressing__AttributedNonNegativeIntegerType() : __anyAttribute(NULL), soap(NULL) { }
	virtual ~addressing__AttributedNonNegativeIntegerType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__Boundary_USCOREType
#define SOAP_TYPE_bes_jsdl__Boundary_USCOREType (42)
/* Primitive jsdl:Boundary_Type schema type: */
class SOAP_CMAC jsdl__Boundary_USCOREType
{
public:
	double __item;
	bool *exclusiveBound;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_bes_jsdl__Boundary_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Boundary_USCOREType() : __item(0), exclusiveBound(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Boundary_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_jsdl__Exact_USCOREType
#define SOAP_TYPE_bes_jsdl__Exact_USCOREType (43)
/* Primitive jsdl:Exact_Type schema type: */
class SOAP_CMAC jsdl__Exact_USCOREType
{
public:
	double __item;
	double *epsilon;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_bes_jsdl__Exact_USCOREType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         jsdl__Exact_USCOREType() : __item(0), epsilon(NULL), __anyAttribute(NULL), soap(NULL) { }
	virtual ~jsdl__Exact_USCOREType() { }
};
#endif

#ifndef SOAP_TYPE_bes_SOAP_ENV__Detail
#define SOAP_TYPE_bes_SOAP_ENV__Detail (122)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	bes__BackendFaultType *bes__BackendFault;	/* optional element of type bes:BackendFaultType */
	bes__BadlyFormedJSDLDocumentFaultType *bes__BadlyFormedJSDLDocumentFault;	/* optional element of type bes:BadlyFormedJSDLDocumentFaultType */
	bes__JobSpecificationFaultType *bes__JobSpecificationFault;	/* optional element of type bes:JobSpecificationFaultType */
	bes__NotAcceptingNewActivitiesFaultType *bes__NotAcceptingNewActivitiesFault;	/* optional element of type bes:NotAcceptingNewActivitiesFaultType */
	bes__UnsupportedFeatureFaultType *bes__UnsupportedFeatureFault;	/* optional element of type bes:UnsupportedFeatureFaultType */
	bes__UnsupportedJSDLFaultType *bes__UnsupportedJSDLFault;	/* optional element of type bes:UnsupportedJSDLFaultType */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_bes___bes__CreateActivityFromJSDL
#define SOAP_TYPE_bes___bes__CreateActivityFromJSDL (134)
/* Operation wrapper: */
struct __bes__CreateActivityFromJSDL
{
public:
	_bes__CreateActivityFromJSDL *bes__CreateActivityFromJSDL;	/* optional element of type bes:CreateActivityFromJSDL */
};
#endif

#ifndef SOAP_TYPE_bes___bes__GetActivityStatus
#define SOAP_TYPE_bes___bes__GetActivityStatus (138)
/* Operation wrapper: */
struct __bes__GetActivityStatus
{
public:
	_bes__GetActivityStatus *bes__GetActivityStatus;	/* optional element of type bes:GetActivityStatus */
};
#endif

#ifndef SOAP_TYPE_bes___bes__RequestActivityStateChanges
#define SOAP_TYPE_bes___bes__RequestActivityStateChanges (142)
/* Operation wrapper: */
struct __bes__RequestActivityStateChanges
{
public:
	_bes__RequestActivityStateChanges *bes__RequestActivityStateChanges;	/* optional element of type bes:RequestActivityStateChanges */
};
#endif

#ifndef SOAP_TYPE_bes___bes__StopAcceptingNewActivities
#define SOAP_TYPE_bes___bes__StopAcceptingNewActivities (145)
/* Operation wrapper: */
struct __bes__StopAcceptingNewActivities
{
public:
	char *bes__StopAcceptingNewActivities;	/* optional element of type xsd:anyType */
};
#endif

#ifndef SOAP_TYPE_bes___bes__StartAcceptingNewActivities
#define SOAP_TYPE_bes___bes__StartAcceptingNewActivities (147)
/* Operation wrapper: */
struct __bes__StartAcceptingNewActivities
{
public:
	char *bes__StartAcceptingNewActivities;	/* optional element of type xsd:anyType */
};
#endif

#ifndef SOAP_TYPE_bes___bes__IsAcceptingNewActivities
#define SOAP_TYPE_bes___bes__IsAcceptingNewActivities (150)
/* Operation wrapper: */
struct __bes__IsAcceptingNewActivities
{
public:
	char *bes__IsAcceptingNewActivities;	/* optional element of type xsd:anyType */
};
#endif

#ifndef SOAP_TYPE_bes___bes__GetActivityJSDLDocuments
#define SOAP_TYPE_bes___bes__GetActivityJSDLDocuments (154)
/* Operation wrapper: */
struct __bes__GetActivityJSDLDocuments
{
public:
	_bes__GetActivityJSDLDocuments *bes__GetActivityJSDLDocuments;	/* optional element of type bes:GetActivityJSDLDocuments */
};
#endif

#ifndef SOAP_TYPE_bes_SOAP_ENV__Header
#define SOAP_TYPE_bes_SOAP_ENV__Header (155)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_bes_SOAP_ENV__Code
#define SOAP_TYPE_bes_SOAP_ENV__Code (156)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_bes_SOAP_ENV__Reason
#define SOAP_TYPE_bes_SOAP_ENV__Reason (158)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_bes_SOAP_ENV__Fault
#define SOAP_TYPE_bes_SOAP_ENV__Fault (159)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_bes__QName
#define SOAP_TYPE_bes__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_bes__XML
#define SOAP_TYPE_bes__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_bes_xsd__ID
#define SOAP_TYPE_bes_xsd__ID (9)
typedef std::string xsd__ID;
#endif

#ifndef SOAP_TYPE_bes_xsd__NCName
#define SOAP_TYPE_bes_xsd__NCName (10)
typedef std::string xsd__NCName;
#endif

#ifndef SOAP_TYPE_bes_xsd__QName
#define SOAP_TYPE_bes_xsd__QName (11)
typedef std::string xsd__QName;
#endif

#ifndef SOAP_TYPE_bes_xsd__anyURI
#define SOAP_TYPE_bes_xsd__anyURI (12)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_bes_xsd__nonNegativeInteger
#define SOAP_TYPE_bes_xsd__nonNegativeInteger (13)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum
#define SOAP_TYPE_bes_addressing__RelationshipTypeOpenEnum (58)
typedef std::string addressing__RelationshipTypeOpenEnum;
#endif

#ifndef SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType
#define SOAP_TYPE_bes_addressing__FaultCodesOpenEnumType (59)
typedef std::string addressing__FaultCodesOpenEnumType;
#endif

#ifndef SOAP_TYPE_bes_jsdl__Description_USCOREType
#define SOAP_TYPE_bes_jsdl__Description_USCOREType (69)
typedef std::string jsdl__Description_USCOREType;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace bes


#endif

/* End of besStub.h */
